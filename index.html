



<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Samurai Warrior Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        /* Home Screen */
        #homeScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a0a0a 0%, #2d1b1b 50%, #1a0a0a 100%);
            display: flex;
            z-index: 100;
        }
        #homeScreen h1 {
            font-size: 64px;
            color: #ff4444;
            text-shadow: 0 0 20px #ff0000, 0 0 40px #880000;
            margin-bottom: 5px;
            text-align: center;
        }
        #homeScreen h2 {
            font-size: 20px;
            color: #888;
            margin-bottom: 30px;
            text-align: center;
        }
        #homeContent {
            display: flex;
            flex: 1;
            padding: 20px 40px;
        }
        #leftPanel {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            padding-top: 20px;
            overflow-y: auto;
        }
        #rightPanel {
            width: 320px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding-left: 40px;
        }
        #startBtn {
            padding: 25px 70px;
            font-size: 32px;
            background: linear-gradient(to bottom, #cc0000, #880000);
            color: white;
            border: 3px solid #ff4444;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 30px;
        }
        #startBtn:hover {
            background: linear-gradient(to bottom, #ff0000, #aa0000);
            transform: scale(1.1);
            box-shadow: 0 0 30px #ff0000;
        }
        #selectMapBtn {
            padding: 12px 30px;
            font-size: 18px;
            background: linear-gradient(to bottom, #225522, #113311);
            color: #44ff44;
            border: 2px solid #44ff44;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 10px;
        }
        #selectMapBtn:hover {
            background: linear-gradient(to bottom, #336633, #224422);
            box-shadow: 0 0 15px #44ff44;
        }
        #selectedMapInfo {
            color: #44ff44;
            font-size: 14px;
            margin-bottom: 15px;
        }
        .hidden { display: none !important; }
        /* Game UI */
        #gameUI {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        #gameUI > * { pointer-events: auto; }
        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
        }
        #waveInfo {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
            text-align: right;
        }
        #waveInfo h2 { margin: 0 0 10px 0; color: #ff6666; }
        #statsPanel {
            position: absolute;
            top: 100px;
            right: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 8px;
            pointer-events: none;
            font-size: 12px;
            font-family: monospace;
            min-width: 160px;
        }
        #statsPanel h4 {
            margin: 0 0 8px 0;
            color: #ffcc00;
            font-size: 13px;
            border-bottom: 1px solid #ffcc00;
            padding-bottom: 4px;
        }
        #statsPanel .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 2px 0;
        }
        #statsPanel .stat-label { color: #aaa; }
        #statsPanel .stat-value { color: #fff; }

        /* Attack Animation Overlay */
        #attackAnimation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
            overflow: hidden;
        }
        .attack-effect {
            position: absolute;
            opacity: 0;
        }
        /* Samurai - diagonal slash */
        .samurai-slash {
            width: 120%;
            height: 8px;
            background: linear-gradient(90deg, transparent, #fff, #ff6666, #fff, transparent);
            top: 50%;
            left: -10%;
            transform: rotate(-25deg);
            box-shadow: 0 0 20px #ff6666, 0 0 40px #ff4444;
            animation: samuraiSlash 0.25s ease-out forwards;
        }
        @keyframes samuraiSlash {
            0% { opacity: 0; transform: rotate(-25deg) translateX(-50%); }
            20% { opacity: 1; }
            100% { opacity: 0; transform: rotate(-25deg) translateX(50%); }
        }
        /* Knight - heavy horizontal swing */
        .knight-swing {
            width: 150%;
            height: 12px;
            background: linear-gradient(90deg, transparent, #aaa, #fff, #aaa, transparent);
            top: 55%;
            left: -25%;
            box-shadow: 0 0 30px #888, 0 0 50px #666;
            animation: knightSwing 0.35s ease-out forwards;
        }
        @keyframes knightSwing {
            0% { opacity: 0; transform: translateX(-30%) rotate(5deg); }
            30% { opacity: 1; }
            100% { opacity: 0; transform: translateX(30%) rotate(-5deg); }
        }
        /* Shuriken Master - spinning star */
        .shuriken-throw {
            width: 50px;
            height: 50px;
            top: 50%;
            left: 50%;
            margin: -25px 0 0 -25px;
            background: radial-gradient(circle, #ffcc00, transparent 70%);
            animation: shurikenThrow 0.3s ease-out forwards;
        }
        .shuriken-throw::before {
            content: 'â˜…';
            position: absolute;
            font-size: 40px;
            color: #ffcc00;
            text-shadow: 0 0 10px #ff6600;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        @keyframes shurikenThrow {
            0% { opacity: 1; transform: scale(0.5) rotate(0deg); }
            50% { opacity: 1; transform: scale(1.2) rotate(360deg); }
            100% { opacity: 0; transform: scale(0.3) rotate(720deg) translateY(-100px); }
        }
        /* Shadow/Assassin - X slash */
        .assassin-slash {
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
        }
        .assassin-slash::before, .assassin-slash::after {
            content: '';
            position: absolute;
            width: 120%;
            height: 4px;
            background: linear-gradient(90deg, transparent, #ff00ff, #fff, #ff00ff, transparent);
            top: 50%;
            left: -10%;
            box-shadow: 0 0 15px #ff00ff;
        }
        .assassin-slash::before { animation: assassinSlash1 0.2s ease-out forwards; }
        .assassin-slash::after { animation: assassinSlash2 0.2s ease-out 0.05s forwards; }
        @keyframes assassinSlash1 {
            0% { opacity: 0; transform: rotate(45deg) translateX(-100%); }
            30% { opacity: 1; }
            100% { opacity: 0; transform: rotate(45deg) translateX(100%); }
        }
        @keyframes assassinSlash2 {
            0% { opacity: 0; transform: rotate(-45deg) translateX(-100%); }
            30% { opacity: 1; }
            100% { opacity: 0; transform: rotate(-45deg) translateX(100%); }
        }
        /* Archer - bow draw and release */
        .archer-shot {
            width: 200px;
            height: 200px;
            top: 50%;
            left: 50%;
            margin: -100px 0 0 -100px;
            animation: archerShot 0.3s ease-out forwards;
        }
        .archer-shot::before {
            content: '';
            position: absolute;
            width: 80px;
            height: 80px;
            border: 4px solid #8B4513;
            border-radius: 50%;
            border-right-color: transparent;
            top: 50%;
            left: 30%;
            transform: translate(-50%, -50%) rotate(-45deg);
        }
        .archer-shot::after {
            content: '';
            position: absolute;
            width: 60px;
            height: 4px;
            background: linear-gradient(90deg, #8B4513, #ffcc00, #fff);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px #ffcc00;
        }
        @keyframes archerShot {
            0% { opacity: 1; transform: scale(0.8); }
            30% { opacity: 1; transform: scale(1); }
            60% { opacity: 1; }
            100% { opacity: 0; transform: scale(1) translateX(100px); }
        }
        /* Pikeman - forward thrust */
        .pike-thrust {
            width: 8px;
            height: 200px;
            background: linear-gradient(to top, #666, #aaa, #fff, #ffcc00);
            top: 60%;
            left: 50%;
            margin-left: -4px;
            transform-origin: bottom center;
            box-shadow: 0 0 15px #ffcc00;
            animation: pikeThrust 0.2s ease-out forwards;
        }
        @keyframes pikeThrust {
            0% { opacity: 0; transform: translateY(50px) scaleY(0.3); }
            40% { opacity: 1; transform: translateY(0) scaleY(1); }
            100% { opacity: 0; transform: translateY(-80px) scaleY(1.2); }
        }
        /* Wizard - magic burst */
        .wizard-cast {
            width: 100px;
            height: 100px;
            top: 50%;
            left: 50%;
            margin: -50px 0 0 -50px;
            border-radius: 50%;
            background: radial-gradient(circle, #00ffff, #0088ff, transparent 70%);
            box-shadow: 0 0 30px #00ffff, 0 0 60px #0088ff;
            animation: wizardCast 0.3s ease-out forwards;
        }
        .wizard-cast::before {
            content: 'âœ¦';
            position: absolute;
            font-size: 60px;
            color: #fff;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-shadow: 0 0 20px #00ffff;
        }
        @keyframes wizardCast {
            0% { opacity: 0; transform: scale(0.3) rotate(0deg); }
            50% { opacity: 1; transform: scale(1.2) rotate(180deg); }
            100% { opacity: 0; transform: scale(0.5) rotate(360deg); }
        }
        /* Necromancer - dark energy slash */
        .necro-slash {
            width: 120%;
            height: 6px;
            background: linear-gradient(90deg, transparent, #440066, #aa00ff, #440066, transparent);
            top: 50%;
            left: -10%;
            transform: rotate(-15deg);
            box-shadow: 0 0 20px #8800ff, 0 0 40px #440066;
            animation: necroSlash 0.25s ease-out forwards;
        }
        .necro-slash::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background: inherit;
            top: 15px;
            box-shadow: inherit;
        }
        @keyframes necroSlash {
            0% { opacity: 0; transform: rotate(-15deg) translateX(-50%); }
            20% { opacity: 1; }
            100% { opacity: 0; transform: rotate(-15deg) translateX(50%); }
        }
        /* Necromancer summon animation */
        .necro-summon {
            width: 120px;
            height: 120px;
            top: 50%;
            left: 50%;
            margin: -60px 0 0 -60px;
            border-radius: 50%;
            background: radial-gradient(circle, #8800ff, #440066, transparent 70%);
            box-shadow: 0 0 40px #8800ff, 0 0 80px #440066;
            animation: necroSummon 0.4s ease-out forwards;
        }
        .necro-summon::before {
            content: 'ðŸ’€';
            position: absolute;
            font-size: 50px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        @keyframes necroSummon {
            0% { opacity: 0; transform: scale(0.3) rotate(0deg); }
            40% { opacity: 1; transform: scale(1.3) rotate(180deg); }
            70% { opacity: 1; transform: scale(1) rotate(360deg); }
            100% { opacity: 0; transform: scale(0.5) rotate(540deg) translateY(-30px); }
        }
        /* Archer punch animation */
        .archer-punch {
            width: 80px;
            height: 80px;
            top: 50%;
            left: 50%;
            margin: -40px 0 0 -40px;
            border-radius: 50%;
            background: radial-gradient(circle, #ffaa00, #ff6600, transparent 70%);
            box-shadow: 0 0 20px #ffaa00;
            animation: archerPunch 0.2s ease-out forwards;
        }
        .archer-punch::before {
            content: 'ðŸ‘Š';
            position: absolute;
            font-size: 40px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        @keyframes archerPunch {
            0% { opacity: 0; transform: scale(0.5) translateY(20px); }
            50% { opacity: 1; transform: scale(1.2) translateY(-10px); }
            100% { opacity: 0; transform: scale(0.8) translateY(-30px); }
        }
        #waveAnnouncement {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 48px;
            font-weight: bold;
            text-shadow: 2px 2px 4px black;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }
        #healthBar {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 30px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            padding: 3px;
            pointer-events: none;
        }
        #healthBarInner {
            width: 100%;
            height: 100%;
            background: linear-gradient(to right, #ff0000, #ff4444);
            border-radius: 12px;
            transition: width 0.2s;
        }
        #healthText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }
        /* Stamina Bar */
        #staminaBar {
            position: absolute;
            top: 58px;
            left: 50%;
            transform: translateX(-50%);
            width: 250px;
            height: 18px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 9px;
            padding: 2px;
            pointer-events: none;
        }
        #staminaBarInner {
            width: 100%;
            height: 100%;
            background: linear-gradient(to right, #ffcc00, #ffee55);
            border-radius: 7px;
            transition: width 0.1s, background 0.3s;
        }
        #staminaBarInner.low {
            background: linear-gradient(to right, #ff8800, #ffaa00);
        }
        #staminaBarInner.critical {
            background: linear-gradient(to right, #ff4400, #ff6600);
        }
        #staminaBarInner.exhausted {
            background: linear-gradient(to right, #880000, #aa0000);
        }
        #staminaText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 11px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }
        #staminaStatus {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff6666;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
        }
        /* Ability Bar */
        #abilityBar {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
            pointer-events: none;
        }
        .ability-slot {
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #666;
            border-radius: 8px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .ability-slot.legendary { border-color: #ff8800; box-shadow: 0 0 10px #ff8800; }
        .ability-slot .key {
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 12px;
        }
        .ability-slot .cooldown-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            text-align: center;
            font-size: 14px;
            font-weight: bold;
        }
        .ability-slot .ability-icon {
            font-size: 28px;
        }
        .ability-slot .level {
            position: absolute;
            bottom: 2px;
            right: 2px;
            background: #ff8800;
            color: black;
            font-size: 10px;
            font-weight: bold;
            padding: 1px 4px;
            border-radius: 3px;
        }
        /* Card Selection */
        #cardOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
        }
        #cardOverlay h2 {
            color: white;
            font-size: 36px;
            margin-bottom: 40px;
            text-shadow: 0 0 10px #fff;
        }
        #cardContainer {
            display: flex;
            gap: 30px;
            position: relative;
            flex-wrap: wrap;
            justify-content: center;
            padding-bottom: 100px;
        }
        .card {
            width: 200px;
            height: 300px;
            border-radius: 15px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        .card:hover {
            transform: translateY(-20px) scale(1.05);
        }
        .card.common {
            background: linear-gradient(135deg, #4a4a4a, #2a2a2a);
            border: 3px solid #888;
        }
        .card.rare {
            background: linear-gradient(135deg, #1a3a6a, #0a1a3a);
            border: 3px solid #4488ff;
            box-shadow: 0 0 20px #4488ff44;
        }
        .card.legendary {
            background: linear-gradient(135deg, #6a3a0a, #3a1a00);
            border: 3px solid #ff8800;
            box-shadow: 0 0 30px #ff880066;
        }
        .card .rarity {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
        }
        .card.common .rarity { color: #888; }
        .card.rare .rarity { color: #4488ff; }
        .card.legendary .rarity { color: #ff8800; }
        .card .icon {
            font-size: 48px;
            margin: 15px 0;
        }
        .card .name {
            color: white;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .card .description {
            color: #ccc;
            font-size: 13px;
            flex-grow: 1;
        }
        .card .level-info {
            color: #aaa;
            font-size: 11px;
            margin-top: 10px;
        }
        .build-button {
            width: 120px;
            height: 50px;
            background: linear-gradient(135deg, #2a5a2a, #1a3a1a);
            border: 3px solid #4a8a4a;
            border-radius: 10px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 20px;
            transition: all 0.3s;
            position: absolute;
            bottom: -80px;
            left: 50%;
            transform: translateX(-50%);
        }
        .build-button:hover {
            background: linear-gradient(135deg, #3a7a3a, #2a5a2a);
            border-color: #6aba6a;
            box-shadow: 0 0 15px #4a8a4a66;
        }
        /* Stats Display */
        #statsDisplay {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
        }
        /* Resource Display */
        #resourceDisplay {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-family: monospace;
            border: 1px solid #555;
        }
        #resourceDisplay .resource {
            margin: 4px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #resourceDisplay .resource-icon {
            width: 20px;
            text-align: center;
        }
        /* Build Mode */
        #buildMode {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
            pointer-events: none;
        }
        #buildMode.hidden { display: none; }
        #buildBar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(20, 20, 30, 0.95);
            border: 2px solid #4488ff;
            border-radius: 12px;
            padding: 20px 40px;
            text-align: center;
            pointer-events: auto;
        }
        #buildBar .build-title {
            color: #4488ff;
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        #buildBar .build-info {
            color: #888;
            font-size: 14px;
        }
        #buildResources {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 30, 0.95);
            border: 2px solid #4488ff;
            border-radius: 8px;
            padding: 15px 20px;
            font-size: 18px;
            color: white;
            display: flex;
            gap: 20px;
        }
        /* Relics Display */
        #relicsPanel {
            background: rgba(30, 30, 40, 0.95);
            border: 2px solid #8844cc;
            border-radius: 12px;
            padding: 15px;
            width: 180px;
            max-height: 80vh;
            overflow-y: auto;
            margin-left: 20px;
            align-self: flex-start;
            margin-top: 20px;
        }
        #relicsPanel h3 {
            color: #cc88ff;
            font-size: 16px;
            margin: 0 0 10px 0;
            text-align: center;
            border-bottom: 1px solid #8844cc;
            padding-bottom: 8px;
        }
        .relic-slot {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            margin: 5px 0;
            background: rgba(60, 40, 80, 0.5);
            border: 2px solid #555;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .relic-slot:hover {
            background: rgba(80, 50, 100, 0.7);
            border-color: #8844cc;
        }
        .relic-slot.unlocked {
            border-color: #666;
            background: rgba(60, 50, 80, 0.4);
        }
        .relic-slot.unlocked:hover {
            border-color: #888;
        }
        .relic-slot.active {
            border-color: #44ff44;
            background: rgba(40, 100, 40, 0.6);
            box-shadow: 0 0 8px rgba(68, 255, 68, 0.3);
        }
        .relic-slot.active:hover {
            border-color: #66ff66;
        }
        .relic-slot.locked {
            opacity: 0.4;
            filter: grayscale(80%);
            cursor: not-allowed;
        }
        .relic-toggle {
            font-size: 10px;
            color: #888;
            margin-top: 2px;
        }
        .relic-slot.active .relic-toggle {
            color: #44ff44;
        }
        .relic-icon {
            font-size: 28px;
            min-width: 36px;
            text-align: center;
        }
        .relic-info {
            flex: 1;
        }
        .relic-name {
            color: #fff;
            font-size: 11px;
            font-weight: bold;
        }
        .relic-map {
            color: #888;
            font-size: 9px;
        }
        .relic-tooltip {
            display: none;
            position: absolute;
            right: 100%;
            top: 50%;
            transform: translateY(-50%);
            margin-right: 10px;
            background: rgba(20, 20, 30, 0.98);
            border: 2px solid #aa66dd;
            border-radius: 8px;
            padding: 12px;
            width: 200px;
            z-index: 1000;
        }
        .relic-slot:hover .relic-tooltip {
            display: block;
        }
        .relic-tooltip h4 {
            color: #cc88ff;
            margin: 0 0 5px 0;
            font-size: 14px;
        }
        .relic-tooltip p {
            color: #ccc;
            margin: 0;
            font-size: 11px;
            line-height: 1.4;
        }
        .relic-tooltip .relic-status {
            color: #888;
            font-size: 10px;
            margin-top: 8px;
            font-style: italic;
        }
        /* Character Selection */
        #characterSelect {
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-width: 100%;
        }
        .char-row {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 0;
        }
        .unlock-arrow {
            color: #ffd700;
            font-size: 24px;
            padding: 0 8px;
            text-shadow: 0 0 10px #ffd700;
            opacity: 0.8;
        }
        .unlock-arrow.bidirectional {
            color: #88ff88;
            text-shadow: 0 0 10px #88ff88;
        }
        .char-card {
            width: 140px;
            padding: 10px;
            background: rgba(50, 50, 50, 0.9);
            border: 3px solid #555;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            flex-shrink: 0;
        }
        .char-card:hover:not(.locked) {
            transform: translateY(-5px);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }
        .char-card.selected {
            border-color: #ff4444;
            box-shadow: 0 0 25px #ff4444;
        }
        .char-card.locked {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(70%);
        }
        .char-card .char-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }
        .char-card .char-name {
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .char-card .char-role {
            color: #aaa;
            font-size: 12px;
            margin-bottom: 8px;
        }
        .char-card .char-stats {
            color: #888;
            font-size: 11px;
            line-height: 1.4;
        }
        .char-card .char-stats span {
            display: block;
        }
        .char-card .char-stats .stat-good { color: #4f4; }
        .char-card .char-stats .stat-bad { color: #f44; }
        .char-card .locked-text {
            color: #ff8800;
            font-size: 11px;
            margin-top: 8px;
        }
        #selectedCharInfo {
            margin-top: 15px;
            color: #ccc;
            font-size: 14px;
            text-align: left;
        }
        /* Map Selection */
        #mapSelectOverlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        #mapSelectOverlay h2 {
            color: #ffd700;
            font-size: 28px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #ffd700;
        }
        #mapSelectContainer {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 70vh;
            overflow-y: auto;
            padding: 10px;
        }
        .map-row {
            display: flex;
            align-items: center;
            gap: 0;
        }
        .map-arrow {
            color: #ffd700;
            font-size: 20px;
            padding: 0 8px;
            text-shadow: 0 0 10px #ffd700;
        }
        .map-card {
            width: 120px;
            padding: 12px;
            background: rgba(50, 50, 50, 0.9);
            border: 3px solid #555;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            flex-shrink: 0;
        }
        .map-card:hover:not(.locked) {
            transform: translateY(-3px);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }
        .map-card.selected {
            border-color: #44ff44;
            box-shadow: 0 0 20px #44ff44;
        }
        .map-card.locked {
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(70%);
        }
        .map-card .map-icon {
            font-size: 32px;
            margin-bottom: 5px;
        }
        .map-card .map-name {
            color: #fff;
            font-size: 12px;
            font-weight: bold;
        }
        .map-card .map-locked {
            color: #ff8800;
            font-size: 10px;
            margin-top: 5px;
        }
        #mapSelectClose {
            margin-top: 20px;
            padding: 12px 40px;
            font-size: 18px;
            background: linear-gradient(to bottom, #444, #222);
            border: 2px solid #44ff44;
            border-radius: 8px;
            color: #44ff44;
            cursor: pointer;
        }
        #mapSelectClose:hover { background: linear-gradient(to bottom, #555, #333); }
        /* Difficulty Selection */
        #difficultySelect {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
        }
        .diff-btn {
            padding: 12px 28px;
            font-size: 16px;
            border: 3px solid #555;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            background: rgba(50, 50, 50, 0.9);
            color: #aaa;
            width: 100%;
        }
        .diff-btn:hover:not(.selected) {
            transform: translateY(-3px);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
        }
        .diff-btn.selected {
            border-color: #ff4444;
            box-shadow: 0 0 20px #ff4444;
            color: #fff;
        }
        .diff-btn.easy { color: #4f4; }
        .diff-btn.easy.selected { border-color: #4f4; box-shadow: 0 0 20px #4f4; }
        .diff-btn.medium { color: #ff4; }
        .diff-btn.medium.selected { border-color: #ff4; box-shadow: 0 0 20px #ff4; }
        .diff-btn.hard { color: #f44; }
        .diff-btn.hard.selected { border-color: #f44; box-shadow: 0 0 20px #f44; }
        #difficultyInfo {
            margin-top: 10px;
            color: #888;
            font-size: 13px;
            text-align: center;
        }
        /* Starter Choice Modal */
        #starterChoiceOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        #starterChoiceOverlay.hidden { display: none; }
        #starterChoiceOverlay h2 {
            color: #ff8800;
            font-size: 32px;
            margin-bottom: 15px;
            text-shadow: 0 0 15px #ff8800;
        }
        #starterChoiceOverlay p {
            color: #aaa;
            font-size: 16px;
            margin-bottom: 40px;
            text-align: center;
            max-width: 500px;
        }
        #starterChoiceContainer {
            display: flex;
            gap: 40px;
        }
        .starter-card {
            width: 220px;
            padding: 25px;
            background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
            border: 3px solid #555;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        .starter-card:hover {
            transform: translateY(-10px) scale(1.05);
            border-color: #ff8800;
            box-shadow: 0 0 30px rgba(255, 136, 0, 0.5);
        }
        .starter-card .starter-icon {
            font-size: 64px;
            margin-bottom: 15px;
        }
        .starter-card .starter-name {
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 8px;
        }
        .starter-card .starter-role {
            color: #ff8800;
            font-size: 14px;
            margin-bottom: 15px;
        }
        .starter-card .starter-desc {
            color: #aaa;
            font-size: 13px;
            line-height: 1.5;
        }
        /* Arrow Ammo UI */
        #arrowAmmo {
            position: absolute;
            bottom: 90px;
            left: 20px;
            color: #c4a000;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            pointer-events: none;
        }
        #arrowAmmo.hidden { display: none; }
        /* Wave 30 Victory Menu */
        #wave30Victory {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 150;
        }
        #wave30Victory.hidden { display: none; }
        #wave30Victory h1 {
            color: #00ff00;
            font-size: 64px;
            text-shadow: 0 0 30px #00ff00;
            margin-bottom: 20px;
        }
        #wave30Victory p {
            color: #ccc;
            font-size: 20px;
            margin-bottom: 40px;
        }
        #wave30Victory .victory-buttons {
            display: flex;
            gap: 30px;
        }
        #wave30Victory button {
            padding: 18px 50px;
            font-size: 22px;
            border: 3px solid;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }
        #wave30Victory .yes-btn {
            background: linear-gradient(to bottom, #228B22, #145214);
            color: white;
            border-color: #00ff00;
        }
        #wave30Victory .yes-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 25px #00ff00;
        }
        #wave30Victory .no-btn {
            background: linear-gradient(to bottom, #555, #333);
            color: white;
            border-color: #888;
        }
        #wave30Victory .no-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px #888;
        }
        /* Shuriken Ammo UI */
        #shurikenAmmo {
            position: absolute;
            bottom: 90px;
            left: 20px;
            color: #aaa;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            pointer-events: none;
        }
        #shurikenAmmo.hidden { display: none; }
        /* Wizard Energy UI */
        #wizardEnergy {
            position: absolute;
            bottom: 90px;
            left: 20px;
            color: #9966ff;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 8px;
            pointer-events: none;
            border: 2px solid #6633cc;
        }
        #wizardEnergy.hidden { display: none; }
        #energyBarOuter {
            width: 180px;
            height: 16px;
            background: #222;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 5px;
        }
        #energyBarInner {
            width: 0%;
            height: 100%;
            background: linear-gradient(to right, #6633cc, #9966ff, #cc99ff);
            border-radius: 8px;
            transition: width 0.15s;
            box-shadow: 0 0 10px #9966ff;
        }
        #energyText {
            text-align: center;
            font-size: 12px;
            margin-bottom: 8px;
        }
        #wizardSpells {
            display: flex;
            gap: 8px;
            font-size: 11px;
        }
        #wizardSpells .spell {
            padding: 4px 8px;
            background: rgba(102, 51, 204, 0.5);
            border-radius: 4px;
            border: 1px solid #6633cc;
        }
        #wizardSpells .spell.disabled {
            opacity: 0.4;
            background: rgba(50, 50, 50, 0.5);
            border-color: #333;
        }
        #wizardSpells .spell.ready {
            opacity: 1;
            box-shadow: 0 0 8px #9966ff;
            animation: spellPulse 1s infinite;
        }
        @keyframes spellPulse {
            0%, 100% { box-shadow: 0 0 8px #9966ff; }
            50% { box-shadow: 0 0 15px #cc99ff; }
        }
        /* Boss Health Bar - positioned directly under player health */
        #bossHealthBar {
            position: absolute;
            top: 58px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 24px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ff4400;
            border-radius: 12px;
            padding: 2px;
            pointer-events: none;
            box-shadow: 0 0 10px rgba(255, 68, 0, 0.4);
        }
        #bossHealthBar.hidden { display: none; }
        #bossHealthBarInner {
            width: 100%;
            height: 100%;
            background: linear-gradient(to right, #ff0000, #ff4400, #ff6600);
            border-radius: 10px;
            transition: width 0.3s;
        }
        #bossHealthBarText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 11px;
            text-shadow: 1px 1px 2px black;
        }
        #bossName {
            position: absolute;
            top: -16px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff4400;
            font-weight: bold;
            font-size: 12px;
            text-shadow: 1px 1px 2px black;
            white-space: nowrap;
        }
        /* Boss Attack Warning */
        #bossAttackWarning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0000;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 60;
        }
        #bossAttackWarning.visible {
            opacity: 1;
            animation: warningPulse 0.3s ease-in-out infinite;
        }
        @keyframes warningPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }
        /* Skill Tree Styles */
        #skillTreeOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 200;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            overflow-y: auto;
        }
        #skillTreeOverlay.hidden { display: none; }
        #skillTreeOverlay h1 {
            color: #ffd700;
            font-size: 36px;
            margin-bottom: 5px;
            text-shadow: 0 0 10px #ff8800;
        }
        #skillTreeOverlay .char-info {
            color: #aaa;
            margin-bottom: 15px;
            font-size: 16px;
        }
        #skillTreeOverlay .char-info span { color: #4f4; }
        #skillTreeTabs {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .skill-tab {
            padding: 10px 20px;
            background: #333;
            border: 2px solid #555;
            border-radius: 8px;
            color: #aaa;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }
        .skill-tab:hover { background: #444; border-color: #888; }
        .skill-tab.active { background: #553300; border-color: #ffd700; color: #ffd700; }
        .skill-tab .tab-icon { font-size: 20px; margin-right: 5px; }
        .skill-tab .tab-xp { font-size: 11px; color: #888; display: block; }
        #skillTreeContent {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            max-width: 1000px;
            width: 100%;
        }
        .skill-node {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 3px solid #333;
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        .skill-node:hover { transform: scale(1.05); border-color: #666; }
        .skill-node.unlocked { border-color: #4a4; background: linear-gradient(135deg, #1a2e1a, #163e16); }
        .skill-node.affordable { border-color: #ffd700; box-shadow: 0 0 15px rgba(255, 215, 0, 0.3); }
        .skill-node.locked { opacity: 0.5; cursor: not-allowed; }
        .skill-node .skill-icon { font-size: 32px; margin-bottom: 8px; }
        .skill-node .skill-name { color: #fff; font-weight: bold; font-size: 14px; margin-bottom: 5px; }
        .skill-node .skill-desc { color: #aaa; font-size: 11px; margin-bottom: 8px; min-height: 30px; }
        .skill-node .skill-cost {
            color: #ffd700;
            font-size: 12px;
            background: rgba(0,0,0,0.3);
            padding: 3px 8px;
            border-radius: 10px;
            display: inline-block;
        }
        .skill-node.unlocked .skill-cost { color: #4f4; }
        .skill-node .skill-check {
            position: absolute;
            top: 5px;
            right: 8px;
            color: #4f4;
            font-size: 18px;
        }
        #skillTreeClose {
            margin-top: 20px;
            padding: 12px 40px;
            font-size: 18px;
            background: linear-gradient(to bottom, #444, #222);
            border: 2px solid #666;
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
        }
        #skillTreeClose:hover { background: linear-gradient(to bottom, #555, #333); }
        #openSkillTree {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 12px 25px;
            font-size: 16px;
            background: linear-gradient(to bottom, #553300, #331a00);
            border: 2px solid #ffd700;
            border-radius: 8px;
            color: #ffd700;
            cursor: pointer;
            z-index: 50;
        }
        #openSkillTree:hover { transform: scale(1.05); box-shadow: 0 0 15px #ffd700; }
        #openQuests {
            position: absolute;
            bottom: 20px;
            right: 170px;
            padding: 12px 25px;
            font-size: 16px;
            background: linear-gradient(to bottom, #553300, #331a00);
            border: 2px solid #ffd700;
            border-radius: 8px;
            color: #ffd700;
            cursor: pointer;
            z-index: 50;
        }
        #openQuests:hover { transform: scale(1.05); box-shadow: 0 0 15px #ffd700; }

        /* Quest System Styles */
        #questOverlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            z-index: 200;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #questOverlay.hidden { display: none; }
        #questContent {
            background: linear-gradient(to bottom, #2a1a0a, #1a0a00);
            border: 3px solid #ffd700;
            border-radius: 15px;
            padding: 30px;
            max-width: 900px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        #questContent h2 {
            color: #ffd700;
            text-align: center;
            margin-bottom: 10px;
            font-size: 28px;
        }
        #questActiveDisplay {
            text-align: center;
            color: #aaa;
            margin-bottom: 20px;
            font-size: 14px;
        }
        #questActiveDisplay.has-quest {
            color: #44ff44;
        }
        #questCardsContainer {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        .quest-card {
            background: linear-gradient(to bottom, #3a2a1a, #2a1a0a);
            border: 2px solid #886622;
            border-radius: 12px;
            padding: 20px;
            width: 250px;
            text-align: center;
            transition: all 0.3s;
        }
        .quest-card:hover {
            border-color: #ffd700;
            transform: translateY(-5px);
            box-shadow: 0 5px 20px rgba(255, 215, 0, 0.3);
        }
        .quest-card.locked {
            opacity: 0.5;
            pointer-events: none;
        }
        .quest-card .quest-icon {
            font-size: 40px;
            margin-bottom: 10px;
        }
        .quest-card .quest-name {
            color: #ffd700;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 8px;
        }
        .quest-card .quest-objective {
            color: #ccc;
            font-size: 13px;
            margin-bottom: 12px;
            min-height: 40px;
        }
        .quest-card .quest-reward {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 8px;
            margin-bottom: 12px;
        }
        .quest-card .quest-reward-title {
            color: #888;
            font-size: 11px;
            margin-bottom: 4px;
        }
        .quest-card .quest-reward-relic {
            color: #aa66ff;
            font-size: 14px;
        }
        .quest-card .quest-reward-xp {
            color: #ffd700;
            font-size: 12px;
        }
        .quest-card .quest-accept-btn {
            background: linear-gradient(to bottom, #446600, #223300);
            border: 2px solid #88cc00;
            border-radius: 6px;
            color: #88cc00;
            padding: 8px 20px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        .quest-card .quest-accept-btn:hover {
            background: linear-gradient(to bottom, #558800, #334400);
            box-shadow: 0 0 10px #88cc00;
        }
        .quest-card .quest-accept-btn:disabled {
            background: #333;
            border-color: #555;
            color: #555;
            cursor: not-allowed;
        }
        #questClose {
            display: block;
            margin: 20px auto 0;
            padding: 10px 30px;
            font-size: 16px;
            background: linear-gradient(to bottom, #444, #222);
            border: 2px solid #888;
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
        }
        #questClose:hover { background: linear-gradient(to bottom, #555, #333); }
        #questRefreshBtn {
            display: block;
            margin: 0 auto 15px;
            padding: 8px 20px;
            font-size: 14px;
            background: linear-gradient(to bottom, #224466, #112233);
            border: 2px solid #4488cc;
            border-radius: 6px;
            color: #4488cc;
            cursor: pointer;
        }
        #questRefreshBtn:hover { box-shadow: 0 0 10px #4488cc; }

        /* Active Quest HUD */
        #activeQuestHUD {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(30, 20, 10, 0.9);
            border: 2px solid #ffd700;
            border-radius: 8px;
            padding: 8px 20px;
            z-index: 100;
            text-align: center;
            display: none;
        }
        #activeQuestHUD.visible { display: block; }
        #activeQuestHUD .quest-hud-name {
            color: #ffd700;
            font-size: 14px;
            font-weight: bold;
        }
        #activeQuestHUD .quest-hud-progress {
            color: #88cc00;
            font-size: 12px;
        }
        .xp-popup {
            position: fixed;
            color: #ffd700;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 5px #000, 0 0 10px #ffd700;
            pointer-events: none;
            animation: xpFloat 1s ease-out forwards;
            z-index: 1000;
        }
        @keyframes xpFloat {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-30px); }
        }
    </style>
</head>
<body>
    <!-- Starter Choice Modal -->
    <div id="starterChoiceOverlay" class="hidden">
        <h2>Choose Your Starter Class</h2>
        <p>Pick one class to unlock immediately. Beat the game with your choice to unlock the other!</p>
        <div id="starterChoiceContainer">
            <div class="starter-card" data-starter="archer">
                <div class="starter-icon">ðŸ¹</div>
                <div class="starter-name">Archer</div>
                <div class="starter-role">Ranged DPS</div>
                <div class="starter-desc">Massive damage from afar but cannot melee. Left-click shoots arrows instead of swinging.</div>
            </div>
            <div class="starter-card" data-starter="pikeman">
                <div class="starter-icon">ðŸ”±</div>
                <div class="starter-name">Pikeman</div>
                <div class="starter-role">Melee Reach</div>
                <div class="starter-desc">Fast thrusting attacks with a long pike. Hit enemies before they can reach you.</div>
            </div>
        </div>
    </div>

    <!-- Map Selection Overlay -->
    <div id="mapSelectOverlay" class="hidden">
        <h2>ðŸ—ºï¸ Select Map</h2>
        <div id="mapSelectContainer"></div>
        <button id="mapSelectClose">CONFIRM</button>
    </div>

    <!-- Home Screen -->
    <div id="homeScreen">
        <div id="homeContent">
            <div id="leftPanel">
                <div id="characterSelect"></div>
                <div id="selectedCharInfo"></div>
            </div>
            <div id="relicsPanel">
                <h3>ðŸ† Relics</h3>
                <div id="relicsList"></div>
            </div>
            <div id="rightPanel">
                <h1>SAMURAI</h1>
                <h2>Survive the Waves</h2>
                <button id="selectMapBtn">ðŸ—ºï¸ Select Map</button>
                <div id="selectedMapInfo"></div>
                <div id="difficultySelect">
                    <button class="diff-btn easy" data-diff="easy">EASY</button>
                    <button class="diff-btn medium" data-diff="medium">MEDIUM</button>
                    <button class="diff-btn hard" data-diff="hard">HARD</button>
                </div>
                <div id="difficultyInfo"></div>
                <button id="startBtn">START GAME</button>
            </div>
        </div>
        <button id="openQuests">ðŸ“œ Quests</button>
        <button id="openSkillTree">ðŸŒ³ Skill Trees</button>
    </div>

    <!-- Skill Tree Overlay -->
    <div id="skillTreeOverlay" class="hidden">
        <div id="skillTreeContent">
            <h2>ðŸŒ³ Skill Trees</h2>
            <div id="skillTreeTabs"></div>
            <div id="skillTreeXPDisplay"></div>
            <div id="skillTreeGrid"></div>
            <button id="skillTreeClose">Close</button>
        </div>
    </div>

    <!-- Quest Overlay -->
    <div id="questOverlay" class="hidden">
        <div id="questContent">
            <h2>ðŸ“œ Quests</h2>
            <div id="questActiveDisplay">No active quest</div>
            <button id="questRefreshBtn">ðŸ”„ Refresh Quests</button>
            <div id="questCardsContainer"></div>
            <button id="questClose">Close</button>
        </div>
    </div>

    <!-- Wave 30 Victory Menu -->
    <div id="wave30Victory" class="hidden">
        <h1>YOU HAVE WON!</h1>
        <p>Would you like to go into freeplay?</p>
        <div class="victory-buttons">
            <button class="yes-btn" onclick="continueFreeplay()">YES</button>
            <button class="no-btn" onclick="endAfterWave30()">NO</button>
        </div>
    </div>

    <!-- Card Selection Overlay -->
    <div id="cardOverlay" class="hidden">
        <h2>Choose an Upgrade</h2>
        <div id="cardContainer"></div>
    </div>

    <!-- Game UI -->
    <div id="gameUI" class="hidden">
        <div id="activeQuestHUD">
            <div class="quest-hud-name"></div>
            <div class="quest-hud-progress"></div>
        </div>
        <div id="attackAnimation"></div>
        <div id="waveInfo">
            <h2>Wave <span id="waveNumber">1</span>/50</h2>
            <p>Enemies: <span id="enemyCount">0</span></p>
        </div>
        <div id="statsPanel">
            <h4>Stats</h4>
            <div id="statsList"></div>
        </div>
        <div id="healthBar">
            <div id="healthBarInner"></div>
            <div id="healthText">100 / 100</div>
        </div>
        <div id="staminaBar">
            <div id="staminaBarInner"></div>
            <div id="staminaText">100 / 100</div>
        </div>
        <div id="staminaStatus"></div>
        <div id="waveAnnouncement"></div>
        <div id="bossHealthBar" class="hidden">
            <div id="bossName"></div>
            <div id="bossHealthBarInner"></div>
            <div id="bossHealthBarText"></div>
        </div>
        <div id="bossAttackWarning"></div>
        <div id="instructions">
            <h3>Controls</h3>
            <p>WASD - Move</p>
            <p>Double-tap - Dodge Roll</p>
            <p>Space - Jump</p>
            <p>Mouse - Look</p>
            <p>LMB - Attack</p>
            <p>RMB - Parry</p>
            <p>1-5 - Abilities</p>
        </div>
        <div id="abilityBar"></div>
        <div id="shurikenAmmo" class="hidden"></div>
        <div id="arrowAmmo" class="hidden"></div>
        <div id="wizardEnergy" class="hidden">
            <div id="energyBarOuter">
                <div id="energyBarInner"></div>
            </div>
            <div id="energyText">0 / 100</div>
            <div id="wizardSpells">
                <span id="spellQ" class="spell disabled">Q: Fireball (30)</span>
                <span id="spellE" class="spell disabled">E: Homing (25)</span>
            </div>
        </div>
        <div id="statsDisplay"></div>
        <div id="resourceDisplay">
            <div class="resource"><span class="resource-icon">ðŸªµ</span> Wood: <span id="woodCount">0</span></div>
            <div class="resource"><span class="resource-icon">â›ï¸</span> Ore: <span id="oreCount">0</span></div>
            <div class="resource"><span class="resource-icon">ðŸª¨</span> Rock: <span id="rockCount">0</span></div>
            <div class="resource"><span class="resource-icon">ðŸ–</span> Food: <span id="foodCount">0</span></div>
        </div>
        <div id="buildMode" class="hidden">
            <div id="buildBar">
                <div class="build-title">Build Mode</div>
                <div class="build-info">Coming Soon - Press ESC to exit</div>
            </div>
            <div id="buildResources">
                <span>ðŸªµ <span id="buildWood">0</span></span>
                <span>â›ï¸ <span id="buildOre">0</span></span>
                <span>ðŸª¨ <span id="buildRock">0</span></span>
                <span>ðŸ– <span id="buildFood">0</span></span>
            </div>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ========== GAME STATE MANAGEMENT ==========
        let gameState = 'home'; // 'home', 'playing', 'cardSelection', 'gameOver', 'building'

        // ========== RESOURCE SYSTEM ==========
        let resources = {
            wood: 0,
            ore: 0,
            rock: 0,
            food: 0
        };

        function updateResourceDisplay() {
            document.getElementById('woodCount').textContent = resources.wood;
            document.getElementById('oreCount').textContent = resources.ore;
            document.getElementById('rockCount').textContent = resources.rock;
            document.getElementById('foodCount').textContent = resources.food;
        }

        function addResource(type, amount) {
            resources[type] = (resources[type] || 0) + amount;
            updateResourceDisplay();
            // Show floating text
            showResourceGain(type, amount);
        }

        function showResourceGain(type, amount) {
            const icons = { wood: 'ðŸªµ', ore: 'â›ï¸', rock: 'ðŸª¨', food: 'ðŸ–' };
            showAbilityEffect(`+${amount} ${icons[type]}`);
        }

        function resetResources() {
            resources = { wood: 0, ore: 0, rock: 0, food: 0 };
            updateResourceDisplay();
        }

        // ========== BUILD MODE ==========
        let buildModeCamera = null;
        let normalCameraState = null;

        function enterBuildMode() {
            gameState = 'building';
            document.exitPointerLock();

            // Show build mode UI
            document.getElementById('buildMode').classList.remove('hidden');
            document.getElementById('resourceDisplay').style.display = 'none';

            // Update build mode resource display
            document.getElementById('buildWood').textContent = resources.wood;
            document.getElementById('buildOre').textContent = resources.ore;
            document.getElementById('buildRock').textContent = resources.rock;
            document.getElementById('buildFood').textContent = resources.food;

            // Save normal camera state
            normalCameraState = {
                position: camera.position.clone(),
                rotation: camera.rotation.clone()
            };

            // Move camera to bird's eye view
            camera.position.set(player.position.x, 50, player.position.z + 30);
            camera.lookAt(player.position.x, 0, player.position.z);
        }

        function exitBuildMode() {
            gameState = 'cardSelection';

            // Hide build mode UI
            document.getElementById('buildMode').classList.add('hidden');
            document.getElementById('resourceDisplay').style.display = 'block';

            // Restore camera
            if (normalCameraState) {
                camera.position.copy(normalCameraState.position);
                camera.rotation.copy(normalCameraState.rotation);
            }

            // Re-show card selection
            showCardSelection();
        }

        // ========== CHARACTER SYSTEM ==========
        // Characters unlock progressively: Standard -> Knight -> Thrower -> Assassin
        const characters = {
            standard: {
                id: 'standard',
                name: 'Samurai',
                icon: 'âš”ï¸',
                role: 'Jack of All Trades',
                description: 'Balanced warrior with faster attacks',
                unlockRequires: null, // Always unlocked
                baseStats: {
                    maxHealth: 100,
                    damage: 1.0,
                    attackSpeed: 0.8, // 20% faster attacks
                    moveSpeed: 1.0,
                    armor: 0,
                    critChance: 0,
                    critDamage: 1.5
                },
                special: null,
                statDisplay: ['Balanced stats', '+20% Attack Speed', 'Good for learning']
            },
            knight: {
                id: 'knight',
                name: 'Knight',
                icon: 'ðŸ›¡ï¸',
                role: 'Tank',
                description: 'Heavy armor and health, but slow',
                unlockRequires: 'standard', // Beat wave 30 with Standard
                baseStats: {
                    maxHealth: 200,
                    damage: 0.8,
                    attackSpeed: 1.2, // Slower attacks
                    moveSpeed: 0.7,
                    armor: 1,
                    critChance: 0,
                    critDamage: 1.5
                },
                special: 'blockChance', // 20% chance to block all damage
                statDisplay: ['+100 Health', '+1 Armor', '-30% Move Speed', '-20% Damage']
            },
            thrower: {
                id: 'thrower',
                name: 'Shuriken Master',
                icon: 'ðŸŒŸ',
                role: 'Ranged',
                description: 'Throws shurikens, weaker in melee',
                unlockRequires: 'knight', // Beat wave 30 with Knight
                baseStats: {
                    maxHealth: 80,
                    damage: 0.7,
                    attackSpeed: 0.8, // Faster attacks
                    moveSpeed: 1.1,
                    armor: 0,
                    critChance: 0.1,
                    critDamage: 1.5
                },
                special: 'shurikens', // Can throw shurikens with Q
                shurikenDamage: 15,
                shurikenAmmo: 5,
                shurikenRegenTime: 4, // Seconds to regen 1 shuriken
                statDisplay: ['-20% Health', '-30% Melee Dmg', '+10% Crit', 'Q: Throw Shurikens']
            },
            assassin: {
                id: 'assassin',
                name: 'Shadow',
                icon: 'ðŸ—¡ï¸',
                role: 'Glass Cannon',
                description: 'Extreme speed and damage, very fragile',
                unlockRequires: 'thrower', // Beat wave 30 with Thrower
                baseStats: {
                    maxHealth: 60,
                    damage: 1.6,
                    attackSpeed: 0.6, // Much faster attacks
                    moveSpeed: 1.5,
                    armor: 0,
                    critChance: 0.25,
                    critDamage: 2.5
                },
                special: 'backstab', // +100% damage from behind
                statDisplay: ['-40% Health', '+60% Damage', '+50% Speed', '+25% Crit', 'Backstab: 2x dmg']
            },
            archer: {
                id: 'archer',
                name: 'Archer',
                icon: 'ðŸ¹',
                role: 'Ranged DPS',
                description: 'Deadly at range, helpless in melee',
                unlockRequires: 'starter', // Starter choice or beat game with Pikeman
                baseStats: {
                    maxHealth: 70,
                    damage: 1.0, // Only affects card upgrades
                    attackSpeed: 1.875, // 25% faster than before
                    moveSpeed: 1.0,
                    armor: 0,
                    critChance: 0.15,
                    critDamage: 2.0
                },
                special: 'bowAttack', // Left-click shoots arrows, no melee
                arrowDamage: 11, // Base arrow damage
                arrowAmmo: 8,
                arrowRegenTime: 1.78, // Seconds to regen 1 arrow (100% faster total)
                punchCooldown: 0.25, // Same as samurai attack cooldown
                statDisplay: ['No Parry', '+15% Crit', 'LMB: Dagger (restores arrow)', 'RMB: Shoot Arrow (11 dmg)', '1.8s Arrow Regen']
            },
            pikeman: {
                id: 'pikeman',
                name: 'Pikeman',
                icon: 'ðŸ”±',
                role: 'Melee Reach',
                description: 'Long pike with fast thrusts',
                unlockRequires: 'starter', // Starter choice or beat game with Archer
                baseStats: {
                    maxHealth: 90,
                    damage: 0.9,
                    attackSpeed: 0.5, // Very fast attacks
                    moveSpeed: 0.9,
                    armor: 2,
                    critChance: 0.05,
                    critDamage: 1.5
                },
                special: 'pikeReach', // Extended melee range
                pikeRangeBonus: 1.8, // 80% extra range
                statDisplay: ['+80% Attack Range', 'Fast Attacks', '-10% Move Speed', '+2 Armor', 'Long Reach']
            },
            wizard: {
                id: 'wizard',
                name: 'Wizard',
                icon: 'ðŸ§™',
                role: 'Spell Caster',
                description: 'Powerful spells fueled by melee combat',
                unlockRequires: 'archerAndPikeman', // Special unlock - requires both
                baseStats: {
                    maxHealth: 75,
                    damage: 0.7,
                    attackSpeed: 1.0,
                    moveSpeed: 0.8, // Slow movement
                    armor: 0,
                    critChance: 0.1,
                    critDamage: 2.0
                },
                special: 'wizard',
                maxEnergy: 100,
                energyPerMelee: 15, // Energy gained per melee hit
                fireballCost: 30, // Q ability cost
                fireballDamage: 50,
                homingBallCost: 25, // E ability cost
                homingBallDamage: 35,
                statDisplay: ['75 HP', 'Slow Movement', 'Q: Fireball (30 Energy)', 'E: Homing Ball (25 Energy)', 'Melee = Energy']
            },
            necromancer: {
                id: 'necromancer',
                name: 'Necromancer',
                icon: 'ðŸ’€',
                role: 'Summoner',
                description: 'Raises undead minions to fight for you',
                unlockRequires: 'wizard', // Beat wave 30 with Wizard
                baseStats: {
                    maxHealth: 70,
                    damage: 0.6,
                    attackSpeed: 1.0,
                    moveSpeed: 0.85,
                    armor: 0,
                    critChance: 0.05,
                    critDamage: 1.5
                },
                special: 'necromancer',
                maxEnergy: 150, // Higher mana capacity
                energyPerMelee: 12, // Energy gained per melee hit
                skeletonWarriorCost: 30, // Q ability cost
                skeletonArcherCost: 25, // E ability cost
                statDisplay: ['70 HP', '150 Mana', 'Q: Skeleton Warrior (30)', 'E: Skeleton Archer (25)', 'Melee = Mana']
            }
        };

        // Track unlocked characters and current selection
        let unlockedCharacters = JSON.parse(localStorage.getItem('samuraiUnlockedChars')) || ['standard'];
        let selectedCharacter = localStorage.getItem('samuraiSelectedChar') || 'standard';
        if (!unlockedCharacters.includes(selectedCharacter)) selectedCharacter = 'standard';

        function saveUnlocks() {
            localStorage.setItem('samuraiUnlockedChars', JSON.stringify(unlockedCharacters));
            localStorage.setItem('samuraiSelectedChar', selectedCharacter);
        }

        // ===== SKILL TREES SYSTEM =====
        const skillTrees = {
            standard: {
                name: 'Warrior Path',
                skills: [
                    { id: 's1', name: 'Iron Will', icon: 'ðŸ›¡ï¸', desc: '+15% max health', cost: 50, effect: { stat: 'maxHealth', mult: 1.15 } },
                    { id: 's2', name: 'Sharp Edge', icon: 'âš”ï¸', desc: '+20% damage', cost: 100, effect: { stat: 'damage', mult: 1.2 } },
                    { id: 's3', name: 'Quick Feet', icon: 'ðŸ‘Ÿ', desc: '+10% move speed', cost: 150, effect: { stat: 'moveSpeed', mult: 1.1 } },
                    { id: 's4', name: 'Battle Fury', icon: 'ðŸ˜¤', desc: '+25% attack speed', cost: 200, effect: { stat: 'attackSpeed', mult: 1.25 } },
                    { id: 's5', name: 'Warrior Spirit', icon: 'ðŸ’ª', desc: '+30% crit damage', cost: 300, effect: { stat: 'critDamage', add: 0.6 } },
                    { id: 's6', name: 'Deflection', icon: 'âš”ï¸', desc: '15% melee deflect', cost: 400, effect: { special: 'deflectChance', add: 0.15 } },
                    { id: 's7', name: 'Warlord', icon: 'ðŸ‘‘', desc: '+25% damage', cost: 500, effect: { stat: 'damage', mult: 1.25 } }
                ]
            },
            knight: {
                name: 'Fortress Path',
                skills: [
                    { id: 'k1', name: 'Heavy Plates', icon: 'ðŸ°', desc: '+25% armor', cost: 50, effect: { stat: 'armor', add: 0.25 } },
                    { id: 'k2', name: 'Shield Wall', icon: 'ðŸ›¡ï¸', desc: '+30 max health', cost: 100, effect: { stat: 'maxHealth', add: 30 } },
                    { id: 'k3', name: 'Counter Strike', icon: 'âš¡', desc: '+15% damage', cost: 150, effect: { stat: 'damage', mult: 1.15 } },
                    { id: 'k4', name: 'Unmovable', icon: 'ðŸ—¿', desc: '+40% armor', cost: 200, effect: { stat: 'armor', add: 0.4 } },
                    { id: 'k5', name: 'Heavy Footed', icon: 'ðŸ¦¶', desc: '-3 stamina drain', cost: 300, effect: { stat: 'staminaMoveDrain', add: -3 } },
                    { id: 'k6', name: 'Iron Skin', icon: 'ðŸ”©', desc: '+30% armor', cost: 400, effect: { stat: 'armor', add: 0.3 } },
                    { id: 'k7', name: 'Immortal', icon: 'ðŸ’Ž', desc: '+75 max health', cost: 500, effect: { stat: 'maxHealth', add: 75 } }
                ]
            },
            thrower: {
                name: 'Shuriken Path',
                skills: [
                    { id: 't1', name: 'Sharp Edges', icon: 'â­', desc: '+25% shuriken damage', cost: 50, effect: { stat: 'damage', mult: 1.25 } },
                    { id: 't2', name: 'Quick Hands', icon: 'âœ‹', desc: '-20% shuriken regen', cost: 100, effect: { special: 'shurikenRegen', mult: 0.8 } },
                    { id: 't3', name: 'Rapid Throw', icon: 'ðŸ’¨', desc: '+20% attack speed', cost: 150, effect: { stat: 'attackSpeed', mult: 1.2 } },
                    { id: 't4', name: 'Extra Pouch', icon: 'ðŸŽ’', desc: '+2 max shurikens', cost: 200, effect: { special: 'maxShurikens', add: 2 } },
                    { id: 't5', name: 'Master Thrower', icon: 'ðŸŒŸ', desc: '+40% shuriken damage', cost: 300, effect: { stat: 'damage', mult: 1.4 } },
                    { id: 't6', name: 'Endless Stars', icon: 'âœ¨', desc: '+3 max shurikens', cost: 400, effect: { special: 'maxShurikens', add: 3 } },
                    { id: 't7', name: 'Blade Storm', icon: 'ðŸŒ€', desc: '-30% shuriken regen', cost: 500, effect: { special: 'shurikenRegen', mult: 0.7 } }
                ]
            },
            assassin: {
                name: 'Shadow Path',
                skills: [
                    { id: 'a1', name: 'Deadly Aim', icon: 'ðŸŽ¯', desc: '+10% crit chance', cost: 50, effect: { stat: 'critChance', add: 0.1 } },
                    { id: 'a2', name: 'Swift Blade', icon: 'âš¡', desc: '+30% attack speed', cost: 100, effect: { stat: 'attackSpeed', mult: 1.3 } },
                    { id: 'a3', name: 'Ghost Step', icon: 'ðŸ‘»', desc: '+15% move speed', cost: 150, effect: { stat: 'moveSpeed', mult: 1.15 } },
                    { id: 'a4', name: 'Backstab', icon: 'ðŸ—¡ï¸', desc: '+50% crit damage', cost: 200, effect: { stat: 'critDamage', add: 1.0 } },
                    { id: 'a5', name: 'Acrobat', icon: 'ðŸ¤¸', desc: '-10 dodge stamina cost', cost: 300, effect: { stat: 'staminaDodgeCost', add: -10 } },
                    { id: 'a6', name: 'Shadow Dance', icon: 'ðŸŒ‘', desc: '+20% move speed', cost: 400, effect: { stat: 'moveSpeed', mult: 1.2 } },
                    { id: 'a7', name: 'Executioner', icon: 'âš°ï¸', desc: '+75% crit damage', cost: 500, effect: { stat: 'critDamage', add: 1.5 } }
                ]
            },
            archer: {
                name: 'Marksman Path',
                skills: [
                    { id: 'ar1', name: 'Steady Aim', icon: 'ðŸ¹', desc: '+25% arrow damage', cost: 50, effect: { stat: 'damage', mult: 1.25 } },
                    { id: 'ar2', name: 'Quick Draw', icon: 'âš¡', desc: '+25% attack speed', cost: 100, effect: { stat: 'attackSpeed', mult: 1.25 } },
                    { id: 'ar3', name: 'Long Shot', icon: 'ðŸ“', desc: '+30% arrow range', cost: 150, effect: { special: 'arrowRange', mult: 1.3 } },
                    { id: 'ar4', name: 'Eagle Eye', icon: 'ðŸ¦…', desc: '+15% crit chance', cost: 200, effect: { stat: 'critChance', add: 0.15 } },
                    { id: 'ar5', name: 'Fast Reload', icon: 'ðŸ”„', desc: '-30% arrow regen time', cost: 300, effect: { special: 'arrowRegen', mult: 0.7 } },
                    { id: 'ar6', name: 'Quick Quiver', icon: 'ðŸŽ’', desc: '+2 max arrows', cost: 400, effect: { special: 'maxArrows', add: 2 } },
                    { id: 'ar7', name: 'Deadeye', icon: 'ðŸ‘ï¸', desc: '+20% crit chance', cost: 500, effect: { stat: 'critChance', add: 0.2 } }
                ]
            },
            pikeman: {
                name: 'Lancer Path',
                skills: [
                    { id: 'p1', name: 'Long Reach', icon: 'ðŸ”±', desc: '+15% pike range', cost: 50, effect: { special: 'pikeRange', mult: 1.15 } },
                    { id: 'p2', name: 'Piercing Strike', icon: 'ðŸ—¡ï¸', desc: '+20% damage', cost: 100, effect: { stat: 'damage', mult: 1.2 } },
                    { id: 'p3', name: 'Rapid Thrust', icon: 'âš¡', desc: '+30% attack speed', cost: 150, effect: { stat: 'attackSpeed', mult: 1.3 } },
                    { id: 'p4', name: 'Phalanx', icon: 'ðŸ›¡ï¸', desc: '+20% max health', cost: 200, effect: { stat: 'maxHealth', mult: 1.2 } },
                    { id: 'p5', name: 'Marathon Runner', icon: 'ðŸƒ', desc: '+8 stamina regen', cost: 300, effect: { stat: 'staminaRegen', add: 8 } },
                    { id: 'p6', name: 'Skewer', icon: 'ðŸ¢', desc: '+20% pike range', cost: 400, effect: { special: 'pikeRange', mult: 1.2 } },
                    { id: 'p7', name: 'Dragoon', icon: 'ðŸ‰', desc: '+30% damage', cost: 500, effect: { stat: 'damage', mult: 1.3 } }
                ]
            },
            wizard: {
                name: 'Arcane Path',
                skills: [
                    { id: 'w1', name: 'Mana Flow', icon: 'ðŸ’™', desc: '+5 energy per melee', cost: 50, effect: { special: 'energyPerMelee', add: 5 } },
                    { id: 'w2', name: 'Fire Mastery', icon: 'ðŸ”¥', desc: '+30% fireball damage', cost: 100, effect: { special: 'fireballDamage', mult: 1.3 } },
                    { id: 'w3', name: 'Arcane Shield', icon: 'ðŸ›¡ï¸', desc: '+25 max health', cost: 150, effect: { stat: 'maxHealth', add: 25 } },
                    { id: 'w4', name: 'Homing Power', icon: 'ðŸŽ¯', desc: '+40% homing ball dmg', cost: 200, effect: { special: 'homingDamage', mult: 1.4 } },
                    { id: 'w5', name: 'Archmage', icon: 'â­', desc: '-20% spell costs', cost: 300, effect: { special: 'spellCost', mult: 0.8 } },
                    { id: 'w6', name: 'Mana Well', icon: 'ðŸ”®', desc: '+25 max energy', cost: 400, effect: { special: 'maxEnergy', add: 25 } },
                    { id: 'w7', name: 'Sorcerer Supreme', icon: 'ðŸ§™', desc: '+50% all spell damage', cost: 500, effect: { special: 'allSpellDamage', mult: 1.5 } }
                ]
            },
            necromancer: {
                name: 'Death Path',
                skills: [
                    { id: 'n1', name: 'Soul Harvest', icon: 'ðŸ‘»', desc: '+5 mana per melee', cost: 50, effect: { special: 'energyPerMelee', add: 5 } },
                    { id: 'n2', name: 'Stronger Bones', icon: 'ðŸ¦´', desc: '+30% minion health', cost: 100, effect: { special: 'minionHealth', mult: 1.3 } },
                    { id: 'n3', name: 'Dark Pact', icon: 'ðŸ“œ', desc: '+25 max health', cost: 150, effect: { stat: 'maxHealth', add: 25 } },
                    { id: 'n4', name: 'Army of Dead', icon: 'âš°ï¸', desc: '+2 max minions', cost: 200, effect: { special: 'maxMinions', add: 2 } },
                    { id: 'n5', name: 'Twin Souls', icon: 'ðŸ‘¥', desc: '25% double summon', cost: 300, effect: { special: 'doubleSummon', add: 0.25 } },
                    { id: 'n6', name: 'Soul Reservoir', icon: 'ðŸ’€', desc: '+30 max mana', cost: 400, effect: { special: 'maxEnergy', add: 30 } },
                    { id: 'n7', name: 'Lich Lord', icon: 'ðŸ‘‘', desc: '+50% minion damage', cost: 500, effect: { special: 'minionDamage', mult: 1.5 } }
                ]
            }
        };

        // XP and unlocked skills per character
        let characterXP = JSON.parse(localStorage.getItem('samuraiCharXP')) || {};
        let characterSkills = JSON.parse(localStorage.getItem('samuraiCharSkills')) || {};

        function saveSkillData() {
            localStorage.setItem('samuraiCharXP', JSON.stringify(characterXP));
            localStorage.setItem('samuraiCharSkills', JSON.stringify(characterSkills));
        }

        function getCharXP(charId) {
            return characterXP[charId] || 0;
        }

        function addCharXP(charId, amount) {
            if (!characterXP[charId]) characterXP[charId] = 0;
            // Apply relic XP penalty (15% reduction per active relic)
            const multiplier = getXPMultiplier();
            const finalAmount = Math.max(1, Math.floor(amount * multiplier));
            characterXP[charId] += finalAmount;
            saveSkillData();
            // Show floating XP popup during gameplay
            if (gameState === 'playing') {
                showXPPopup(finalAmount);
            }
        }

        function showXPPopup(amount) {
            const popup = document.createElement('div');
            popup.className = 'xp-popup';
            popup.textContent = `+${amount} XP`;
            popup.style.left = `${window.innerWidth / 2 + (Math.random() - 0.5) * 100}px`;
            popup.style.top = `${window.innerHeight / 2 - 50}px`;
            document.body.appendChild(popup);
            setTimeout(() => popup.remove(), 1000);
        }

        const MAX_SKILL_LEVEL = 5;
        const SKILL_COST_INCREASE = 1.25; // 25% more expensive each level

        function getSkillLevel(charId, skillId) {
            if (!characterSkills[charId]) return 0;
            return characterSkills[charId][skillId] || 0;
        }

        function getSkillCost(baseCost, currentLevel) {
            return Math.floor(baseCost * Math.pow(SKILL_COST_INCREASE, currentLevel));
        }

        function upgradeSkill(charId, skillId, baseCost) {
            if (!characterSkills[charId]) characterSkills[charId] = {};
            const currentLevel = getSkillLevel(charId, skillId);
            if (currentLevel >= MAX_SKILL_LEVEL) return false;
            const cost = getSkillCost(baseCost, currentLevel);
            if (getCharXP(charId) < cost) return false;
            characterXP[charId] -= cost;
            characterSkills[charId][skillId] = currentLevel + 1;
            saveSkillData();
            return true;
        }

        function getSkillBonuses(charId) {
            const bonuses = { statMults: {}, statAdds: {}, specials: {} };
            const tree = skillTrees[charId];
            if (!tree) return bonuses;
            tree.skills.forEach(skill => {
                const level = getSkillLevel(charId, skill.id);
                if (level > 0) {
                    const eff = skill.effect;
                    // Apply effect multiple times based on level
                    for (let i = 0; i < level; i++) {
                        if (eff.stat) {
                            if (eff.mult) {
                                bonuses.statMults[eff.stat] = (bonuses.statMults[eff.stat] || 1) * eff.mult;
                            }
                            if (eff.add) {
                                bonuses.statAdds[eff.stat] = (bonuses.statAdds[eff.stat] || 0) + eff.add;
                            }
                        }
                        if (eff.special) {
                            if (eff.mult) {
                                bonuses.specials[eff.special] = (bonuses.specials[eff.special] || { mult: 1, add: 0 });
                                bonuses.specials[eff.special].mult *= eff.mult;
                            }
                            if (eff.add) {
                                bonuses.specials[eff.special] = (bonuses.specials[eff.special] || { mult: 1, add: 0 });
                                bonuses.specials[eff.special].add += eff.add;
                            }
                        }
                    }
                }
            });
            return bonuses;
        }

        let currentSkillTreeChar = 'standard';

        function openSkillTree() {
            document.getElementById('skillTreeOverlay').classList.remove('hidden');
            renderSkillTreeTabs();
            renderSkillTree(currentSkillTreeChar);
        }

        function closeSkillTree() {
            document.getElementById('skillTreeOverlay').classList.add('hidden');
        }

        function renderSkillTreeTabs() {
            const container = document.getElementById('skillTreeTabs');
            container.innerHTML = '';
            Object.keys(skillTrees).forEach(charId => {
                if (unlockedCharacters.includes(charId)) {
                    const char = characters[charId];
                    const tab = document.createElement('button');
                    tab.className = 'skill-tab' + (charId === currentSkillTreeChar ? ' active' : '');
                    tab.innerHTML = `${char.icon} ${char.name}`;
                    tab.onclick = () => {
                        currentSkillTreeChar = charId;
                        renderSkillTreeTabs();
                        renderSkillTree(charId);
                    };
                    container.appendChild(tab);
                }
            });
        }

        function renderSkillTree(charId) {
            const tree = skillTrees[charId];
            const char = characters[charId];
            const xp = getCharXP(charId);

            document.getElementById('skillTreeXPDisplay').innerHTML = `
                <span style="color:#ffd700;">â­ ${tree.name}</span> |
                <span style="color:#4f4;">XP: ${xp}</span>
            `;

            const grid = document.getElementById('skillTreeGrid');
            grid.innerHTML = '';
            tree.skills.forEach(skill => {
                const level = getSkillLevel(charId, skill.id);
                const isMaxed = level >= MAX_SKILL_LEVEL;
                const nextCost = getSkillCost(skill.cost, level);
                const canAfford = xp >= nextCost && !isMaxed;
                const node = document.createElement('div');
                node.className = 'skill-node';
                if (isMaxed) node.classList.add('unlocked');
                else if (canAfford) node.classList.add('affordable');
                else if (level > 0) node.classList.add('unlocked');
                else node.classList.add('locked');

                // Create level indicator dots
                let levelDots = '';
                for (let i = 0; i < MAX_SKILL_LEVEL; i++) {
                    levelDots += `<span style="color:${i < level ? '#4f4' : '#444'};">â—</span>`;
                }

                node.innerHTML = `
                    ${isMaxed ? '<span class="skill-check">MAX</span>' : ''}
                    <div class="skill-icon">${skill.icon}</div>
                    <div class="skill-name">${skill.name}</div>
                    <div class="skill-desc">${skill.desc}</div>
                    <div style="font-size:14px;margin:5px 0;letter-spacing:2px;">${levelDots}</div>
                    <div class="skill-cost">${isMaxed ? 'MAXED' : nextCost + ' XP'}</div>
                `;

                if (!isMaxed && canAfford) {
                    node.onclick = () => {
                        if (upgradeSkill(charId, skill.id, skill.cost)) {
                            renderSkillTree(charId);
                        }
                    };
                }
                grid.appendChild(node);
            });
        }

        // Skill tree button listeners
        document.getElementById('openSkillTree').addEventListener('click', openSkillTree);
        document.getElementById('skillTreeClose').addEventListener('click', closeSkillTree);
        // ===== END SKILL TREES =====

        // Quest button listeners
        document.getElementById('openQuests').addEventListener('click', openQuestOverlay);
        document.getElementById('questClose').addEventListener('click', closeQuestOverlay);
        document.getElementById('questRefreshBtn').addEventListener('click', () => {
            if (!useQuestRefresh()) {
                alert('No refreshes available! Complete a quest to earn a refresh.');
            }
        });

        function unlockNextCharacter(currentCharId) {
            const unlockOrder = ['standard', 'knight', 'thrower', 'assassin'];
            const currentIndex = unlockOrder.indexOf(currentCharId);
            if (currentIndex < unlockOrder.length - 1) {
                const nextChar = unlockOrder[currentIndex + 1];
                if (!unlockedCharacters.includes(nextChar)) {
                    unlockedCharacters.push(nextChar);
                    saveUnlocks();
                    return nextChar;
                }
            }
            // Archer/Pikeman unlock each other when beating the game (wave 50)
            if (currentCharId === 'archer' && !unlockedCharacters.includes('pikeman')) {
                unlockedCharacters.push('pikeman');
                saveUnlocks();
                return 'pikeman';
            }
            if (currentCharId === 'pikeman' && !unlockedCharacters.includes('archer')) {
                unlockedCharacters.push('archer');
                saveUnlocks();
                return 'archer';
            }
            // Track archer/pikeman wins for wizard unlock
            if (currentCharId === 'archer') {
                localStorage.setItem('archerWin', 'true');
            }
            if (currentCharId === 'pikeman') {
                localStorage.setItem('pikemanWin', 'true');
            }
            // Wizard unlocks after winning with BOTH archer and pikeman
            if (localStorage.getItem('archerWin') === 'true' &&
                localStorage.getItem('pikemanWin') === 'true' &&
                !unlockedCharacters.includes('wizard')) {
                unlockedCharacters.push('wizard');
                saveUnlocks();
                return 'wizard';
            }
            // Necromancer unlocks after winning with Wizard
            if (currentCharId === 'wizard' && !unlockedCharacters.includes('necromancer')) {
                unlockedCharacters.push('necromancer');
                saveUnlocks();
                return 'necromancer';
            }
            return null;
        }

        function getUnlockText(charId) {
            const char = characters[charId];
            if (charId === 'archer') {
                return unlockedCharacters.includes('pikeman')
                    ? 'Beat the game with Pikeman'
                    : 'Choose as starter or beat game with Pikeman';
            }
            if (charId === 'pikeman') {
                return unlockedCharacters.includes('archer')
                    ? 'Beat the game with Archer'
                    : 'Choose as starter or beat game with Archer';
            }
            if (charId === 'wizard') {
                const archerWin = localStorage.getItem('archerWin') === 'true';
                const pikemanWin = localStorage.getItem('pikemanWin') === 'true';
                if (!archerWin && !pikemanWin) return 'Beat game with Archer AND Pikeman';
                if (!archerWin) return 'Beat game with Archer (Pikeman done!)';
                if (!pikemanWin) return 'Beat game with Pikeman (Archer done!)';
                return 'Unlocked!';
            }
            if (char.unlockRequires) {
                const unlockChar = characters[char.unlockRequires];
                return `Beat the game with ${unlockChar ? unlockChar.name : '?'}`;
            }
            return 'Locked';
        }

        function renderRelicsPanel() {
            const container = document.getElementById('relicsList');
            if (!container) return;

            const mapOrder = ['forest', 'desert', 'volcano', 'frost', 'swamp', 'shadow', 'crystal', 'graveyard', 'sky', 'abyss'];

            // Header with XP penalty info
            const xpMult = getXPMultiplier();
            const xpPenalty = Math.round((1 - xpMult) * 100);
            let html = `<div style="text-align:center;margin-bottom:10px;font-size:10px;">
                <span style="color:#ff8888;">Active: ${activeRelics.length}/${MAX_ACTIVE_RELICS}</span><br>
                <span style="color:#ffaa44;">XP: ${xpPenalty > 0 ? '-' + xpPenalty + '%' : 'Normal'}</span>
            </div>`;

            mapOrder.forEach(mapId => {
                const relic = relics[mapId];
                const map = gameMaps[mapId];
                const isUnlocked = isRelicUnlocked(mapId);
                const isActive = hasRelic(mapId);

                let slotClass = 'relic-slot';
                if (!isUnlocked) slotClass += ' locked';
                else if (isActive) slotClass += ' active';
                else slotClass += ' unlocked';

                let statusText = 'ðŸ”’ Locked';
                if (isUnlocked) {
                    if (isActive) {
                        statusText = 'âœ“ Active (click to disable)';
                    } else if (activeRelics.length >= MAX_ACTIVE_RELICS) {
                        statusText = 'âš  Max relics active (disable one first)';
                    } else {
                        statusText = 'â—‹ Inactive (click to enable)';
                    }
                }

                html += `
                    <div class="${slotClass}" data-relic="${mapId}" ${isUnlocked ? 'style="cursor:pointer;"' : ''}>
                        <div class="relic-icon">${isUnlocked ? relic.icon : 'â“'}</div>
                        <div class="relic-info">
                            <div class="relic-name">${isUnlocked ? relic.name : '???'}</div>
                            <div class="relic-map">${map.name}</div>
                            ${isUnlocked ? `<div class="relic-toggle">${isActive ? 'â— ON' : 'â—‹ OFF'}</div>` : ''}
                        </div>
                        <div class="relic-tooltip">
                            <h4>${isUnlocked ? relic.icon : 'â“'} ${isUnlocked ? relic.name : 'Unknown Relic'}</h4>
                            <p>${isUnlocked ? relic.desc : 'Beat ' + map.name + ' to unlock this relic.'}</p>
                            <div class="relic-status" style="color:${isActive ? '#44ff44' : '#888'}">${statusText}</div>
                            ${isUnlocked ? '<div style="color:#ff8888;font-size:9px;margin-top:5px;">-15% XP when active</div>' : ''}
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;

            // Add click handlers for toggling relics
            container.querySelectorAll('.relic-slot[data-relic]').forEach(slot => {
                slot.addEventListener('click', () => {
                    const relicId = slot.dataset.relic;
                    if (isRelicUnlocked(relicId)) {
                        const toggled = toggleRelic(relicId);
                        if (!toggled && !hasRelic(relicId)) {
                            // Failed to activate - at max
                            alert('Maximum 3 relics can be active! Disable one first.');
                        }
                        renderRelicsPanel(); // Re-render to update display
                    }
                });
            });
        }

        function renderCharacterSelect() {
            const container = document.getElementById('characterSelect');

            // Define unlock chains with arrows
            // Row 1: Standard â†’ Knight â†’ Thrower â†’ Assassin
            // Row 2: Archer â†” Pikeman â†’ Wizard â†’ Necromancer
            const row1 = ['standard', 'knight', 'thrower', 'assassin'];
            const row2 = ['archer', 'pikeman', 'wizard', 'necromancer'];

            function renderCard(charId) {
                const char = characters[charId];
                const isUnlocked = unlockedCharacters.includes(charId);
                const isSelected = selectedCharacter === charId;
                const xp = getCharXP(charId);

                return `
                    <div class="char-card ${isSelected ? 'selected' : ''} ${!isUnlocked ? 'locked' : ''}"
                         data-char="${charId}" ${!isUnlocked ? 'title="Locked"' : ''}>
                        <div class="char-icon">${char.icon}</div>
                        <div class="char-name">${char.name}</div>
                        <div class="char-role">${char.role}</div>
                        ${isUnlocked ? `<div class="char-xp" style="color:#ffd700;font-size:11px;margin-top:3px;">â­ ${xp} XP</div>` : ''}
                        <div class="char-stats">
                            ${char.statDisplay.map(s => {
                                const isGood = s.includes('+') || s.includes('Backstab') || s.includes('Throw') || s.includes('LMB:') || s.includes('Long Reach') || s.includes('Fast Attacks') || s.includes('Q:') || s.includes('E:') || s.includes('Energy');
                                const isBad = s.includes('-') || s.includes('No Melee') || s.includes('Very Slow') || s.includes('Slow Movement') || s.includes('75 HP');
                                return `<span class="${isGood ? 'stat-good' : ''} ${isBad ? 'stat-bad' : ''}">${s}</span>`;
                            }).join('')}
                        </div>
                        ${!isUnlocked ? `<div class="locked-text">${getUnlockText(charId)}</div>` : ''}
                    </div>
                `;
            }

            // Build Row 1: Standard â†’ Knight â†’ Thrower â†’ Assassin
            let row1Html = '<div class="char-row">';
            row1Html += renderCard('standard');
            row1Html += '<span class="unlock-arrow">â†’</span>';
            row1Html += renderCard('knight');
            row1Html += '<span class="unlock-arrow">â†’</span>';
            row1Html += renderCard('thrower');
            row1Html += '<span class="unlock-arrow">â†’</span>';
            row1Html += renderCard('assassin');
            row1Html += '</div>';

            // Build Row 2: Archer â†” Pikeman â†’ Wizard â†’ Necromancer
            let row2Html = '<div class="char-row">';
            row2Html += renderCard('archer');
            row2Html += '<span class="unlock-arrow bidirectional">â†”</span>';
            row2Html += renderCard('pikeman');
            row2Html += '<span class="unlock-arrow">â†’</span>';
            row2Html += renderCard('wizard');
            row2Html += '<span class="unlock-arrow">â†’</span>';
            row2Html += renderCard('necromancer');
            row2Html += '</div>';

            container.innerHTML = row1Html + row2Html;

            // Add click handlers
            container.querySelectorAll('.char-card:not(.locked)').forEach(card => {
                card.addEventListener('click', () => {
                    selectedCharacter = card.dataset.char;
                    saveUnlocks();
                    renderCharacterSelect();
                    updateSelectedCharInfo();
                });
            });

            updateSelectedCharInfo();
        }

        function updateSelectedCharInfo() {
            const char = characters[selectedCharacter];
            const info = document.getElementById('selectedCharInfo');
            info.innerHTML = `<strong>${char.name}</strong>: ${char.description}`;
        }

        // Initialize character select on load
        setTimeout(renderCharacterSelect, 100);
        setTimeout(renderRelicsPanel, 100);

        // ========== MAP SELECTION SYSTEM ==========
        const mapIcons = {
            forest: 'ðŸŒ²', desert: 'ðŸœï¸', volcano: 'ðŸŒ‹', frost: 'â„ï¸',
            swamp: 'ðŸ¸', shadow: 'ðŸ‘ï¸', crystal: 'ðŸ’Ž', graveyard: 'ðŸ’€',
            sky: 'â˜ï¸', abyss: 'ðŸ”¥'
        };

        function renderMapSelect() {
            const container = document.getElementById('mapSelectContainer');

            // Two rows of 5 maps each
            const row1Maps = ['forest', 'desert', 'volcano', 'frost', 'swamp'];
            const row2Maps = ['shadow', 'crystal', 'graveyard', 'sky', 'abyss'];

            function renderMapCard(mapId) {
                const map = gameMaps[mapId];
                const isUnlocked = unlockedMaps.includes(mapId);
                const isSelected = selectedMap === mapId;
                const mapIndex = mapOrder.indexOf(mapId);
                const prevMap = mapIndex > 0 ? gameMaps[mapOrder[mapIndex - 1]] : null;

                return `
                    <div class="map-card ${isSelected ? 'selected' : ''} ${!isUnlocked ? 'locked' : ''}"
                         data-map="${mapId}">
                        <div class="map-icon">${mapIcons[mapId] || 'ðŸ—ºï¸'}</div>
                        <div class="map-name">${map.name}</div>
                        ${!isUnlocked ? `<div class="map-locked">Beat ${prevMap ? prevMap.name : '?'}</div>` : ''}
                    </div>
                `;
            }

            let row1Html = '<div class="map-row">';
            row1Maps.forEach((mapId, i) => {
                row1Html += renderMapCard(mapId);
                if (i < row1Maps.length - 1) row1Html += '<span class="map-arrow">â†’</span>';
            });
            row1Html += '</div>';

            let row2Html = '<div class="map-row">';
            row2Maps.forEach((mapId, i) => {
                row2Html += renderMapCard(mapId);
                if (i < row2Maps.length - 1) row2Html += '<span class="map-arrow">â†’</span>';
            });
            row2Html += '</div>';

            container.innerHTML = row1Html + row2Html;

            // Add click handlers
            container.querySelectorAll('.map-card:not(.locked)').forEach(card => {
                card.addEventListener('click', () => {
                    selectedMap = card.dataset.map;
                    saveMapUnlocks();
                    renderMapSelect();
                    updateSelectedMapInfo();
                });
            });
        }

        function updateSelectedMapInfo() {
            const map = gameMaps[selectedMap];
            const info = document.getElementById('selectedMapInfo');
            info.innerHTML = `${mapIcons[selectedMap]} <strong>${map.name}</strong>`;
        }

        function showMapSelect() {
            renderMapSelect();
            document.getElementById('mapSelectOverlay').classList.remove('hidden');
        }

        function hideMapSelect() {
            document.getElementById('mapSelectOverlay').classList.add('hidden');
        }

        // Map select button handlers
        document.getElementById('selectMapBtn').addEventListener('click', showMapSelect);
        document.getElementById('mapSelectClose').addEventListener('click', hideMapSelect);

        // Initialize map info
        setTimeout(updateSelectedMapInfo, 100);

        // ========== STARTER CHOICE SYSTEM ==========
        let hasChosenStarter = localStorage.getItem('samuraiStarterChosen') === 'true';

        function showStarterChoice() {
            document.getElementById('starterChoiceOverlay').classList.remove('hidden');
        }

        function hideStarterChoice() {
            document.getElementById('starterChoiceOverlay').classList.add('hidden');
        }

        function chooseStarter(starterId) {
            if (!unlockedCharacters.includes(starterId)) {
                unlockedCharacters.push(starterId);
            }
            hasChosenStarter = true;
            localStorage.setItem('samuraiStarterChosen', 'true');
            saveUnlocks();
            hideStarterChoice();
            renderCharacterSelect();
        }

        // Add click handlers for starter choice
        document.querySelectorAll('.starter-card').forEach(card => {
            card.addEventListener('click', () => {
                chooseStarter(card.dataset.starter);
            });
        });

        // Show starter choice on first visit if neither archer nor pikeman is unlocked
        setTimeout(() => {
            if (!hasChosenStarter && !unlockedCharacters.includes('archer') && !unlockedCharacters.includes('pikeman')) {
                showStarterChoice();
            }
        }, 200);

        // ========== DIFFICULTY SYSTEM ==========
        const difficultySettings = {
            easy: {
                name: 'Easy',
                enemyHealthMult: 0.75,
                bossHealthMult: 0.75 * 0.75, // 25% less than regular enemies
                description: 'Enemies have 75% health, bosses have 56% health'
            },
            medium: {
                name: 'Medium',
                enemyHealthMult: 1.0,
                bossHealthMult: 0.75, // 25% less than regular enemies
                description: 'Standard difficulty, bosses have 75% health'
            },
            hard: {
                name: 'Hard',
                enemyHealthMult: 1.25,
                bossHealthMult: 1.25 * 0.75, // 25% less than regular enemies
                description: 'Enemies have 125% health, bosses have 94% health'
            }
        };

        let selectedDifficulty = localStorage.getItem('samuraiDifficulty') || 'medium';

        function saveDifficulty() {
            localStorage.setItem('samuraiDifficulty', selectedDifficulty);
        }

        function renderDifficultySelect() {
            const buttons = document.querySelectorAll('.diff-btn');
            buttons.forEach(btn => {
                btn.classList.remove('selected');
                if (btn.dataset.diff === selectedDifficulty) {
                    btn.classList.add('selected');
                }
            });
            updateDifficultyInfo();
        }

        function updateDifficultyInfo() {
            const info = document.getElementById('difficultyInfo');
            const diff = difficultySettings[selectedDifficulty];
            info.textContent = diff.description;
        }

        // Add click handlers for difficulty buttons
        document.querySelectorAll('.diff-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                selectedDifficulty = btn.dataset.diff;
                saveDifficulty();
                renderDifficultySelect();
            });
        });

        // Initialize difficulty select on load
        setTimeout(renderDifficultySelect, 100);

        // Player upgrades and stats
        const playerStats = {
            maxHealth: 100,
            damage: 1.0, // multiplier
            attackSpeed: 1.0, // multiplier (lower = faster)
            moveSpeed: 1.0, // multiplier
            armor: 0,
            critChance: 0,
            critDamage: 1.5,
            lifesteal: 0,
            comboBonus: 0,
            attackRange: 1.0, // multiplier
            regenRate: 1.0, // multiplier
            parryDamageReduction: 0.75,
            // Stamina stats
            maxStamina: 100,
            staminaRegen: 15, // per second when not moving
            staminaMoveDrain: 8, // per second while moving
            staminaDodgeCost: 25, // cost per dodge roll
            skillBonuses: {} // Character skill tree bonuses
        };

        // Rare card levels (for stacking effects)
        const rareCardLevels = {};

        // Legendary abilities
        const playerAbilities = []; // Max 5
        const abilityCooldowns = {}; // Track cooldowns by ability id

        // ========== CARD DEFINITIONS ==========
        // 30 Common cards - stat upgrades
        const commonCards = [
            { id: 'c1', name: 'Vitality', icon: 'â¤ï¸', desc: '+15 Max Health', effect: () => { playerStats.maxHealth += 15; } },
            { id: 'c2', name: 'Fortitude', icon: 'ðŸ’ª', desc: '+25 Max Health', effect: () => { playerStats.maxHealth += 25; } },
            { id: 'c3', name: 'Sharp Edge', icon: 'ðŸ—¡ï¸', desc: '+10% Damage', effect: () => { playerStats.damage += 0.1; } },
            { id: 'c4', name: 'Deadly Strike', icon: 'âš”ï¸', desc: '+15% Damage', effect: () => { playerStats.damage += 0.15; } },
            { id: 'c5', name: 'Swift Blade', icon: 'ðŸ’¨', desc: '-10% Attack Cooldown', effect: () => { playerStats.attackSpeed *= 0.9; } },
            { id: 'c6', name: 'Quick Slash', icon: 'âš¡', desc: '-15% Attack Cooldown', effect: () => { playerStats.attackSpeed *= 0.85; } },
            { id: 'c7', name: 'Light Feet', icon: 'ðŸ‘Ÿ', desc: '+10% Move Speed', effect: () => { playerStats.moveSpeed += 0.1; } },
            { id: 'c8', name: 'Wind Walker', icon: 'ðŸŒªï¸', desc: '+15% Move Speed', effect: () => { playerStats.moveSpeed += 0.15; } },
            { id: 'c9', name: 'Iron Skin', icon: 'ðŸ›¡ï¸', desc: '+1 Armor', effect: () => { playerStats.armor += 1; } },
            { id: 'c10', name: 'Steel Plates', icon: 'ðŸ”©', desc: '+2 Armor', effect: () => { playerStats.armor += 2; } },
            { id: 'c11', name: 'Keen Eye', icon: 'ðŸ‘ï¸', desc: '+5% Crit Chance', effect: () => { playerStats.critChance += 0.05; } },
            { id: 'c12', name: 'Precision', icon: 'ðŸŽ¯', desc: '+8% Crit Chance', effect: () => { playerStats.critChance += 0.08; } },
            { id: 'c13', name: 'Brutal Force', icon: 'ðŸ’¥', desc: '+25% Crit Damage', effect: () => { playerStats.critDamage += 0.25; } },
            { id: 'c14', name: 'Savage Blow', icon: 'ðŸ”¥', desc: '+40% Crit Damage', effect: () => { playerStats.critDamage += 0.4; } },
            { id: 'c15', name: 'Long Reach', icon: 'ðŸ“', desc: '+10% Attack Range', effect: () => { playerStats.attackRange += 0.1; } },
            { id: 'c16', name: 'Extended Strike', icon: 'ðŸ—¡ï¸', desc: '+15% Attack Range', effect: () => { playerStats.attackRange += 0.15; } },
            { id: 'c17', name: 'Regeneration', icon: 'ðŸ’š', desc: '+25% Health Regen', effect: () => { playerStats.regenRate += 0.25; } },
            { id: 'c18', name: 'Rapid Recovery', icon: 'ðŸŒ¿', desc: '+40% Health Regen', effect: () => { playerStats.regenRate += 0.4; } },
            { id: 'c19', name: 'Thick Skin', icon: 'ðŸ§±', desc: '+10 Max Health, +1 Armor', effect: () => { playerStats.maxHealth += 10; playerStats.armor += 1; } },
            { id: 'c20', name: 'Battle Ready', icon: 'âš”ï¸', desc: '+5% Damage, +5% Speed', effect: () => { playerStats.damage += 0.05; playerStats.moveSpeed += 0.05; } },
            { id: 'c21', name: 'Giant Slayer', icon: 'ðŸ—¿', desc: '+20% damage to bosses', effect: () => { playerStats.bossDamage = (playerStats.bossDamage || 0) + 0.2; } },
            { id: 'c22', name: 'Dodger', icon: 'ðŸ’«', desc: '+8% dodge chance', effect: () => { playerStats.dodgeChance = (playerStats.dodgeChance || 0) + 0.08; } },
            { id: 'c23', name: 'Arrow Ward', icon: 'ðŸ¹', desc: '-20% ranged damage taken', effect: () => { playerStats.rangedResist = (playerStats.rangedResist || 0) + 0.2; } },
            { id: 'c24', name: 'Second Wind', icon: 'ðŸŒ¬ï¸', desc: '+50% regen when low HP', effect: () => { playerStats.lowHealthRegen = (playerStats.lowHealthRegen || 0) + 0.5; } },
            { id: 'c25', name: 'Warrior Heart', icon: 'ðŸ’–', desc: '+35 Max Health', effect: () => { playerStats.maxHealth += 35; } },
            { id: 'c26', name: 'Blade Master', icon: 'âš”ï¸', desc: '+20% Damage', effect: () => { playerStats.damage += 0.2; } },
            { id: 'c27', name: 'Haste', icon: 'ðŸƒ', desc: '+20% Move Speed', effect: () => { playerStats.moveSpeed += 0.2; } },
            { id: 'c28', name: 'Assassin Eye', icon: 'ðŸŽ¯', desc: '+12% Crit Chance', effect: () => { playerStats.critChance += 0.12; } },
            { id: 'c29', name: 'Fortress', icon: 'ðŸ°', desc: '+3 Armor', effect: () => { playerStats.armor += 3; } },
            { id: 'c30', name: 'Sweeping Blade', icon: 'ðŸŒ€', desc: '+20% Attack Range', effect: () => { playerStats.attackRange += 0.2; } },
            // Stamina cards
            { id: 'c31', name: 'Endurance', icon: 'ðŸƒ', desc: '+15 Max Stamina', effect: () => { playerStats.maxStamina += 15; } },
            { id: 'c32', name: 'Marathon Runner', icon: 'ðŸŽ½', desc: '+25 Max Stamina', effect: () => { playerStats.maxStamina += 25; } },
            { id: 'c33', name: 'Quick Recovery', icon: 'ðŸ’¨', desc: '+3 Stamina Regen', effect: () => { playerStats.staminaRegen += 3; } },
            { id: 'c34', name: 'Second Breath', icon: 'ðŸŒ¬ï¸', desc: '+5 Stamina Regen', effect: () => { playerStats.staminaRegen += 5; } },
            { id: 'c35', name: 'Efficient Movement', icon: 'ðŸ¦¶', desc: '-1.5 Stamina Drain', effect: () => { playerStats.staminaMoveDrain = Math.max(1, playerStats.staminaMoveDrain - 1.5); } },
            { id: 'c36', name: 'Light Footed', icon: 'ðŸª¶', desc: '-2.5 Stamina Drain', effect: () => { playerStats.staminaMoveDrain = Math.max(1, playerStats.staminaMoveDrain - 2.5); } },
            { id: 'c37', name: 'Agile Dodge', icon: 'ðŸ’«', desc: '-5 Dodge Stamina Cost', effect: () => { playerStats.staminaDodgeCost = Math.max(5, playerStats.staminaDodgeCost - 5); } },
            { id: 'c38', name: 'Athletic', icon: 'ðŸ‹ï¸', desc: '+10 Max Stamina, +2 Regen', effect: () => { playerStats.maxStamina += 10; playerStats.staminaRegen += 2; } }
        ];

        // 18 Rare cards - special effects that level up
        const rareCards = [
            { id: 'r1', name: 'Vampiric Blade', icon: 'ðŸ§›', desc: 'Lifesteal: Heal for {val}% of damage dealt',
              levels: [3, 6, 10, 15, 20], effect: (lvl) => { playerStats.lifesteal = rareCards[0].levels[lvl-1] / 100; } },
            { id: 'r2', name: 'Combo Master', icon: 'ðŸ”—', desc: 'Consecutive hits deal +{val}% damage',
              levels: [5, 10, 18, 28, 40], effect: (lvl) => { playerStats.comboBonus = rareCards[1].levels[lvl-1] / 100; } },
            { id: 'r3', name: 'Berserker', icon: 'ðŸ˜¤', desc: '+{val}% damage when below 50% health',
              levels: [20, 35, 50, 70, 100], effect: (lvl) => { playerStats.berserkBonus = rareCards[2].levels[lvl-1] / 100; } },
            { id: 'r4', name: 'Thorns', icon: 'ðŸŒ¹', desc: 'Reflect {val}% damage to attackers',
              levels: [10, 20, 30, 45, 60], effect: (lvl) => { playerStats.thornsDamage = rareCards[3].levels[lvl-1] / 100; } },
            { id: 'r5', name: 'Execute', icon: 'ðŸ’€', desc: 'Deal +{val}% damage to enemies below 30% HP',
              levels: [25, 45, 70, 100, 150], effect: (lvl) => { playerStats.executeBonus = rareCards[4].levels[lvl-1] / 100; } },
            { id: 'r6', name: 'Perfect Parry', icon: 'ðŸ›¡ï¸', desc: 'Parry blocks {val}% damage',
              levels: [80, 85, 90, 95, 100], effect: (lvl) => { playerStats.parryDamageReduction = rareCards[5].levels[lvl-1] / 100; } },
            { id: 'r7', name: 'Momentum', icon: 'ðŸƒ', desc: 'Kills grant +{val}% speed for 3s',
              levels: [15, 25, 40, 60, 80], effect: (lvl) => { playerStats.momentumBonus = rareCards[6].levels[lvl-1] / 100; } },
            { id: 'r8', name: 'Cleave', icon: 'ðŸŒ€', desc: 'Attacks hit +{val} additional enemies',
              levels: [1, 2, 3, 4, 5], effect: (lvl) => { playerStats.cleaveTargets = rareCards[7].levels[lvl-1]; } },
            { id: 'r9', name: 'Critical Surge', icon: 'âš¡', desc: 'Crits restore {val} health',
              levels: [3, 6, 10, 15, 22], effect: (lvl) => { playerStats.critHeal = rareCards[8].levels[lvl-1]; } },
            { id: 'r10', name: 'Last Stand', icon: 'ðŸ°', desc: 'Take {val}% less damage below 25% HP',
              levels: [20, 35, 50, 65, 80], effect: (lvl) => { playerStats.lastStandReduction = rareCards[9].levels[lvl-1] / 100; } },
            { id: 'r11', name: 'First Strike', icon: 'ðŸŽª', desc: 'First hit on enemy deals +{val}% damage',
              levels: [30, 55, 85, 120, 160], effect: (lvl) => { playerStats.firstStrikeBonus = rareCards[10].levels[lvl-1] / 100; } },
            { id: 'r12', name: 'Adrenaline', icon: 'ðŸ’‰', desc: 'Taking damage boosts attack speed by {val}% for 2s',
              levels: [15, 25, 40, 55, 75], effect: (lvl) => { playerStats.adrenalineBonus = rareCards[11].levels[lvl-1] / 100; } },
            { id: 'r13', name: 'Soul Eater', icon: 'ðŸ‘»', desc: 'Kills permanently grant +{val} max HP',
              levels: [1, 2, 3, 5, 8], effect: (lvl) => { playerStats.soulEaterBonus = rareCards[12].levels[lvl-1]; } },
            { id: 'r14', name: 'Bloodlust', icon: 'ðŸ©¸', desc: 'Kills heal {val}% of max HP',
              levels: [5, 8, 12, 18, 25], effect: (lvl) => { playerStats.bloodlustHeal = rareCards[13].levels[lvl-1] / 100; } },
            { id: 'r15', name: 'Steady Hands', icon: 'ðŸ¤²', desc: '+{val}% damage for 2s after parrying',
              levels: [20, 35, 55, 80, 110], effect: (lvl) => { playerStats.parryDamageBoost = rareCards[14].levels[lvl-1] / 100; } },
            { id: 'r16', name: 'Iron Will', icon: 'ðŸ§ ', desc: 'Immune to knockback, +{val} armor',
              levels: [1, 2, 3, 5, 7], effect: (lvl) => { playerStats.ironWillArmor = rareCards[15].levels[lvl-1]; } },
            { id: 'r17', name: 'Hunter', icon: 'ðŸ¹', desc: '+{val}% damage to enemies far away',
              levels: [15, 28, 45, 65, 90], effect: (lvl) => { playerStats.hunterBonus = rareCards[16].levels[lvl-1] / 100; } },
            { id: 'r18', name: 'Predator', icon: 'ðŸº', desc: '+{val}% damage to isolated enemies',
              levels: [20, 35, 55, 80, 110], effect: (lvl) => { playerStats.predatorBonus = rareCards[17].levels[lvl-1] / 100; } },
            { id: 'r19', name: 'Projectile Shield', icon: 'ðŸ›¡ï¸', desc: '{val}% chance to deflect projectiles',
              levels: [15, 25, 40, 55, 75], effect: (lvl) => { playerStats.deflectChance = rareCards[18].levels[lvl-1] / 100; } },
            { id: 'r20', name: 'Counter Strike', icon: 'âš”ï¸', desc: 'Parrying triggers {val} damage counter',
              levels: [10, 20, 35, 55, 80], effect: (lvl) => { playerStats.counterDamage = rareCards[19].levels[lvl-1]; } },
            { id: 'r21', name: 'Relentless', icon: 'ðŸ”„', desc: '{val}% chance to reset attack cooldown',
              levels: [10, 18, 28, 40, 55], effect: (lvl) => { playerStats.resetChance = rareCards[20].levels[lvl-1] / 100; } },
            { id: 'r22', name: 'Armor Piercer', icon: 'ðŸ“Œ', desc: 'Ignore {val} enemy armor',
              levels: [1, 2, 3, 5, 8], effect: (lvl) => { playerStats.armorPierce = rareCards[21].levels[lvl-1]; } },
            { id: 'r23', name: 'Boss Hunter', icon: 'ðŸ‘¹', desc: '+{val}% damage to bosses',
              levels: [25, 45, 70, 100, 150], effect: (lvl) => { playerStats.bossHunter = rareCards[22].levels[lvl-1] / 100; } },
            { id: 'r24', name: 'Dodge Master', icon: 'ðŸ’¨', desc: '{val}% chance to dodge attacks',
              levels: [8, 15, 22, 32, 45], effect: (lvl) => { playerStats.dodgeChance = rareCards[23].levels[lvl-1] / 100; } },
            // Stamina rare cards
            { id: 'r25', name: 'Tireless', icon: 'ðŸƒ', desc: '+{val} Max Stamina',
              levels: [20, 35, 50, 70, 100], effect: (lvl) => { playerStats.maxStamina += rareCards[24].levels[lvl-1]; } },
            { id: 'r26', name: 'Rapid Recovery', icon: 'âš¡', desc: '+{val} Stamina Regen/sec',
              levels: [4, 7, 11, 16, 25], effect: (lvl) => { playerStats.staminaRegen += rareCards[25].levels[lvl-1]; } },
            { id: 'r27', name: 'Efficient Runner', icon: 'ðŸ¦µ', desc: '-{val} Stamina Drain',
              levels: [2, 3, 4, 5, 6], effect: (lvl) => { playerStats.staminaMoveDrain = Math.max(1, playerStats.staminaMoveDrain - rareCards[26].levels[lvl-1]); } },
            { id: 'r28', name: 'Nimble Dodger', icon: 'ðŸŒ€', desc: '-{val} Dodge Cost',
              levels: [5, 8, 12, 17, 22], effect: (lvl) => { playerStats.staminaDodgeCost = Math.max(3, playerStats.staminaDodgeCost - rareCards[27].levels[lvl-1]); } }
        ];

        // 12 Legendary cards - abilities with cooldowns
        const legendaryCards = [
            { id: 'l1', name: 'Dragon Rage', icon: 'ðŸ‰', desc: 'Unleash fire dealing {val} damage in a cone',
              cooldown: 15, levels: [50, 80, 120, 175, 250],
              activate: (lvl) => { dragonRageAttack(legendaryCards[0].levels[lvl-1]); } },
            { id: 'l2', name: 'Shadow Step', icon: 'ðŸ‘¤', desc: 'Teleport behind nearest enemy, +{val}% next hit',
              cooldown: 10, levels: [50, 80, 120, 170, 230],
              activate: (lvl) => { shadowStepAbility(legendaryCards[1].levels[lvl-1]); } },
            { id: 'l3', name: 'Battle Cry', icon: 'ðŸ“¢', desc: 'Stun nearby enemies for {val}s',
              cooldown: 20, levels: [1.5, 2, 2.5, 3.5, 5],
              activate: (lvl) => { battleCryAbility(legendaryCards[2].levels[lvl-1]); } },
            { id: 'l4', name: 'Blade Storm', icon: 'ðŸŒªï¸', desc: 'Spin attack hitting all nearby for {val} damage',
              cooldown: 12, levels: [30, 50, 75, 110, 160],
              activate: (lvl) => { bladeStormAbility(legendaryCards[3].levels[lvl-1]); } },
            { id: 'l5', name: 'Iron Fortress', icon: 'ðŸ¯', desc: 'Block all damage for {val}s',
              cooldown: 25, levels: [2, 2.5, 3, 4, 5],
              activate: (lvl) => { ironFortressAbility(legendaryCards[4].levels[lvl-1]); } },
            { id: 'l6', name: 'Phoenix Rise', icon: 'ðŸ”¥', desc: 'Revive with {val}% HP once per wave',
              cooldown: 60, levels: [25, 40, 55, 75, 100],
              activate: (lvl) => { /* Passive - checked on death */ } },
            { id: 'l7', name: 'Thunder Strike', icon: 'âš¡', desc: 'Lightning hits {val} enemies for 40 damage each',
              cooldown: 14, levels: [3, 5, 7, 10, 15],
              activate: (lvl) => { thunderStrikeAbility(legendaryCards[6].levels[lvl-1]); } },
            { id: 'l8', name: 'Healing Surge', icon: 'ðŸ’š', desc: 'Instantly heal {val}% of max HP',
              cooldown: 18, levels: [30, 45, 60, 80, 100],
              activate: (lvl) => { healingSurgeAbility(legendaryCards[7].levels[lvl-1]); } },
            { id: 'l9', name: 'Time Slow', icon: 'â±ï¸', desc: 'Slow enemies by 70% for {val}s',
              cooldown: 22, levels: [3, 4, 5, 7, 10],
              activate: (lvl) => { timeSlowAbility(legendaryCards[8].levels[lvl-1]); } },
            { id: 'l10', name: 'Summon Spirit', icon: 'ðŸ‘»', desc: 'Summon a spirit that fights for {val}s',
              cooldown: 30, levels: [8, 12, 18, 25, 35],
              activate: (lvl) => { summonSpiritAbility(legendaryCards[9].levels[lvl-1]); } },
            { id: 'l11', name: 'Blood Sacrifice', icon: 'ðŸ©¸', desc: 'Spend 20% HP to deal {val} damage to all',
              cooldown: 16, levels: [40, 65, 95, 140, 200],
              activate: (lvl) => { bloodSacrificeAbility(legendaryCards[10].levels[lvl-1]); } },
            { id: 'l12', name: 'Mirror Image', icon: 'ðŸªž', desc: 'Create {val} decoys that distract enemies',
              cooldown: 20, levels: [1, 2, 3, 4, 5],
              activate: (lvl) => { mirrorImageAbility(legendaryCards[11].levels[lvl-1]); } },
            { id: 'l13', name: 'Earthquake', icon: 'ðŸŒ‹', desc: 'Knock down all enemies, deal {val} damage',
              cooldown: 25, levels: [25, 45, 70, 100, 150],
              activate: (lvl) => { earthquakeAbility(legendaryCards[12].levels[lvl-1]); } },
            { id: 'l14', name: 'Wind Slash', icon: 'ðŸŒŠ', desc: 'Ranged blade wave deals {val} damage',
              cooldown: 8, levels: [30, 50, 75, 110, 160],
              activate: (lvl) => { windSlashAbility(legendaryCards[13].levels[lvl-1]); } },
            { id: 'l15', name: 'Soul Drain', icon: 'ðŸ’€', desc: 'Drain {val} HP from nearest enemy',
              cooldown: 12, levels: [25, 40, 60, 85, 120],
              activate: (lvl) => { soulDrainAbility(legendaryCards[14].levels[lvl-1]); } },
            { id: 'l16', name: 'Demon Form', icon: 'ðŸ‘¿', desc: '+{val}% damage and speed for 5s',
              cooldown: 30, levels: [30, 50, 75, 100, 150],
              activate: (lvl) => { demonFormAbility(legendaryCards[15].levels[lvl-1]); } }
        ];

        // Ability functions
        let timeSlowActive = false;
        let timeSlowMultiplier = 1;
        let ironFortressActive = false;
        let spiritMesh = null;
        let decoys = [];
        let shadowStepBonus = 0;
        let comboCount = 0;
        let lastHitTime = 0;
        let phoenixUsedThisWave = false;

        function dragonRageAttack(damage) {
            // Create fire cone visual
            for (let i = 0; i < 10; i++) {
                const angle = cameraRotationY + (Math.random() - 0.5) * (Math.PI / 3);
                const dist = 2 + Math.random() * 6;
                const fx = player.position.x - Math.sin(angle) * dist;
                const fz = player.position.z - Math.cos(angle) * dist;
                createFireEffect(fx, 1 + Math.random(), fz);
            }

            // Deal damage in a cone in front of player
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dx = enemy.mesh.position.x - player.position.x;
                const dz = enemy.mesh.position.z - player.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);

                if (distance <= 8) {
                    const angleToEnemy = Math.atan2(-dx, -dz);
                    let angleDiff = angleToEnemy - cameraRotationY;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                    if (Math.abs(angleDiff) <= Math.PI / 3) {
                        dealDamageToEnemy(i, damage);
                    }
                }
            }
            showAbilityEffect('ðŸ”¥ Dragon Rage!');
        }

        function shadowStepAbility(bonus) {
            // Find nearest enemy and teleport behind them
            let nearestDist = Infinity;
            let nearestEnemy = null;
            for (const enemy of enemies) {
                const dx = enemy.mesh.position.x - player.position.x;
                const dz = enemy.mesh.position.z - player.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearestEnemy = enemy;
                }
            }
            if (nearestEnemy && nearestDist < 20) {
                const angle = nearestEnemy.mesh.rotation.y;
                player.position.x = nearestEnemy.mesh.position.x + Math.sin(angle) * 2;
                player.position.z = nearestEnemy.mesh.position.z + Math.cos(angle) * 2;
                cameraRotationY = angle + Math.PI; // Face the enemy
                shadowStepBonus = bonus / 100;
                setTimeout(() => { shadowStepBonus = 0; }, 3000);
            }
            showAbilityEffect('ðŸ‘¤ Shadow Step!');
        }

        function battleCryAbility(duration) {
            for (const enemy of enemies) {
                enemy.stunned = true;
                enemy.stunDuration = duration;
            }
            showAbilityEffect('ðŸ“¢ Battle Cry!');
        }

        function bladeStormAbility(damage) {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dx = enemy.mesh.position.x - player.position.x;
                const dz = enemy.mesh.position.z - player.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                if (distance <= 6) {
                    dealDamageToEnemy(i, damage);
                }
            }
            showAbilityEffect('ðŸŒªï¸ Blade Storm!');
        }

        function ironFortressAbility(duration) {
            ironFortressActive = true;
            setTimeout(() => { ironFortressActive = false; }, duration * 1000);
            showAbilityEffect('ðŸ¯ Iron Fortress!');
        }

        function thunderStrikeAbility(targets) {
            let hit = 0;
            for (let i = enemies.length - 1; i >= 0 && hit < targets; i--) {
                dealDamageToEnemy(i, 40);
                hit++;
            }
            showAbilityEffect('âš¡ Thunder Strike!');
        }

        function healingSurgeAbility(percent) {
            playerHealth = Math.min(playerStats.maxHealth, playerHealth + playerStats.maxHealth * (percent / 100));
            updatePlayerHealth();
            showAbilityEffect('ðŸ’š Healing Surge!');
        }

        function timeSlowAbility(duration) {
            timeSlowActive = true;
            timeSlowMultiplier = 0.3;
            setTimeout(() => {
                timeSlowActive = false;
                timeSlowMultiplier = 1;
            }, duration * 1000);
            showAbilityEffect('â±ï¸ Time Slow!');
        }

        function summonSpiritAbility(duration) {
            // Create a spirit ally
            if (spiritMesh) scene.remove(spiritMesh);
            const spiritGeo = new THREE.BoxGeometry(0.6, 1.5, 0.4);
            const spiritMat = new THREE.MeshStandardMaterial({ color: 0x8888ff, transparent: true, opacity: 0.6 });
            spiritMesh = new THREE.Mesh(spiritGeo, spiritMat);
            spiritMesh.position.copy(player.position);
            spiritMesh.position.x += 2;
            scene.add(spiritMesh);
            spiritMesh.isSpirit = true;
            spiritMesh.attackTimer = 0;
            setTimeout(() => {
                if (spiritMesh) {
                    scene.remove(spiritMesh);
                    spiritMesh = null;
                }
            }, duration * 1000);
            showAbilityEffect('ðŸ‘» Spirit Summoned!');
        }

        function bloodSacrificeAbility(damage) {
            playerHealth -= playerStats.maxHealth * 0.2;
            if (playerHealth < 1) playerHealth = 1;
            updatePlayerHealth();
            for (let i = enemies.length - 1; i >= 0; i--) {
                dealDamageToEnemy(i, damage);
            }
            showAbilityEffect('ðŸ©¸ Blood Sacrifice!');
        }

        function mirrorImageAbility(count) {
            // Remove old decoys
            for (const decoy of decoys) scene.remove(decoy);
            decoys = [];

            for (let i = 0; i < count; i++) {
                const decoyGeo = new THREE.BoxGeometry(0.8, 1.8, 0.5);
                const decoyMat = new THREE.MeshStandardMaterial({ color: 0x8B0000, transparent: true, opacity: 0.5 });
                const decoy = new THREE.Mesh(decoyGeo, decoyMat);
                const angle = (Math.PI * 2 / count) * i;
                decoy.position.set(
                    player.position.x + Math.cos(angle) * 3,
                    player.position.y + 0.9,
                    player.position.z + Math.sin(angle) * 3
                );
                scene.add(decoy);
                decoys.push(decoy);
            }
            setTimeout(() => {
                for (const decoy of decoys) scene.remove(decoy);
                decoys = [];
            }, 8000);
            showAbilityEffect('ðŸªž Mirror Image!');
        }

        function earthquakeAbility(damage) {
            // Create visual shockwave
            createShockwaveEffect(player.position.x, player.position.z, 0x8B4513);
            // Damage and knock down all enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dx = enemy.mesh.position.x - player.position.x;
                const dz = enemy.mesh.position.z - player.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                if (dist < 12) {
                    dealDamageToEnemy(i, damage);
                    enemy.stunned = true;
                    enemy.stunDuration = 1.5;
                }
            }
            showAbilityEffect('ðŸŒ‹ Earthquake!');
        }

        function windSlashAbility(damage) {
            // Create projectile effect
            const slashGeo = new THREE.BoxGeometry(0.1, 0.8, 2);
            const slashMat = new THREE.MeshBasicMaterial({ color: 0x88ccff, transparent: true, opacity: 0.7 });
            const slash = new THREE.Mesh(slashGeo, slashMat);
            slash.position.copy(player.position);
            slash.position.y = 1.2;
            slash.rotation.y = cameraRotationY;
            scene.add(slash);

            const dir = new THREE.Vector3(-Math.sin(cameraRotationY), 0, -Math.cos(cameraRotationY));
            const projectile = { mesh: slash, dir: dir, damage: damage, life: 2 };
            visualProjectiles.push(projectile);
            showAbilityEffect('ðŸŒŠ Wind Slash!');
        }

        function soulDrainAbility(amount) {
            // Find nearest enemy
            let nearestDist = Infinity;
            let nearestIdx = -1;
            for (let i = 0; i < enemies.length; i++) {
                const enemy = enemies[i];
                const dx = enemy.mesh.position.x - player.position.x;
                const dz = enemy.mesh.position.z - player.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                if (dist < nearestDist && dist < 15) {
                    nearestDist = dist;
                    nearestIdx = i;
                }
            }
            if (nearestIdx >= 0) {
                dealDamageToEnemy(nearestIdx, amount);
                playerHealth = Math.min(playerStats.maxHealth, playerHealth + amount);
                updatePlayerHealth();
                // Visual drain effect
                createDrainEffect(enemies[nearestIdx]?.mesh?.position || player.position);
            }
            showAbilityEffect('ðŸ’€ Soul Drain!');
        }

        let demonFormActive = false;
        function demonFormAbility(bonus) {
            demonFormActive = true;
            const bonusMult = bonus / 100;
            playerStats.damage *= (1 + bonusMult);
            playerStats.moveSpeed *= (1 + bonusMult);
            // Visual effect - red tint
            scene.fog = new THREE.Fog(0xff0000, 50, 100);
            setTimeout(() => {
                demonFormActive = false;
                playerStats.damage /= (1 + bonusMult);
                playerStats.moveSpeed /= (1 + bonusMult);
                scene.fog = null;
            }, 5000);
            showAbilityEffect('ðŸ‘¿ Demon Form!');
        }

        // Visual effects arrays
        const visualProjectiles = [];
        const visualEffects = [];
        const gibs = []; // Body part gibs

        function createShockwaveEffect(x, z, color) {
            const ringGeo = new THREE.RingGeometry(0.5, 1, 32);
            const ringMat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.8, side: THREE.DoubleSide });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.position.set(x, 0.1, z);
            ring.rotation.x = -Math.PI / 2;
            scene.add(ring);
            visualEffects.push({ mesh: ring, type: 'shockwave', scale: 1, life: 1 });
        }

        function createDrainEffect(targetPos) {
            for (let i = 0; i < 5; i++) {
                const particleGeo = new THREE.SphereGeometry(0.1);
                const particleMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                const particle = new THREE.Mesh(particleGeo, particleMat);
                particle.position.copy(targetPos);
                scene.add(particle);
                visualEffects.push({ mesh: particle, type: 'drain', target: player.position.clone(), life: 1 });
            }
        }

        function createFireEffect(x, y, z) {
            const fireGeo = new THREE.SphereGeometry(0.3);
            const fireMat = new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.8 });
            const fire = new THREE.Mesh(fireGeo, fireMat);
            fire.position.set(x, y, z);
            scene.add(fire);
            visualEffects.push({ mesh: fire, type: 'fire', life: 0.5 });
        }

        function createHitEffect(x, y, z, color) {
            // Create a burst of particles at hit location
            const burstGeo = new THREE.SphereGeometry(0.4);
            const burstMat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.9 });
            const burst = new THREE.Mesh(burstGeo, burstMat);
            burst.position.set(x, y, z);
            scene.add(burst);
            visualEffects.push({ mesh: burst, type: 'hit', life: 0.3 });

            // Add smaller particles
            for (let i = 0; i < 4; i++) {
                const particleGeo = new THREE.SphereGeometry(0.15);
                const particleMat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.8 });
                const particle = new THREE.Mesh(particleGeo, particleMat);
                particle.position.set(x, y, z);
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 4,
                    Math.random() * 3,
                    (Math.random() - 0.5) * 4
                );
                scene.add(particle);
                visualEffects.push({ mesh: particle, type: 'hitParticle', life: 0.4 });
            }
        }

        // ========== EPIC BOSS VISUAL EFFECTS ==========
        let screenShakeIntensity = 0;
        let screenShakeDuration = 0;
        const originalCameraOffset = new THREE.Vector3();

        function screenShake(intensity, duration) {
            screenShakeIntensity = intensity;
            screenShakeDuration = duration;
        }

        function updateScreenShake(deltaTime) {
            if (screenShakeDuration > 0) {
                screenShakeDuration -= deltaTime;
                const shake = screenShakeIntensity * (screenShakeDuration > 0 ? 1 : 0);
                camera.position.x += (Math.random() - 0.5) * shake;
                camera.position.y += (Math.random() - 0.5) * shake * 0.5;
                camera.position.z += (Math.random() - 0.5) * shake;
            }
        }

        function createGroundCrack(x, z, size, color = 0x333333) {
            const crackGroup = new THREE.Group();
            const crackCount = 5 + Math.floor(Math.random() * 5);

            for (let i = 0; i < crackCount; i++) {
                const angle = (i / crackCount) * Math.PI * 2 + Math.random() * 0.5;
                const length = size * (0.5 + Math.random() * 0.5);
                const crackGeo = new THREE.BoxGeometry(0.15, 0.05, length);
                const crackMat = new THREE.MeshBasicMaterial({ color: color });
                const crack = new THREE.Mesh(crackGeo, crackMat);
                crack.position.set(Math.cos(angle) * length / 2, 0.02, Math.sin(angle) * length / 2);
                crack.rotation.y = angle;
                crackGroup.add(crack);
            }
            crackGroup.position.set(x, 0, z);
            scene.add(crackGroup);

            // Fade out and remove
            setTimeout(() => {
                let opacity = 1;
                const fadeInterval = setInterval(() => {
                    opacity -= 0.05;
                    crackGroup.children.forEach(c => { if (c.material) c.material.opacity = opacity; c.material.transparent = true; });
                    if (opacity <= 0) {
                        scene.remove(crackGroup);
                        clearInterval(fadeInterval);
                    }
                }, 50);
            }, 2000);
        }

        function createEpicExplosion(x, y, z, color, size = 3, particleCount = 30) {
            // Central flash
            const flashGeo = new THREE.SphereGeometry(size * 0.8);
            const flashMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 1 });
            const flash = new THREE.Mesh(flashGeo, flashMat);
            flash.position.set(x, y, z);
            scene.add(flash);

            // Flash expands and fades
            let flashScale = 1;
            const flashInterval = setInterval(() => {
                flashScale += 0.4;
                flash.scale.set(flashScale, flashScale, flashScale);
                flash.material.opacity -= 0.15;
                if (flash.material.opacity <= 0) {
                    scene.remove(flash);
                    clearInterval(flashInterval);
                }
            }, 30);

            // Debris particles flying outward
            for (let i = 0; i < particleCount; i++) {
                const pSize = 0.1 + Math.random() * 0.3;
                const pGeo = new THREE.BoxGeometry(pSize, pSize, pSize);
                const pMat = new THREE.MeshBasicMaterial({
                    color: Math.random() > 0.5 ? color : (Math.random() > 0.5 ? 0xffffff : 0x222222)
                });
                const particle = new THREE.Mesh(pGeo, pMat);
                particle.position.set(x, y, z);

                const speed = 5 + Math.random() * 10;
                const angle = Math.random() * Math.PI * 2;
                const upSpeed = 3 + Math.random() * 8;
                const vel = {
                    x: Math.cos(angle) * speed,
                    y: upSpeed,
                    z: Math.sin(angle) * speed
                };

                scene.add(particle);

                let life = 0;
                const moveInterval = setInterval(() => {
                    life += 0.03;
                    vel.y -= 0.5; // gravity
                    particle.position.x += vel.x * 0.03;
                    particle.position.y += vel.y * 0.03;
                    particle.position.z += vel.z * 0.03;
                    particle.rotation.x += 0.2;
                    particle.rotation.z += 0.15;

                    if (particle.position.y < 0 || life > 2) {
                        scene.remove(particle);
                        clearInterval(moveInterval);
                    }
                }, 30);
            }

            // Shockwave rings
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const ringGeo = new THREE.RingGeometry(0.5, 1.5, 32);
                    const ringMat = new THREE.MeshBasicMaterial({
                        color: color, transparent: true, opacity: 0.8, side: THREE.DoubleSide
                    });
                    const ring = new THREE.Mesh(ringGeo, ringMat);
                    ring.position.set(x, 0.1, z);
                    ring.rotation.x = -Math.PI / 2;
                    scene.add(ring);

                    let scale = 1;
                    const expandInterval = setInterval(() => {
                        scale += 0.8;
                        ring.scale.set(scale, scale, 1);
                        ring.material.opacity -= 0.06;
                        if (ring.material.opacity <= 0) {
                            scene.remove(ring);
                            clearInterval(expandInterval);
                        }
                    }, 30);
                }, i * 100);
            }
        }

        function createLightningBolt(startX, startY, startZ, endX, endY, endZ, color = 0x88ccff) {
            const boltGroup = new THREE.Group();
            const segments = 8;
            let prevPoint = new THREE.Vector3(startX, startY, startZ);

            for (let i = 1; i <= segments; i++) {
                const t = i / segments;
                const targetPoint = new THREE.Vector3(
                    startX + (endX - startX) * t + (i < segments ? (Math.random() - 0.5) * 2 : 0),
                    startY + (endY - startY) * t + (i < segments ? (Math.random() - 0.5) * 2 : 0),
                    startZ + (endZ - startZ) * t + (i < segments ? (Math.random() - 0.5) * 2 : 0)
                );

                const segLength = prevPoint.distanceTo(targetPoint);
                const segGeo = new THREE.CylinderGeometry(0.08, 0.08, segLength, 6);
                const segMat = new THREE.MeshBasicMaterial({ color: color });
                const seg = new THREE.Mesh(segGeo, segMat);

                seg.position.copy(prevPoint).add(targetPoint).multiplyScalar(0.5);
                seg.lookAt(targetPoint);
                seg.rotateX(Math.PI / 2);

                boltGroup.add(seg);

                // Glow sphere at joints
                const glowGeo = new THREE.SphereGeometry(0.15);
                const glowMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                glow.position.copy(targetPoint);
                boltGroup.add(glow);

                prevPoint = targetPoint.clone();
            }

            scene.add(boltGroup);

            // Flash and fade
            let flicker = 0;
            const flickerInterval = setInterval(() => {
                flicker++;
                boltGroup.visible = flicker % 2 === 0;
                if (flicker > 6) {
                    scene.remove(boltGroup);
                    clearInterval(flickerInterval);
                }
            }, 50);
        }

        function createBossChargeUp(enemy, color, duration, onComplete) {
            const startScale = enemy.mesh.scale.clone();
            let chargeTime = 0;

            // Swirling particles around boss
            const particles = [];
            for (let i = 0; i < 20; i++) {
                const pGeo = new THREE.SphereGeometry(0.15);
                const pMat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.8 });
                const p = new THREE.Mesh(pGeo, pMat);
                const angle = (i / 20) * Math.PI * 2;
                const radius = 3 + Math.random();
                p.userData = { angle, radius, speed: 2 + Math.random() * 2, height: Math.random() * 3 };
                scene.add(p);
                particles.push(p);
            }

            // Glow aura
            const auraGeo = new THREE.SphereGeometry(2.5);
            const auraMat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.3, side: THREE.BackSide });
            const aura = new THREE.Mesh(auraGeo, auraMat);
            enemy.mesh.add(aura);

            const chargeInterval = setInterval(() => {
                chargeTime += 0.03;
                const progress = chargeTime / duration;

                // Pulse boss scale
                const pulse = 1 + Math.sin(chargeTime * 15) * 0.05 * progress;
                enemy.mesh.scale.set(startScale.x * pulse, startScale.y * pulse, startScale.z * pulse);

                // Update swirling particles - converge toward boss
                particles.forEach(p => {
                    p.userData.angle += p.userData.speed * 0.03;
                    const currentRadius = p.userData.radius * (1 - progress * 0.7);
                    p.position.set(
                        enemy.mesh.position.x + Math.cos(p.userData.angle) * currentRadius,
                        enemy.mesh.position.y + p.userData.height * (1 - progress),
                        enemy.mesh.position.z + Math.sin(p.userData.angle) * currentRadius
                    );
                });

                // Grow aura
                aura.scale.set(1 + progress, 1 + progress, 1 + progress);
                auraMat.opacity = 0.3 + progress * 0.4;

                // Boss glows
                enemy.mesh.children.forEach(child => {
                    if (child.material && child.material.emissive && child !== aura) {
                        child.material.emissive.setHex(color);
                        child.material.emissiveIntensity = progress * 0.8;
                    }
                });

                if (chargeTime >= duration) {
                    clearInterval(chargeInterval);
                    enemy.mesh.scale.copy(startScale);
                    particles.forEach(p => scene.remove(p));
                    enemy.mesh.remove(aura);

                    // Reset emissive
                    enemy.mesh.children.forEach(child => {
                        if (child.material && child.material.emissive) {
                            child.material.emissiveIntensity = 0;
                        }
                    });

                    if (onComplete) onComplete();
                }
            }, 30);
        }

        function createDustCloud(x, z, radius, particleCount = 15) {
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * radius;
                const pGeo = new THREE.SphereGeometry(0.2 + Math.random() * 0.3);
                const pMat = new THREE.MeshBasicMaterial({
                    color: 0x8b7355, transparent: true, opacity: 0.6
                });
                const p = new THREE.Mesh(pGeo, pMat);
                p.position.set(x + Math.cos(angle) * dist, 0.2, z + Math.sin(angle) * dist);
                scene.add(p);

                const riseSpeed = 1 + Math.random() * 2;
                const spreadSpeed = 0.5 + Math.random();
                let life = 0;
                const dustInterval = setInterval(() => {
                    life += 0.03;
                    p.position.y += riseSpeed * 0.03;
                    p.position.x += Math.cos(angle) * spreadSpeed * 0.03;
                    p.position.z += Math.sin(angle) * spreadSpeed * 0.03;
                    p.material.opacity -= 0.02;
                    p.scale.multiplyScalar(1.02);

                    if (p.material.opacity <= 0) {
                        scene.remove(p);
                        clearInterval(dustInterval);
                    }
                }, 30);
            }
        }

        function createEnergyBeam(startX, startY, startZ, endX, endY, endZ, color, width = 0.5, duration = 0.5) {
            const length = Math.sqrt(
                Math.pow(endX - startX, 2) +
                Math.pow(endY - startY, 2) +
                Math.pow(endZ - startZ, 2)
            );

            const beamGeo = new THREE.CylinderGeometry(width, width, length, 8);
            const beamMat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.9 });
            const beam = new THREE.Mesh(beamGeo, beamMat);

            // Inner bright core
            const coreGeo = new THREE.CylinderGeometry(width * 0.4, width * 0.4, length, 8);
            const coreMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const core = new THREE.Mesh(coreGeo, coreMat);
            beam.add(core);

            beam.position.set((startX + endX) / 2, (startY + endY) / 2, (startZ + endZ) / 2);
            beam.lookAt(endX, endY, endZ);
            beam.rotateX(Math.PI / 2);
            scene.add(beam);

            // Pulse effect
            let time = 0;
            const beamInterval = setInterval(() => {
                time += 0.03;
                const pulse = 1 + Math.sin(time * 20) * 0.2;
                beam.scale.set(pulse, 1, pulse);

                if (time >= duration) {
                    beam.material.opacity -= 0.1;
                    if (beam.material.opacity <= 0) {
                        scene.remove(beam);
                        clearInterval(beamInterval);
                    }
                }
            }, 30);
        }

        function createBossRoarEffect(enemy, color) {
            // Expanding rings from mouth area
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const ringGeo = new THREE.TorusGeometry(0.5, 0.1, 8, 24);
                    const ringMat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.8 });
                    const ring = new THREE.Mesh(ringGeo, ringMat);
                    ring.position.copy(enemy.mesh.position);
                    ring.position.y = 2;
                    ring.lookAt(player.position);
                    scene.add(ring);

                    let scale = 1;
                    const expandInterval = setInterval(() => {
                        scale += 0.4;
                        ring.scale.set(scale, scale, scale);
                        ring.material.opacity -= 0.05;
                        ring.position.x += (player.position.x - enemy.mesh.position.x) * 0.02;
                        ring.position.z += (player.position.z - enemy.mesh.position.z) * 0.02;

                        if (ring.material.opacity <= 0) {
                            scene.remove(ring);
                            clearInterval(expandInterval);
                        }
                    }, 30);
                }, i * 100);
            }

            // Screen shake
            screenShake(0.3, 0.5);
        }

        function createSlamEffect(x, z, size, color) {
            // Ground crack
            createGroundCrack(x, z, size, color);

            // Dust cloud
            createDustCloud(x, z, size);

            // Shockwave
            createShockwaveEffect(x, z, color);

            // Screen shake
            screenShake(0.5, 0.3);

            // Debris launching up
            for (let i = 0; i < 10; i++) {
                const debrisGeo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                const debrisMat = new THREE.MeshBasicMaterial({ color: 0x666666 });
                const debris = new THREE.Mesh(debrisGeo, debrisMat);
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * size * 0.5;
                debris.position.set(x + Math.cos(angle) * dist, 0, z + Math.sin(angle) * dist);
                scene.add(debris);

                let vy = 5 + Math.random() * 5;
                const debrisInterval = setInterval(() => {
                    vy -= 0.5;
                    debris.position.y += vy * 0.03;
                    debris.rotation.x += 0.2;
                    debris.rotation.z += 0.15;

                    if (debris.position.y < 0) {
                        scene.remove(debris);
                        clearInterval(debrisInterval);
                    }
                }, 30);
            }
        }

        function dealDamageToEnemy(index, damage) {
            if (index < 0 || index >= enemies.length) return;
            const enemy = enemies[index];

            // Armor pierce
            const pierce = playerStats.armorPierce || 0;
            const effectiveArmor = Math.max(0, enemy.armor - pierce);

            // Boss damage bonus
            let finalDamage = damage;
            if (enemy.isBoss && (playerStats.bossDamage || playerStats.bossHunter)) {
                const bossBonus = (playerStats.bossDamage || 0) + (playerStats.bossHunter || 0);
                finalDamage *= (1 + bossBonus);
            }

            // Demon Horn relic - +50% damage when below 30% HP
            if (hasRelic('abyss') && playerHealth < playerStats.maxHealth * 0.3) {
                finalDamage *= 1.5;
                // Ignite effect
                if (!enemy.isIgnited) {
                    enemy.isIgnited = true;
                    enemy.igniteTimer = 3;
                    enemy.igniteDamage = 5;
                }
            }

            // Warrior's Medallion - kill streak damage boost
            if (hasRelic('warrior') && killStreakStacks > 0) {
                finalDamage *= (1 + killStreakStacks * 0.05); // +5% per stack
            }

            // Shadow Blade - first hit on enemy deals double damage
            if (hasRelic('assassin') && enemy.id && !enemiesFirstHit.has(enemy.id)) {
                enemiesFirstHit.add(enemy.id);
                finalDamage *= 2;
                createHitEffect(enemy.mesh.position.x, 1.5, enemy.mesh.position.z, 0x8800ff);
            }

            // Dragon Scale - bonus fire damage
            if (hasRelic('dragonscale')) {
                finalDamage *= 1.15; // 15% bonus fire damage
                if (!enemy.isIgnited && Math.random() < 0.3) {
                    enemy.isIgnited = true;
                    enemy.igniteTimer = 2;
                    enemy.igniteDamage = 4;
                }
            }

            // Crystal Eye relic - double crit damage
            if (hasRelic('crystal') && damage > playerStats.damage * 20) { // Likely a crit
                finalDamage *= 1.5; // Extra 50% on crits
            }

            const actualDamage = applyDamageVariance(Math.max(1, finalDamage - effectiveArmor));
            enemy.health -= actualDamage;
            trackQuestDamage(actualDamage);

            // Blood Chalice - 8% lifesteal
            if (hasRelic('vampire')) {
                const healAmount = actualDamage * 0.08;
                playerHealth = Math.min(playerStats.maxHealth, playerHealth + healAmount);
                updatePlayerHealth();
            }

            // Titan's Might - knockback and stun
            if (hasRelic('titan') && enemy.mesh && !enemy.isBoss) {
                const knockDir = new THREE.Vector3(
                    enemy.mesh.position.x - player.position.x,
                    0,
                    enemy.mesh.position.z - player.position.z
                ).normalize();
                enemy.mesh.position.x += knockDir.x * 3;
                enemy.mesh.position.z += knockDir.z * 3;
                enemy.stunned = true;
                enemy.stunDuration = 0.3;
            }

            // Permafrost Shard relic - 20% freeze chance
            if (hasRelic('frost') && !enemy.isBoss && Math.random() < 0.2) {
                if (!enemy.isFrozen) {
                    enemy.isFrozen = true;
                    enemy.frozenTimer = 1.5;
                    // Visual freeze effect
                    enemy.mesh.children.forEach(child => {
                        if (child.material) child.material.color.setHex(0x88ddff);
                    });
                    createHitEffect(enemy.mesh.position.x, 1.5, enemy.mesh.position.z, 0x88ddff);
                }
            }

            // Plague Amulet relic - poison on hit
            if (hasRelic('swamp') && !enemy.isPoisoned) {
                enemy.isPoisoned = true;
                enemy.poisonTimer = 4;
                enemy.poisonDamage = 3;
            }

            // Flash enemy
            enemy.mesh.children.forEach(child => {
                if (child.material && child.material.emissive) {
                    child.material.emissive.setHex(0xff0000);
                    setTimeout(() => { child.material.emissive.setHex(0x000000); }, 100);
                }
            });

            if (enemy.health <= 0) {
                // Create death gibs
                createGibs(enemy);
                scene.remove(enemy.mesh);
                enemies.splice(index, 1);
                onEnemyKilled(enemy);
                updateEnemyCount();
            }
        }

        let momentumActive = false;
        let momentumSpeedBonus = 0;

        function onEnemyKilled(enemy) {
            // Track quest kill
            trackQuestKill(currentRunCharacter);

            // Grant character XP based on enemy type
            let xpGain = 5; // Base XP for normal enemies
            if (enemy && enemy.isBoss) xpGain = 50; // Bosses give way more XP
            else if (enemy && enemy.isElite) xpGain = 15; // Elite enemies
            else if (enemy && enemy.health > 50) xpGain = 10; // Tanky enemies
            addCharXP(currentRunCharacter, xpGain);

            // RELIC EFFECTS ON KILL

            // Heart of the Grove - 15% chance to drop healing orb
            if (hasRelic('forest') && Math.random() < 0.15 && enemy && enemy.mesh) {
                createHealingOrb(enemy.mesh.position.x, enemy.mesh.position.z);
            }

            // Volcanic Core - enemies explode on death
            if (hasRelic('volcano') && enemy && enemy.mesh && !enemy.isBoss) {
                const explosionDamage = 15;
                const explosionRadius = 4;
                createFireEffect(enemy.mesh.position.x, 1, enemy.mesh.position.z);
                // Damage nearby enemies
                enemies.forEach((other, idx) => {
                    if (other !== enemy && other.mesh) {
                        const dx = other.mesh.position.x - enemy.mesh.position.x;
                        const dz = other.mesh.position.z - enemy.mesh.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        if (dist < explosionRadius) {
                            other.health -= explosionDamage;
                            createDamageNumber(other.mesh.position.x, other.mesh.position.y + 2, other.mesh.position.z, explosionDamage, false);
                        }
                    }
                });
            }

            // Spectral Lantern - 12% chance for ghost ally
            if (hasRelic('graveyard') && Math.random() < 0.12 && enemy && enemy.mesh && !enemy.isBoss) {
                createGhostAlly(enemy.mesh.position.x, enemy.mesh.position.z);
            }

            // Warrior's Medallion - kill streak damage boost
            if (hasRelic('warrior')) {
                killStreakStacks = Math.min(killStreakStacks + 1, 10); // Max 10 stacks = 50%
                killStreakTimer = 5;
            }

            // Hunter's Mark - speed boost on kill
            if (hasRelic('hunter')) {
                hunterSpeedTimer = 3;
            }

            // Storm Rune - chain lightning on kill
            if (hasRelic('thunder') && enemy && enemy.mesh) {
                let chainsLeft = 2;
                const chainDamage = playerStats.damage * 0.5;
                enemies.forEach(other => {
                    if (chainsLeft > 0 && other !== enemy && other.mesh) {
                        const dx = other.mesh.position.x - enemy.mesh.position.x;
                        const dz = other.mesh.position.z - enemy.mesh.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        if (dist < 6) {
                            other.health -= chainDamage;
                            createDamageNumber(other.mesh.position.x, other.mesh.position.y + 2, other.mesh.position.z, Math.floor(chainDamage), false);
                            createHitEffect(other.mesh.position.x, 1.5, other.mesh.position.z, 0xffff00);
                            chainsLeft--;
                        }
                    }
                });
            }

            // Soul Eater bonus
            if (playerStats.soulEaterBonus) {
                playerStats.maxHealth += playerStats.soulEaterBonus;
            }
            // Bloodlust heal
            if (playerStats.bloodlustHeal) {
                playerHealth = Math.min(playerStats.maxHealth, playerHealth + playerStats.maxHealth * playerStats.bloodlustHeal);
                updatePlayerHealth();
            }
            // Momentum speed bonus
            if (playerStats.momentumBonus) {
                momentumActive = true;
                momentumSpeedBonus = playerStats.momentumBonus;
                setTimeout(() => {
                    momentumActive = false;
                    momentumSpeedBonus = 0;
                }, 3000);
            }

            // Boss kill announcement
            if (enemy && enemy.isBoss) {
                showAbilityEffect(`${enemy.name} DEFEATED!`);
                // Track dragon kill for quest
                if (enemy.type === 'dragon') {
                    questProgress.current = 1;
                    updateQuestProgress();
                }
            }

            // Check wave completion
            if (enemies.length === 0 && waveInProgress && !waveStartDelay) {
                waveInProgress = false;
                phoenixUsedThisWave = false;
                deathSaveUsedThisWave = false;
                trackQuestWaveComplete(currentWave);
                setTimeout(() => showCardSelection(), 1500);
            }
        }

        function showAbilityEffect(text) {
            waveAnnouncementEl.textContent = text;
            waveAnnouncementEl.style.color = '#ffaa00';
            waveAnnouncementEl.style.opacity = '1';
            setTimeout(() => { waveAnnouncementEl.style.opacity = '0'; }, 1000);
        }

        // ========== RELIC EFFECT HELPERS ==========
        const healingOrbs = [];

        function createHealingOrb(x, z) {
            const geo = new THREE.SphereGeometry(0.4, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color: 0x44ff44, transparent: true, opacity: 0.8 });
            const orb = new THREE.Mesh(geo, mat);
            orb.position.set(x, 1, z);
            scene.add(orb);

            // Add glow
            const glowGeo = new THREE.SphereGeometry(0.6, 8, 8);
            const glowMat = new THREE.MeshBasicMaterial({ color: 0x88ff88, transparent: true, opacity: 0.3 });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            orb.add(glow);

            healingOrbs.push({ mesh: orb, life: 10 }); // 10 seconds to collect
        }

        function updateHealingOrbs(deltaTime) {
            for (let i = healingOrbs.length - 1; i >= 0; i--) {
                const orb = healingOrbs[i];
                orb.life -= deltaTime;
                orb.mesh.position.y = 1 + Math.sin(performance.now() / 300) * 0.2; // Bob
                orb.mesh.rotation.y += deltaTime * 2;

                // Check player pickup
                const dx = player.position.x - orb.mesh.position.x;
                const dz = player.position.z - orb.mesh.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                if (dist < 2) {
                    // Heal player
                    const healAmount = 15;
                    playerHealth = Math.min(playerStats.maxHealth, playerHealth + healAmount);
                    updatePlayerHealth();
                    showXPPopup(`+${healAmount} HP`, orb.mesh.position.x, orb.mesh.position.z);
                    scene.remove(orb.mesh);
                    healingOrbs.splice(i, 1);
                    continue;
                }

                if (orb.life <= 0) {
                    scene.remove(orb.mesh);
                    healingOrbs.splice(i, 1);
                }
            }
        }

        function createGhostAlly(x, z) {
            const geo = new THREE.ConeGeometry(0.4, 1.2, 6);
            const mat = new THREE.MeshBasicMaterial({ color: 0x88ffaa, transparent: true, opacity: 0.6 });
            const ghost = new THREE.Mesh(geo, mat);
            ghost.position.set(x, 1.5, z);
            ghost.rotation.x = Math.PI; // Point down
            scene.add(ghost);

            // Add eyes
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const eyeGeo = new THREE.SphereGeometry(0.1, 6, 6);
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(-0.15, -0.3, 0.25);
            ghost.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(0.15, -0.3, 0.25);
            ghost.add(rightEye);

            ghostAllies.push({
                mesh: ghost,
                life: 8, // 8 seconds
                attackCooldown: 0,
                damage: 10
            });
        }

        function updateGhostAllies(deltaTime) {
            for (let i = ghostAllies.length - 1; i >= 0; i--) {
                const ghost = ghostAllies[i];
                ghost.life -= deltaTime;
                ghost.attackCooldown -= deltaTime;

                // Float animation
                ghost.mesh.position.y = 1.5 + Math.sin(performance.now() / 200) * 0.3;
                ghost.mesh.rotation.y += deltaTime;

                // Find nearest enemy and attack
                let nearestEnemy = null;
                let nearestDist = 8; // Attack range
                enemies.forEach(enemy => {
                    if (!enemy.mesh) return;
                    const dx = enemy.mesh.position.x - ghost.mesh.position.x;
                    const dz = enemy.mesh.position.z - ghost.mesh.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestEnemy = enemy;
                    }
                });

                if (nearestEnemy) {
                    // Move towards enemy
                    const dx = nearestEnemy.mesh.position.x - ghost.mesh.position.x;
                    const dz = nearestEnemy.mesh.position.z - ghost.mesh.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    ghost.mesh.position.x += (dx / dist) * 5 * deltaTime;
                    ghost.mesh.position.z += (dz / dist) * 5 * deltaTime;

                    // Attack if close and ready
                    if (dist < 2 && ghost.attackCooldown <= 0) {
                        nearestEnemy.health -= ghost.damage;
                        createDamageNumber(nearestEnemy.mesh.position.x, nearestEnemy.mesh.position.y + 2, nearestEnemy.mesh.position.z, ghost.damage, false);
                        createHitEffect(nearestEnemy.mesh.position.x, 1.5, nearestEnemy.mesh.position.z, 0x88ffaa);
                        ghost.attackCooldown = 1;
                    }
                }

                if (ghost.life <= 0) {
                    scene.remove(ghost.mesh);
                    ghostAllies.splice(i, 1);
                }
            }
        }

        // ========== CARD SELECTION SYSTEM ==========
        let wave30VictoryShown = false;

        function showWave30Victory() {
            gameState = 'cardSelection'; // Pause game
            document.exitPointerLock();
            document.getElementById('wave30Victory').classList.remove('hidden');

            // Unlock next character regardless of choice
            const newUnlock = unlockNextCharacter(currentRunCharacter);
            if (newUnlock) {
                const char = characters[newUnlock];
                setTimeout(() => {
                    alert(`Character Unlocked: ${char.name} (${char.role})!`);
                }, 500);
            }

            // Unlock next map
            const newMapUnlock = unlockNextMap(currentMapId);
            if (newMapUnlock) {
                const map = gameMaps[newMapUnlock];
                setTimeout(() => {
                    alert(`Map Unlocked: ${map.name}!`);
                }, newUnlock ? 1500 : 500);
            }
        }

        function continueFreeplay() {
            document.getElementById('wave30Victory').classList.add('hidden');
            document.getElementById('cardOverlay').classList.remove('hidden');
            // Generate cards for continuing
            generateCards();
        }

        function endAfterWave30() {
            document.getElementById('wave30Victory').classList.add('hidden');
            showGameOver(false); // Don't unlock again, already unlocked
        }

        function generateCards() {
            const cards = [];
            for (let i = 0; i < 3; i++) {
                const roll = Math.random();
                if (roll < 0.6) {
                    cards.push({ ...commonCards[Math.floor(Math.random() * commonCards.length)], rarity: 'common' });
                } else if (roll < 0.9) {
                    const rareCard = rareCards[Math.floor(Math.random() * rareCards.length)];
                    const currentLvl = rareCardLevels[rareCard.id] || 0;
                    const nextLvl = Math.min(currentLvl + 1, 5);
                    cards.push({
                        ...rareCard,
                        rarity: 'rare',
                        currentLevel: currentLvl,
                        nextLevel: nextLvl,
                        displayDesc: rareCard.desc.replace('{val}', rareCard.levels[nextLvl - 1])
                    });
                } else {
                    const legCard = legendaryCards[Math.floor(Math.random() * legendaryCards.length)];
                    const existingAbility = playerAbilities.find(a => a.id === legCard.id);
                    const currentLvl = existingAbility ? existingAbility.level : 0;
                    const nextLvl = Math.min(currentLvl + 1, 5);
                    cards.push({
                        ...legCard,
                        rarity: 'legendary',
                        currentLevel: currentLvl,
                        nextLevel: nextLvl,
                        displayDesc: legCard.desc.replace('{val}', legCard.levels[nextLvl - 1])
                    });
                }
            }
            renderCards(cards);
        }

        function showCardSelection() {
            // Check for wave 30 victory (freeplay choice)
            if (currentWave === 30 && !wave30VictoryShown) {
                wave30VictoryShown = true;
                showWave30Victory();
                return;
            }

            if (currentWave >= totalWaves) {
                // Victory! Check for character unlock
                gameState = 'gameOver';
                document.exitPointerLock();
                waveAnnouncementEl.textContent = 'VICTORY!';
                waveAnnouncementEl.style.color = '#00ff00';
                waveAnnouncementEl.style.opacity = '1';

                // Return to home after showing victory (pass true for unlock check)
                setTimeout(() => {
                    showGameOver(true);
                }, 3000);
                return;
            }

            gameState = 'cardSelection';
            document.exitPointerLock();
            document.getElementById('cardOverlay').classList.remove('hidden');

            // Generate 3 cards with weighted rarity
            // Fortune's Favor relic shifts odds toward rare/legendary
            const fortuneBonus = hasRelic('fortune') ? 0.15 : 0;
            const commonThreshold = 0.6 - fortuneBonus; // 60% -> 45%
            const rareThreshold = 0.9 - (fortuneBonus * 0.5); // 90% -> 82.5%

            const cards = [];
            for (let i = 0; i < 3; i++) {
                const roll = Math.random();
                if (roll < commonThreshold) {
                    // Common (60% or 45% with fortune)
                    cards.push({ ...commonCards[Math.floor(Math.random() * commonCards.length)], rarity: 'common' });
                } else if (roll < rareThreshold) {
                    // Rare (30% or 37.5% with fortune)
                    const rareCard = rareCards[Math.floor(Math.random() * rareCards.length)];
                    const currentLvl = rareCardLevels[rareCard.id] || 0;
                    const nextLvl = Math.min(currentLvl + 1, 5);
                    cards.push({
                        ...rareCard,
                        rarity: 'rare',
                        currentLevel: currentLvl,
                        nextLevel: nextLvl,
                        displayDesc: rareCard.desc.replace('{val}', rareCard.levels[nextLvl - 1])
                    });
                } else {
                    // 10% legendary
                    const legCard = legendaryCards[Math.floor(Math.random() * legendaryCards.length)];
                    const existingAbility = playerAbilities.find(a => a.id === legCard.id);
                    const currentLvl = existingAbility ? existingAbility.level : 0;
                    const nextLvl = Math.min(currentLvl + 1, 5);
                    cards.push({
                        ...legCard,
                        rarity: 'legendary',
                        currentLevel: currentLvl,
                        nextLevel: nextLvl,
                        displayDesc: legCard.desc.replace('{val}', legCard.levels[nextLvl - 1])
                    });
                }
            }

            renderCards(cards);
        }

        function renderCards(cards) {
            const container = document.getElementById('cardContainer');
            container.innerHTML = '';

            cards.forEach((card, index) => {
                const cardEl = document.createElement('div');
                cardEl.className = `card ${card.rarity}`;

                let levelInfo = '';
                if (card.rarity === 'rare') {
                    levelInfo = card.currentLevel > 0 ? `Level ${card.currentLevel} â†’ ${card.nextLevel}` : 'New!';
                } else if (card.rarity === 'legendary') {
                    if (card.currentLevel > 0) {
                        levelInfo = `Level ${card.currentLevel} â†’ ${card.nextLevel}`;
                    } else if (playerAbilities.length >= 5) {
                        levelInfo = 'Ability slots full!';
                    } else {
                        levelInfo = 'New Ability!';
                    }
                }

                cardEl.innerHTML = `
                    <div class="rarity">${card.rarity}</div>
                    <div class="icon">${card.icon}</div>
                    <div class="name">${card.name}</div>
                    <div class="description">${card.displayDesc || card.desc}</div>
                    ${levelInfo ? `<div class="level-info">${levelInfo}</div>` : ''}
                `;

                cardEl.addEventListener('click', () => selectCard(card));
                container.appendChild(cardEl);
            });

            // Add Build button below cards
            const buildBtn = document.createElement('div');
            buildBtn.className = 'build-button';
            buildBtn.innerHTML = 'ðŸ—ï¸ Build';
            buildBtn.addEventListener('click', () => {
                document.getElementById('cardOverlay').classList.add('hidden');
                enterBuildMode();
            });
            container.appendChild(buildBtn);
        }

        function selectCard(card) {
            trackQuestCardChosen();

            // Apply card effect
            if (card.rarity === 'common') {
                card.effect();
            } else if (card.rarity === 'rare') {
                rareCardLevels[card.id] = card.nextLevel;
                // Find the rare card and call its effect
                const rareCard = rareCards.find(r => r.id === card.id);
                rareCard.effect(card.nextLevel);
            } else if (card.rarity === 'legendary') {
                const existingAbility = playerAbilities.find(a => a.id === card.id);
                if (existingAbility) {
                    existingAbility.level = card.nextLevel;
                } else if (playerAbilities.length < 5) {
                    playerAbilities.push({
                        id: card.id,
                        name: card.name,
                        icon: card.icon,
                        cooldown: card.cooldown,
                        level: card.nextLevel,
                        activate: card.activate
                    });
                    abilityCooldowns[card.id] = 0;
                }
                updateAbilityBar();
            }

            // Update health bar to reflect new max health
            playerHealth = Math.min(playerHealth, playerStats.maxHealth);
            updatePlayerHealth();
            updateStatsDisplay();

            // Close card selection and start next wave
            document.getElementById('cardOverlay').classList.add('hidden');
            gameState = 'playing';
            renderer.domElement.requestPointerLock();
            setTimeout(startNextWave, 500);
        }

        // ========== ABILITY BAR UI ==========
        function updateAbilityBar() {
            const bar = document.getElementById('abilityBar');
            bar.innerHTML = '';

            playerAbilities.forEach((ability, index) => {
                const slot = document.createElement('div');
                slot.className = 'ability-slot legendary';

                const cooldown = abilityCooldowns[ability.id] || 0;
                const cooldownText = cooldown > 0 ? Math.ceil(cooldown) + 's' : '';

                slot.innerHTML = `
                    <div class="key">${index + 1}</div>
                    <div class="ability-icon">${ability.icon}</div>
                    ${ability.level > 1 ? `<div class="level">${ability.level}</div>` : ''}
                    ${cooldownText ? `<div class="cooldown-overlay">${cooldownText}</div>` : ''}
                `;
                bar.appendChild(slot);
            });
        }

        function updateStatsDisplay() {
            const display = document.getElementById('statsDisplay');
            display.innerHTML = `
                <div>DMG: ${Math.round(playerStats.damage * 100)}%</div>
                <div>SPD: ${Math.round(playerStats.moveSpeed * 100)}%</div>
                <div>ARM: ${playerStats.armor + (playerStats.ironWillArmor || 0)}</div>
                <div>CRIT: ${Math.round(playerStats.critChance * 100)}%</div>
            `;
        }

        // ========== HOME SCREEN & GAME OVER ==========
        // Track current character for this run (for unlock check)
        let currentRunCharacter = 'standard';

        // Shuriken thrower state
        let shurikenAmmo = 0;
        let maxShurikenAmmo = 0;
        let shurikenRegenTimer = 0;

        // Archer state
        let arrowAmmo = 0;
        let maxArrowAmmo = 0;
        let arrowRegenTimer = 0;
        let canArcherPunch = true;
        let canShootArrow = true;

        // Archer punch attack - restores 1 arrow, deals 3-5 damage
        // Archer dagger attack - restores arrows on hit
        function performArcherDagger() {
            if (!canArcherPunch) return;
            canArcherPunch = false;

            // Dagger cooldown
            const daggerCooldown = 0.35;
            setTimeout(() => { canArcherPunch = true; }, daggerCooldown * 1000);

            // Deal 25% of arrow damage as melee
            const baseDamage = characters.archer.arrowDamage * playerStats.damage;
            const daggerDamage = Math.floor(baseDamage * 0.25);
            const daggerRange = 3.5;
            const daggerAngle = Math.PI / 2; // 90 degree cone

            let hitEnemy = false;
            enemies.forEach(enemy => {
                if (!enemy.mesh) return;

                const dx = enemy.mesh.position.x - player.position.x;
                const dz = enemy.mesh.position.z - player.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < daggerRange) {
                    // Use -dx, -dz to match normal melee attack direction
                    const angleToEnemy = Math.atan2(-dx, -dz);
                    let angleDiff = angleToEnemy - cameraRotationY;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                    if (Math.abs(angleDiff) < daggerAngle / 2) {
                        enemy.health -= daggerDamage;
                        trackQuestDamage(daggerDamage);
                        hitEnemy = true;
                        createDamageNumber(enemy.mesh.position.x, enemy.mesh.position.y + 2, enemy.mesh.position.z, daggerDamage, false);
                        createHitEffect(enemy.mesh.position.x, 1.5, enemy.mesh.position.z, 0x88ffff);
                    }
                }
            });

            // Restore 1 arrow if hit an enemy
            if (hitEnemy && arrowAmmo < maxArrowAmmo) {
                arrowAmmo++;
                updateArrowUI();
                showXPPopup('+1 Arrow', player.position.x, player.position.z);
            }

            // Dagger visual effect
            createHitEffect(
                player.position.x + Math.sin(cameraRotationY) * 1.5,
                1.2,
                player.position.z + Math.cos(cameraRotationY) * 1.5,
                0x88ffff
            );
        }

        function startGame() {
            // Reset everything
            gameState = 'playing';
            currentWave = 0;
            wave30VictoryShown = false;
            currentRunCharacter = selectedCharacter;

            // Reset quest tracking for new game
            resetQuestTracking();
            updateQuestHUD();

            // Reset relic state for new game
            killStreakStacks = 0;
            killStreakTimer = 0;
            hunterSpeedTimer = 0;
            phoenixReviveUsed = false;
            temporalSlowCooldown = 0;
            furyAttackSpeedTimer = 0;
            enemiesFirstHit.clear();

            // Reset combat state
            isSwinging = false;
            isParrying = false;
            canAttack = true;
            swingProgress = 0;
            hasHitThisSwing = false;

            // Use selected map
            applyMapTheme(selectedMap);
            rebuildEnvironment();

            // Clear and spawn fresh animals
            clearAnimals();
            spawnAnimals(3); // Start with a few animals

            // Apply selected character's base stats
            const char = characters[selectedCharacter];
            Object.assign(playerStats, {
                maxHealth: char.baseStats.maxHealth,
                damage: char.baseStats.damage,
                attackSpeed: char.baseStats.attackSpeed,
                moveSpeed: char.baseStats.moveSpeed,
                armor: char.baseStats.armor,
                critChance: char.baseStats.critChance,
                critDamage: char.baseStats.critDamage,
                lifesteal: 0,
                comboBonus: 0,
                attackRange: 1.0,
                regenRate: 1.0,
                parryDamageReduction: 0.75
            });

            // Character-specific setup
            if (char.special === 'blockChance') {
                playerStats.blockChance = 0.2; // Knight: 20% block
            }
            if (char.special === 'backstab') {
                playerStats.backstabBonus = 1.0; // Assassin: +100% from behind
            }
            if (char.special === 'shurikens') {
                maxShurikenAmmo = char.shurikenAmmo;
                shurikenAmmo = maxShurikenAmmo;
                shurikenRegenTimer = 0;
                document.getElementById('shurikenAmmo').classList.remove('hidden');
                updateShurikenUI();
            } else {
                document.getElementById('shurikenAmmo').classList.add('hidden');
            }
            if (char.special === 'bowAttack') {
                maxArrowAmmo = char.arrowAmmo;
                arrowAmmo = maxArrowAmmo;
                arrowRegenTimer = 0;
                canArcherPunch = true;
                canShootArrow = true;
                document.getElementById('arrowAmmo').classList.remove('hidden');
                updateArrowUI();
            } else {
                document.getElementById('arrowAmmo').classList.add('hidden');
            }
            if (char.special === 'pikeReach') {
                playerStats.attackRange = char.pikeRangeBonus; // Pike has extended range
            }
            if (char.special === 'wizard') {
                wizardEnergy = 0;
                wizardMaxEnergy = char.maxEnergy || 100;
                wizardFireballCooldown = 0;
                wizardHomingCooldown = 0;
                document.getElementById('wizardEnergy').classList.remove('hidden');
                updateWizardEnergyUI();
            } else if (char.special === 'necromancer') {
                necroMana = 0;
                necroMaxMana = char.maxEnergy || 150;
                necroMaxMinions = 4; // Base max minions
                // Clear existing minions
                for (const minion of necroMinions) {
                    scene.remove(minion.mesh);
                }
                necroMinions = [];
                document.getElementById('wizardEnergy').classList.remove('hidden');
                updateNecroManaUI();
            } else {
                document.getElementById('wizardEnergy').classList.add('hidden');
            }

            // Apply skill tree bonuses
            const bonuses = getSkillBonuses(selectedCharacter);
            // Apply stat multipliers
            for (const stat in bonuses.statMults) {
                if (playerStats[stat] !== undefined) {
                    playerStats[stat] *= bonuses.statMults[stat];
                }
            }
            // Apply stat additions
            for (const stat in bonuses.statAdds) {
                if (playerStats[stat] !== undefined) {
                    playerStats[stat] += bonuses.statAdds[stat];
                }
            }
            // Store special bonuses for later use
            playerStats.skillBonuses = bonuses.specials;

            // Apply special skill bonuses to character-specific mechanics
            if (char.special === 'shurikens' && bonuses.specials.maxShurikens) {
                maxShurikenAmmo += bonuses.specials.maxShurikens.add || 0;
                shurikenAmmo = maxShurikenAmmo;
                updateShurikenUI();
            }
            if (char.special === 'bowAttack' && bonuses.specials.maxArrows) {
                maxArrowAmmo += bonuses.specials.maxArrows.add || 0;
                arrowAmmo = maxArrowAmmo;
                updateArrowUI();
            }
            if (char.special === 'pikeReach' && bonuses.specials.pikeRange) {
                playerStats.attackRange *= bonuses.specials.pikeRange.mult || 1;
            }
            if (char.special === 'wizard' && bonuses.specials.maxEnergy) {
                wizardMaxEnergy += bonuses.specials.maxEnergy.add || 0;
                updateWizardEnergyUI();
            }
            if (char.special === 'necromancer') {
                if (bonuses.specials.maxEnergy) {
                    necroMaxMana += bonuses.specials.maxEnergy.add || 0;
                }
                if (bonuses.specials.maxMinions) {
                    necroMaxMinions += bonuses.specials.maxMinions.add || 0;
                }
                updateNecroManaUI();
            }

            playerHealth = playerStats.maxHealth;

            // Initialize stamina
            playerStamina = playerStats.maxStamina;
            isStaminaStunned = false;
            updateStaminaUI();

            // Update stats panel
            updateStatsPanel();

            // Clear enemies
            for (const enemy of enemies) {
                scene.remove(enemy.mesh);
            }
            enemies.length = 0;

            // Hide boss health bar
            hideBossHealthBar();

            // Clear projectiles
            for (const proj of projectiles) {
                scene.remove(proj.mesh);
            }
            projectiles.length = 0;

            // Clear visual effects
            for (const effect of visualEffects) {
                scene.remove(effect.mesh);
            }
            visualEffects.length = 0;

            // Clear gibs
            for (const gib of gibs) {
                scene.remove(gib.mesh);
            }
            gibs.length = 0;

            // Clear visual projectiles
            for (const vp of visualProjectiles) {
                scene.remove(vp.mesh);
            }
            visualProjectiles.length = 0;

            // Clear player projectiles (shurikens)
            for (const pp of playerProjectiles) {
                scene.remove(pp.mesh);
            }
            playerProjectiles.length = 0;

            // Reset player position
            player.position.set(0, 0, 0);
            cameraRotationY = 0;

            // Reset abilities and stats
            phoenixUsedThisWave = false;
            demonFormActive = false;
            scene.fog = null;

            // Update UI
            updatePlayerHealth();
            updateEnemyCount();
            updateAbilityBar();
            updateStatsDisplay();

            // Hide home, show game UI
            document.getElementById('homeScreen').classList.add('hidden');
            document.getElementById('gameUI').classList.remove('hidden');

            // Lock pointer and start
            renderer.domElement.requestPointerLock();
            setTimeout(startNextWave, 1000);
        }

        function updateShurikenUI() {
            const el = document.getElementById('shurikenAmmo');
            el.innerHTML = `Shurikens [Q]: ${'â˜…'.repeat(shurikenAmmo)}${'â˜†'.repeat(maxShurikenAmmo - shurikenAmmo)}`;
        }

        function updateArrowUI() {
            const el = document.getElementById('arrowAmmo');
            el.innerHTML = `Arrows: ${'âž¤'.repeat(arrowAmmo)}${'â—‹'.repeat(maxArrowAmmo - arrowAmmo)}`;
        }

        function updateStatsPanel() {
            const statsList = document.getElementById('statsList');
            if (!statsList) return;

            const stats = [
                { label: 'Max HP', value: playerStats.maxHealth.toFixed(0) },
                { label: 'Damage', value: playerStats.damage.toFixed(2) },
                { label: 'Atk Speed', value: playerStats.attackSpeed.toFixed(2) },
                { label: 'Move Speed', value: playerStats.moveSpeed.toFixed(2) },
                { label: 'Armor', value: playerStats.armor.toFixed(0) },
                { label: 'Crit Chance', value: playerStats.critChance.toFixed(2) },
                { label: 'Crit Damage', value: playerStats.critDamage.toFixed(2) },
                { label: 'Lifesteal', value: playerStats.lifesteal.toFixed(2) },
                { label: 'Combo Bonus', value: playerStats.comboBonus.toFixed(2) },
                { label: 'Atk Range', value: playerStats.attackRange.toFixed(2) },
                { label: 'Regen Rate', value: playerStats.regenRate.toFixed(2) },
                { label: 'Parry Reduc', value: playerStats.parryDamageReduction.toFixed(2) },
                { label: 'Max Stamina', value: playerStats.maxStamina.toFixed(0) },
                { label: 'Stam Regen', value: playerStats.staminaRegen.toFixed(1) },
                { label: 'Stam Drain', value: playerStats.staminaMoveDrain.toFixed(1) },
                { label: 'Dodge Cost', value: playerStats.staminaDodgeCost.toFixed(0) }
            ];

            statsList.innerHTML = stats.map(s =>
                `<div class="stat-row"><span class="stat-label">${s.label}:</span><span class="stat-value">${s.value}</span></div>`
            ).join('');
        }

        function updateStaminaUI() {
            const staminaBarInner = document.getElementById('staminaBarInner');
            const staminaText = document.getElementById('staminaText');
            const staminaStatus = document.getElementById('staminaStatus');
            if (!staminaBarInner || !staminaText) return;

            const staminaPercent = (playerStamina / playerStats.maxStamina) * 100;
            staminaBarInner.style.width = staminaPercent + '%';
            staminaText.textContent = `${Math.floor(playerStamina)} / ${Math.floor(playerStats.maxStamina)}`;

            // Update bar color based on stamina level
            staminaBarInner.classList.remove('low', 'critical', 'exhausted');
            if (isStaminaStunned) {
                staminaBarInner.classList.add('exhausted');
            } else if (staminaPercent <= 35) {
                staminaBarInner.classList.add('critical');
            } else if (staminaPercent <= 60) {
                staminaBarInner.classList.add('low');
            }

            // Update status text
            if (staminaStatus) {
                if (isStaminaStunned) {
                    staminaStatus.textContent = 'EXHAUSTED - Cannot move!';
                    staminaStatus.style.color = '#ff0000';
                } else if (staminaPercent <= 35) {
                    staminaStatus.textContent = 'TIRED - 30% slower';
                    staminaStatus.style.color = '#ff6600';
                } else if (staminaPercent <= 60) {
                    staminaStatus.textContent = 'WINDED - Cannot dodge';
                    staminaStatus.style.color = '#ffaa00';
                } else {
                    staminaStatus.textContent = '';
                }
            }
        }

        // Play character-specific attack animation on screen
        function playAttackAnimation(attackType = 'melee') {
            const container = document.getElementById('attackAnimation');
            if (!container) return;

            // Clear any existing animation
            container.innerHTML = '';

            // Determine animation class based on character and attack type
            let animClass = '';
            const charId = currentRunCharacter;

            if (attackType === 'punch') {
                animClass = 'archer-punch';
            } else if (attackType === 'arrow') {
                animClass = 'archer-shot';
            } else if (attackType === 'spell') {
                animClass = 'wizard-cast';
            } else if (attackType === 'summon') {
                animClass = 'necro-summon';
            } else {
                // Melee attack animations by character
                switch (charId) {
                    case 'standard':
                        animClass = 'samurai-slash';
                        break;
                    case 'knight':
                        animClass = 'knight-swing';
                        break;
                    case 'thrower':
                        animClass = 'shuriken-throw';
                        break;
                    case 'assassin':
                        animClass = 'assassin-slash';
                        break;
                    case 'archer':
                        animClass = 'archer-shot';
                        break;
                    case 'pikeman':
                        animClass = 'pike-thrust';
                        break;
                    case 'wizard':
                        animClass = 'wizard-cast';
                        break;
                    case 'necromancer':
                        animClass = 'necro-slash';
                        break;
                    default:
                        animClass = 'samurai-slash';
                }
            }

            // Create and add the animation element
            const effectEl = document.createElement('div');
            effectEl.className = `attack-effect ${animClass}`;
            container.appendChild(effectEl);

            // Remove element after animation completes
            setTimeout(() => {
                if (effectEl.parentNode) {
                    effectEl.parentNode.removeChild(effectEl);
                }
            }, 400);
        }

        function showGameOver(isVictory = false) {
            gameState = 'gameOver';
            document.exitPointerLock();

            // Check for low HP win quest
            if (isVictory && activeQuest) {
                const quest = ALL_QUESTS.find(q => q.id === activeQuest);
                if (quest && quest.type === 'lowHPWin') {
                    const hpPercent = (playerHealth / playerStats.maxHealth) * 100;
                    if (hpPercent < quest.target) {
                        questProgress.current = quest.target;
                        updateQuestProgress();
                    }
                }
                // Also check damageTaken quest completion
                if (quest && quest.type === 'damageTaken' && questDamageTaken >= quest.target) {
                    questProgress.current = questDamageTaken;
                    updateQuestProgress();
                }
            }

            // Check for character unlock on victory
            if (isVictory) {
                const newUnlock = unlockNextCharacter(currentRunCharacter);
                if (newUnlock) {
                    const char = characters[newUnlock];
                    setTimeout(() => {
                        alert(`Congratulations! You unlocked: ${char.name} (${char.role})!`);
                    }, 500);
                }

                // Unlock relic for completing this map
                const newRelic = unlockRelic(selectedMap);
                if (newRelic) {
                    setTimeout(() => {
                        alert(`Relic Acquired: ${newRelic.icon} ${newRelic.name}!\n\n${newRelic.desc}`);
                    }, 1000);
                }
            }

            // Reset all stats for next run (will be set again by startGame based on character)
            Object.assign(playerStats, {
                maxHealth: 100,
                damage: 1.0,
                attackSpeed: 1.0,
                moveSpeed: 1.0,
                armor: 0,
                critChance: 0,
                critDamage: 1.5,
                lifesteal: 0,
                comboBonus: 0,
                attackRange: 1.0,
                regenRate: 1.0,
                parryDamageReduction: 0.75,
                // Clear rare card effect stats
                berserkBonus: 0,
                thornsDamage: 0,
                executeBonus: 0,
                momentumBonus: 0,
                cleaveTargets: 0,
                critHeal: 0,
                lastStandReduction: 0,
                firstStrikeBonus: 0,
                adrenalineBonus: 0,
                soulEaterBonus: 0,
                bloodlustHeal: 0,
                parryDamageBoost: 0,
                ironWillArmor: 0,
                hunterBonus: 0,
                predatorBonus: 0,
                // Clear character-specific stats
                blockChance: 0,
                backstabBonus: 0,
                // Reset stamina stats
                maxStamina: 100,
                staminaRegen: 15,
                staminaMoveDrain: 8,
                staminaDodgeCost: 25
            });

            // Clear rare card levels
            Object.keys(rareCardLevels).forEach(key => delete rareCardLevels[key]);

            // Clear abilities
            playerAbilities.length = 0;
            Object.keys(abilityCooldowns).forEach(key => delete abilityCooldowns[key]);

            // Reset active effects
            timeSlowActive = false;
            timeSlowMultiplier = 1;
            ironFortressActive = false;
            momentumActive = false;
            momentumSpeedBonus = 0;
            parryDamageBoostActive = false;
            adrenalineActive = false;
            shadowStepBonus = 0;
            comboCount = 0;

            // Reset shuriken state
            shurikenAmmo = 0;
            maxShurikenAmmo = 0;

            // Reset arrow state
            arrowAmmo = 0;
            maxArrowAmmo = 0;

            // Clean up spirit and decoys
            if (spiritMesh) {
                scene.remove(spiritMesh);
                spiritMesh = null;
            }
            for (const decoy of decoys) scene.remove(decoy);
            decoys = [];

            // Clean up necromancer minions
            for (const minion of necroMinions) {
                scene.remove(minion.mesh);
            }
            necroMinions = [];

            // Show home screen after delay
            setTimeout(() => {
                document.getElementById('gameUI').classList.add('hidden');
                document.getElementById('homeScreen').classList.remove('hidden');
                document.getElementById('shurikenAmmo').classList.add('hidden');
                waveAnnouncementEl.style.opacity = '0';
                renderCharacterSelect(); // Refresh character select to show new unlocks
                renderRelicsPanel(); // Refresh relics to show new unlocks
            }, 2000);
        }

        // Start button event
        document.getElementById('startBtn').addEventListener('click', startGame);

        // Ability hotkeys (1-5) and Q for shurikens
        document.addEventListener('keydown', (e) => {
            if (gameState !== 'playing') return;

            const key = e.key.toLowerCase();
            if (key >= '1' && key <= '5') {
                const index = parseInt(key) - 1;
                if (index < playerAbilities.length) {
                    const ability = playerAbilities[index];
                    if (abilityCooldowns[ability.id] <= 0) {
                        ability.activate(ability.level);
                        abilityCooldowns[ability.id] = ability.cooldown;
                        updateAbilityBar();
                    }
                }
            }

            // Q - Throw shuriken (Shuriken Master only)
            if (key === 'q' && characters[currentRunCharacter].special === 'shurikens') {
                throwPlayerShuriken();
            }
        });

        // Player projectiles array
        const playerProjectiles = [];

        function throwPlayerShuriken() {
            if (shurikenAmmo <= 0) return;

            shurikenAmmo--;
            updateShurikenUI();
            playAttackAnimation('melee'); // Uses shuriken-throw animation

            const char = characters.thrower;
            const pos = player.position.clone();
            pos.y = 1.5;

            // Direction player is facing
            const dir = new THREE.Vector3(
                -Math.sin(cameraRotationY),
                0,
                -Math.cos(cameraRotationY)
            ).normalize();

            const geo = new THREE.BoxGeometry(0.2, 0.03, 0.2);
            const mat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.8 });
            const shuriken = new THREE.Mesh(geo, mat);
            shuriken.position.copy(pos);
            shuriken.position.add(dir.clone().multiplyScalar(1)); // Start in front of player
            shuriken.lookAt(shuriken.position.clone().add(dir));
            scene.add(shuriken);

            playerProjectiles.push({
                mesh: shuriken,
                dir: dir,
                speed: 25,
                damage: char.shurikenDamage * playerStats.damage,
                life: 2.5
            });
        }

        function updatePlayerProjectiles(deltaTime) {
            for (let i = playerProjectiles.length - 1; i >= 0; i--) {
                const proj = playerProjectiles[i];
                proj.life -= deltaTime;

                if (proj.life <= 0) {
                    scene.remove(proj.mesh);
                    playerProjectiles.splice(i, 1);
                    continue;
                }

                // Check range limit
                if (proj.maxRange && proj.startPos) {
                    const dx = proj.mesh.position.x - proj.startPos.x;
                    const dz = proj.mesh.position.z - proj.startPos.z;
                    const distTraveled = Math.sqrt(dx * dx + dz * dz);
                    if (distTraveled >= proj.maxRange) {
                        scene.remove(proj.mesh);
                        playerProjectiles.splice(i, 1);
                        continue;
                    }
                }

                // Move projectile
                proj.mesh.position.x += proj.dir.x * proj.speed * deltaTime;
                proj.mesh.position.z += proj.dir.z * proj.speed * deltaTime;

                // Spin (shurikens only, not arrows)
                if (!proj.isArrow) {
                    proj.mesh.rotation.y += deltaTime * 25;
                }

                // Check collision with enemies
                for (let e = enemies.length - 1; e >= 0; e--) {
                    const enemy = enemies[e];
                    const dx = proj.mesh.position.x - enemy.mesh.position.x;
                    const dz = proj.mesh.position.z - enemy.mesh.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    if (dist < 1.5) {
                        // Hit enemy
                        let damage = proj.damage;

                        // Apply crit
                        const isCrit = Math.random() < playerStats.critChance;
                        if (isCrit) {
                            damage *= playerStats.critDamage;
                        }

                        // Armor pierce
                        const pierce = playerStats.armorPierce || 0;
                        const effectiveArmor = Math.max(0, enemy.armor - pierce);
                        const actualDamage = applyDamageVariance(Math.max(1, damage - effectiveArmor));

                        enemy.health -= actualDamage;
                        trackQuestDamage(actualDamage);

                        // Flash enemy (yellow for crit, red for normal)
                        const flashColor = isCrit ? 0xffff00 : 0xff0000;
                        enemy.mesh.children.forEach(child => {
                            if (child.material && child.material.emissive) {
                                child.material.emissive.setHex(flashColor);
                                setTimeout(() => { child.material.emissive.setHex(0x000000); }, 100);
                            }
                        });

                        // Lifesteal
                        if (playerStats.lifesteal > 0) {
                            const healAmount = actualDamage * playerStats.lifesteal;
                            playerHealth = Math.min(playerStats.maxHealth, playerHealth + healAmount);
                            updatePlayerHealth();
                        }

                        // Check if enemy died
                        if (enemy.health <= 0) {
                            createGibs(enemy);
                            scene.remove(enemy.mesh);
                            enemies.splice(e, 1);
                            onEnemyKilled(enemy);
                            updateEnemyCount();
                        }

                        scene.remove(proj.mesh);
                        playerProjectiles.splice(i, 1);
                        break;
                    }
                }
            }
        }

        function regenShurikens(deltaTime) {
            if (characters[currentRunCharacter].special !== 'shurikens') return;
            if (shurikenAmmo >= maxShurikenAmmo) return;

            shurikenRegenTimer += deltaTime;
            const baseRegenTime = characters.thrower.shurikenRegenTime;
            const regenMult = playerStats.skillBonuses?.shurikenRegen?.mult || 1;
            const regenTime = baseRegenTime * regenMult;

            if (shurikenRegenTimer >= regenTime) {
                shurikenRegenTimer = 0;
                shurikenAmmo = Math.min(shurikenAmmo + 1, maxShurikenAmmo);
                updateShurikenUI();
            }
        }

        // Arrow passive regen (half shuriken speed) + melee restores arrows
        function regenArrows(deltaTime) {
            if (characters[currentRunCharacter].special !== 'bowAttack') return;
            if (arrowAmmo >= maxArrowAmmo) return;

            arrowRegenTimer += deltaTime;
            const baseRegenTime = characters.archer.arrowRegenTime; // 8 seconds
            const regenMult = playerStats.skillBonuses?.arrowRegen?.mult || 1;
            const regenTime = baseRegenTime * regenMult;

            if (arrowRegenTimer >= regenTime) {
                arrowRegenTimer = 0;
                arrowAmmo = Math.min(arrowAmmo + 1, maxArrowAmmo);
                updateArrowUI();
            }
        }

        function shootArrow() {
            if (arrowAmmo <= 0) return;
            if (!canShootArrow) return;

            canShootArrow = false;
            setTimeout(() => { canShootArrow = true; }, 400); // 0.4s cooldown between shots

            arrowAmmo--;
            arrowRegenTimer = 0; // Reset regen timer when shooting
            updateArrowUI();

            const char = characters.archer;
            const pos = player.position.clone();
            pos.y = 1.5;

            // Direction player is facing with small aim spread
            const aimSpread = 0.045; // Small inaccuracy cone (~2.6 degrees, 25% tighter)
            const spreadX = (Math.random() - 0.5) * aimSpread;
            const spreadZ = (Math.random() - 0.5) * aimSpread;
            const dir = new THREE.Vector3(
                -Math.sin(cameraRotationY) + spreadX,
                0,
                -Math.cos(cameraRotationY) + spreadZ
            ).normalize();

            // Create arrow mesh (elongated box)
            const arrowBody = new THREE.BoxGeometry(0.08, 0.08, 0.6);
            const arrowMat = new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.8 });
            const arrow = new THREE.Mesh(arrowBody, arrowMat);

            // Add arrowhead
            const headGeo = new THREE.BoxGeometry(0.15, 0.15, 0.15);
            const headMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.7 });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.z = 0.35;
            arrow.add(head);

            arrow.position.copy(pos);
            arrow.position.add(dir.clone().multiplyScalar(1));
            arrow.lookAt(arrow.position.clone().add(dir));
            scene.add(arrow);

            playerProjectiles.push({
                mesh: arrow,
                dir: dir,
                speed: 35, // Faster than shurikens
                damage: char.arrowDamage * playerStats.damage,
                life: 3.0,
                isArrow: true,
                startPos: pos.clone(),
                maxRange: 22.5 * (playerStats.skillBonuses?.arrowRange?.mult || 1) // Arrows have 22.5 unit range (25% reduced) + skill bonus
            });
        }

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb); // Sky blue background

        // ========== MAP SYSTEM ==========
        const gameMaps = {
            forest: {
                name: 'Forest Glade',
                skyColor: 0x87ceeb,
                groundColor: 0x228B22,
                gridColor: 0x1a6b1a,
                ambientIntensity: 0.5,
                lightColor: 0xffffff,
                lake: { color: 0x2288aa, bottomColor: 0x1a5566 },
                treeColors: { trunk: 0x4a3728, leaves: 0x228B22 },
                rockColor: 0x666666,
                enemies: ['ashigaru', 'ronin', 'scout', 'samurai', 'ninja', 'brute', 'oni'],
                dragonTheme: { bodyColor: 0x228B22, accentColor: 0x44aa44, eyeColor: 0xff4400, fireColor: 0xff4400, name: 'Forest Dragon' }
            },
            desert: {
                name: 'Scorched Sands',
                skyColor: 0xffd699,
                groundColor: 0xc2a366,
                gridColor: 0xa08050,
                ambientIntensity: 0.7,
                lightColor: 0xfff4e0,
                lake: { color: 0x66ccaa, bottomColor: 0x448866 }, // Oasis
                treeColors: { trunk: 0x8B4513, leaves: 0x9acd32 }, // Palm trees
                rockColor: 0xb8956e,
                enemies: ['ashigaru', 'ronin', 'bandit', 'samurai', 'desert_warrior', 'brute', 'sandOni'],
                dragonTheme: { bodyColor: 0xc2a366, accentColor: 0xff6600, eyeColor: 0xffff00, fireColor: 0xff8800, name: 'Sand Wyrm' }
            },
            volcano: {
                name: 'Volcanic Wastes',
                skyColor: 0x4a2020,
                groundColor: 0x2a1a1a,
                gridColor: 0x3a2020,
                ambientIntensity: 0.3,
                lightColor: 0xff6644,
                lake: { color: 0xff4400, bottomColor: 0xaa2200 }, // Lava pool
                treeColors: { trunk: 0x1a1a1a, leaves: 0x4a1a1a }, // Dead trees
                rockColor: 0x1a1a1a,
                enemies: ['fireImp', 'lavaGolem', 'ashWraith', 'samurai', 'ninja', 'infernoOni', 'brute'],
                dragonTheme: { bodyColor: 0x440000, accentColor: 0xff2200, eyeColor: 0xffff00, fireColor: 0xff0000, name: 'Inferno Drake' }
            },
            frost: {
                name: 'Frozen Tundra',
                skyColor: 0xaaccff,
                groundColor: 0xddeeff,
                gridColor: 0xbbccdd,
                ambientIntensity: 0.6,
                lightColor: 0xccddff,
                lake: { color: 0x88bbdd, bottomColor: 0x6699bb }, // Frozen lake
                treeColors: { trunk: 0x4a4a5a, leaves: 0xaaddff }, // Snow-covered
                rockColor: 0x8899aa,
                enemies: ['frostWarrior', 'iceArcher', 'snowBrute', 'samurai', 'frostNinja', 'iceOni', 'ronin'],
                dragonTheme: { bodyColor: 0x88aacc, accentColor: 0xaaddff, eyeColor: 0x00ffff, fireColor: 0x88ddff, name: 'Frost Wyrm' }
            },
            swamp: {
                name: 'Cursed Swamp',
                skyColor: 0x445544,
                groundColor: 0x2a3a2a,
                gridColor: 0x1a2a1a,
                ambientIntensity: 0.35,
                lightColor: 0x88aa88,
                lake: { color: 0x334422, bottomColor: 0x222211 }, // Murky water
                treeColors: { trunk: 0x2a2a1a, leaves: 0x445533 }, // Dead/mossy trees
                rockColor: 0x3a3a2a,
                enemies: ['swampZombie', 'bogWitch', 'mireCreeper', 'samurai', 'plagueBearer', 'swampOni', 'ronin'],
                dragonTheme: { bodyColor: 0x334422, accentColor: 0x66aa44, eyeColor: 0x88ff00, fireColor: 0x66ff22, name: 'Plague Dragon' }
            },
            shadow: {
                name: 'Shadow Realm',
                skyColor: 0x1a0a2a,
                groundColor: 0x1a1a2a,
                gridColor: 0x2a1a3a,
                ambientIntensity: 0.25,
                lightColor: 0x8866cc,
                lake: { color: 0x2a1a4a, bottomColor: 0x1a0a2a }, // Void pool
                treeColors: { trunk: 0x1a1a2a, leaves: 0x4a2a6a }, // Shadow trees
                rockColor: 0x2a2a3a,
                enemies: ['shadowWraith', 'voidStalker', 'darkKnight', 'samurai', 'shadowNinja', 'shadowOni', 'ronin'],
                dragonTheme: { bodyColor: 0x2a1a4a, accentColor: 0x8844cc, eyeColor: 0xff00ff, fireColor: 0xaa44ff, name: 'Void Dragon' }
            },
            crystal: {
                name: 'Crystal Cavern',
                skyColor: 0x1a1a3a,
                groundColor: 0x2a2a4a,
                gridColor: 0x3a3a5a,
                ambientIntensity: 0.4,
                lightColor: 0xaabbff,
                lake: { color: 0x4466aa, bottomColor: 0x223366 }, // Crystal-clear water
                treeColors: { trunk: 0x6666aa, leaves: 0x88aaff }, // Crystal formations
                rockColor: 0x5566aa,
                enemies: ['crystalGolem', 'gemSprite', 'caveHunter', 'samurai', 'crystalArcher', 'crystalOni', 'ronin'],
                dragonTheme: { bodyColor: 0x4466aa, accentColor: 0x88ccff, eyeColor: 0x00ffff, fireColor: 0x66aaff, name: 'Crystal Dragon' }
            },
            graveyard: {
                name: 'Haunted Graveyard',
                skyColor: 0x2a2a3a,
                groundColor: 0x3a3a3a,
                gridColor: 0x2a2a2a,
                ambientIntensity: 0.3,
                lightColor: 0x8888aa,
                lake: { color: 0x334433, bottomColor: 0x222222 }, // Stagnant pond
                treeColors: { trunk: 0x2a2a2a, leaves: 0x3a3a4a }, // Dead trees
                rockColor: 0x4a4a4a,
                enemies: ['skeleton', 'ghost', 'ghoul', 'samurai', 'banshee', 'graveOni', 'ronin'],
                dragonTheme: { bodyColor: 0x3a3a4a, accentColor: 0x666688, eyeColor: 0x88ff88, fireColor: 0x88ffaa, name: 'Bone Dragon' }
            },
            sky: {
                name: 'Sky Temple',
                skyColor: 0xaaddff,
                groundColor: 0xeeeeff,
                gridColor: 0xddddee,
                ambientIntensity: 0.8,
                lightColor: 0xffffee,
                lake: { color: 0xaaccff, bottomColor: 0x88aadd }, // Cloud pool
                treeColors: { trunk: 0xccccdd, leaves: 0xffffff }, // White marble pillars
                rockColor: 0xddddee,
                enemies: ['skyGuardian', 'cloudNinja', 'templeMonk', 'samurai', 'stormArcher', 'skyOni', 'ronin'],
                dragonTheme: { bodyColor: 0xddddff, accentColor: 0xffffaa, eyeColor: 0xffff00, fireColor: 0xffffcc, name: 'Storm Dragon' }
            },
            abyss: {
                name: 'Infernal Abyss',
                skyColor: 0x0a0000,
                groundColor: 0x1a0a0a,
                gridColor: 0x2a0a0a,
                ambientIntensity: 0.2,
                lightColor: 0xff4422,
                lake: { color: 0x660000, bottomColor: 0x330000 }, // Blood pool
                treeColors: { trunk: 0x1a0a0a, leaves: 0x440000 }, // Bone spires
                rockColor: 0x2a1a1a,
                enemies: ['hellSpawn', 'demonGuard', 'abyssalKnight', 'samurai', 'hellArcher', 'abyssOni', 'ronin'],
                dragonTheme: { bodyColor: 0x440000, accentColor: 0xff0000, eyeColor: 0xffff00, fireColor: 0xff2200, name: 'Abyssal Dragon' }
            }
        };

        // ========== RELICS SYSTEM ==========
        // Earned by beating each map - unique passive effects
        const relics = {
            forest: {
                id: 'forest',
                name: 'Heart of the Grove',
                icon: 'ðŸŒ³',
                mapId: 'forest',
                desc: 'Killing enemies has 15% chance to drop a healing orb',
                effect: 'healingOrbs'
            },
            desert: {
                id: 'desert',
                name: 'Scorched Hourglass',
                icon: 'â³',
                mapId: 'desert',
                desc: 'Once per wave, survive fatal damage with 1 HP + 2s invincibility',
                effect: 'deathSave'
            },
            volcano: {
                id: 'volcano',
                name: 'Volcanic Core',
                icon: 'ðŸŒ‹',
                mapId: 'volcano',
                desc: 'Enemies explode on death, damaging nearby foes',
                effect: 'deathExplosion'
            },
            frost: {
                id: 'frost',
                name: 'Permafrost Shard',
                icon: 'â„ï¸',
                mapId: 'frost',
                desc: 'Attacks have 20% chance to freeze enemies for 1.5s',
                effect: 'freezeChance'
            },
            swamp: {
                id: 'swamp',
                name: 'Plague Amulet',
                icon: 'â˜ ï¸',
                mapId: 'swamp',
                desc: 'Damaged enemies become poisoned, taking damage over time',
                effect: 'poisonTouch'
            },
            shadow: {
                id: 'shadow',
                name: 'Void Cloak',
                icon: 'ðŸ‘»',
                mapId: 'shadow',
                desc: 'After dodging, become invisible for 1.5s (enemies lose aggro)',
                effect: 'dodgeInvisibility'
            },
            crystal: {
                id: 'crystal',
                name: 'Crystal Eye',
                icon: 'ðŸ’Ž',
                mapId: 'crystal',
                desc: 'See enemy health bars and critical hits deal double damage',
                effect: 'crystalVision'
            },
            graveyard: {
                id: 'graveyard',
                name: 'Spectral Lantern',
                icon: 'ðŸ®',
                mapId: 'graveyard',
                desc: '12% chance killed enemies become friendly ghosts',
                effect: 'ghostAllies'
            },
            sky: {
                id: 'sky',
                name: 'Storm Feather',
                icon: 'ðŸª¶',
                mapId: 'sky',
                desc: 'Gain double jump ability',
                effect: 'doubleJump'
            },
            abyss: {
                id: 'abyss',
                name: 'Demon Horn',
                icon: 'ðŸ˜ˆ',
                mapId: 'abyss',
                desc: 'Below 30% HP: +50% damage, attacks ignite enemies',
                effect: 'demonRage'
            },
            // ===== QUEST-EXCLUSIVE RELICS =====
            warrior: {
                id: 'warrior',
                name: 'Warrior\'s Medallion',
                icon: 'ðŸ…',
                desc: 'Each kill grants +5% damage for 5 seconds (stacks up to 50%)',
                effect: 'killStreak'
            },
            hunter: {
                id: 'hunter',
                name: 'Hunter\'s Mark',
                icon: 'ðŸŽ¯',
                desc: 'Killing an enemy grants +30% move speed for 3 seconds',
                effect: 'hunterSpeed'
            },
            berserker: {
                id: 'berserker',
                name: 'Berserker\'s Fang',
                icon: 'ðŸ¦·',
                desc: 'Attack speed increases as HP decreases (up to +40%)',
                effect: 'berserkerFury'
            },
            guardian: {
                id: 'guardian',
                name: 'Guardian\'s Aegis',
                icon: 'ðŸ›¡ï¸',
                desc: '15% chance to completely block incoming damage',
                effect: 'guardianBlock'
            },
            assassin: {
                id: 'assassin',
                name: 'Shadow Blade',
                icon: 'ðŸ—¡ï¸',
                desc: 'First hit on each enemy deals double damage',
                effect: 'firstStrike'
            },
            titan: {
                id: 'titan',
                name: 'Titan\'s Might',
                icon: 'ðŸ’ª',
                desc: 'Attacks knock enemies back further and stun briefly',
                effect: 'titanKnockback'
            },
            phoenix: {
                id: 'phoenix',
                name: 'Phoenix Plume',
                icon: 'ðŸ”¥',
                desc: 'Revive once per game with 30% HP when killed',
                effect: 'phoenixRevive'
            },
            vampire: {
                id: 'vampire',
                name: 'Blood Chalice',
                icon: 'ðŸ©¸',
                desc: 'Gain 8% of damage dealt as health',
                effect: 'vampireLifesteal'
            },
            thunder: {
                id: 'thunder',
                name: 'Storm Rune',
                icon: 'âš¡',
                desc: 'Attacks chain lightning to 2 nearby enemies for 50% damage',
                effect: 'chainLightning'
            },
            earth: {
                id: 'earth',
                name: 'Stone Heart',
                icon: 'ðŸª¨',
                desc: 'Take 20% less damage from all sources',
                effect: 'damageReduction'
            },
            wind: {
                id: 'wind',
                name: 'Gale Boots',
                icon: 'ðŸ’¨',
                desc: '+25% movement speed permanently',
                effect: 'windSpeed'
            },
            temporal: {
                id: 'temporal',
                name: 'Temporal Gem',
                icon: 'â°',
                desc: 'When hit, slow all enemies by 50% for 2 seconds (10s cooldown)',
                effect: 'timeSlowOnHit'
            },
            fortune: {
                id: 'fortune',
                name: 'Fortune\'s Favor',
                icon: 'ðŸ€',
                desc: 'Upgrade cards have +15% chance to be rare or legendary',
                effect: 'betterCards'
            },
            fury: {
                id: 'fury',
                name: 'Rage Emblem',
                icon: 'ðŸ˜¤',
                desc: 'Taking damage grants +30% attack speed for 4 seconds',
                effect: 'furyOnHit'
            },
            dragonscale: {
                id: 'dragonscale',
                name: 'Dragon Scale',
                icon: 'ðŸ²',
                desc: 'Immune to fire damage, attacks deal bonus fire damage',
                effect: 'dragonPower'
            }
        };

        // Track unlocked and active relics
        let unlockedRelics = JSON.parse(localStorage.getItem('samuraiUnlockedRelics')) || [];
        let activeRelics = JSON.parse(localStorage.getItem('samuraiActiveRelics')) || [];
        const MAX_ACTIVE_RELICS = 3;
        const RELIC_XP_PENALTY = 0.15; // 15% XP reduction per active relic

        function saveRelics() {
            localStorage.setItem('samuraiUnlockedRelics', JSON.stringify(unlockedRelics));
            localStorage.setItem('samuraiActiveRelics', JSON.stringify(activeRelics));
        }

        function unlockRelic(mapId) {
            if (!unlockedRelics.includes(mapId)) {
                unlockedRelics.push(mapId);
                // Auto-activate if under limit
                if (activeRelics.length < MAX_ACTIVE_RELICS) {
                    activeRelics.push(mapId);
                }
                saveRelics();
                return relics[mapId];
            }
            return null;
        }

        function hasRelic(relicId) {
            return activeRelics.includes(relicId); // Only active relics have effects
        }

        function isRelicUnlocked(relicId) {
            return unlockedRelics.includes(relicId);
        }

        function toggleRelic(relicId) {
            if (!unlockedRelics.includes(relicId)) return false;

            if (activeRelics.includes(relicId)) {
                // Deactivate
                activeRelics = activeRelics.filter(r => r !== relicId);
                saveRelics();
                return true;
            } else {
                // Activate if under limit
                if (activeRelics.length < MAX_ACTIVE_RELICS) {
                    activeRelics.push(relicId);
                    saveRelics();
                    return true;
                }
                return false; // Can't activate, at max
            }
        }

        function getActiveRelicCount() {
            return activeRelics.length;
        }

        function getXPMultiplier() {
            // Each active relic reduces XP by 15%
            return Math.max(0.1, 1 - (activeRelics.length * RELIC_XP_PENALTY));
        }

        // Relic effect state variables
        let deathSaveUsedThisWave = false;
        let isInvisible = false;
        let invisibilityTimer = 0;
        let ghostAllies = [];
        let hasDoubleJumped = false;

        // New quest relic effect variables
        let killStreakStacks = 0;
        let killStreakTimer = 0;
        let hunterSpeedTimer = 0;
        let phoenixReviveUsed = false;
        let temporalSlowCooldown = 0;
        let furyAttackSpeedTimer = 0;
        let enemiesFirstHit = new Set(); // Track which enemies have been hit for assassin relic

        // ========== QUEST SYSTEM ==========
        const ALL_QUESTS = [
            // Kill count quests
            { id: 'q1', name: 'First Blood', icon: 'âš”ï¸', objective: 'Kill 25 enemies in a single game', type: 'kills', target: 25, reward: { relic: 'warrior', xp: 100 } },
            { id: 'q2', name: 'Warrior\'s Path', icon: 'ðŸ—¡ï¸', objective: 'Kill 50 enemies in a single game', type: 'kills', target: 50, reward: { relic: 'hunter', xp: 150 } },
            { id: 'q3', name: 'Slaughter', icon: 'ðŸ’€', objective: 'Kill 100 enemies in a single game', type: 'kills', target: 100, reward: { relic: 'berserker', xp: 200 } },
            { id: 'q4', name: 'Massacre', icon: 'â˜ ï¸', objective: 'Kill 200 enemies in a single game', type: 'kills', target: 200, reward: { relic: 'titan', xp: 300 } },

            // Wave progression quests
            { id: 'q5', name: 'Survivor', icon: 'ðŸ›¡ï¸', objective: 'Reach wave 5', type: 'wave', target: 5, reward: { relic: 'forest', xp: 100 } },
            { id: 'q6', name: 'Endurance', icon: 'ðŸƒ', objective: 'Reach wave 10', type: 'wave', target: 10, reward: { relic: 'frost', xp: 150 } },
            { id: 'q7', name: 'Veteran', icon: 'ðŸŽ–ï¸', objective: 'Reach wave 20', type: 'wave', target: 20, reward: { relic: 'crystal', xp: 250 } },
            { id: 'q8', name: 'Legend', icon: 'ðŸ‘‘', objective: 'Reach wave 30 (Victory)', type: 'wave', target: 30, reward: { relic: 'abyss', xp: 300 } },

            // Damage quests
            { id: 'q9', name: 'Heavy Hitter', icon: 'ðŸ’ª', objective: 'Deal 500 total damage', type: 'damage', target: 500, reward: { relic: 'guardian', xp: 150 } },
            { id: 'q10', name: 'Devastator', icon: 'ðŸ’¥', objective: 'Deal 1500 total damage', type: 'damage', target: 1500, reward: { relic: 'thunder', xp: 250 } },

            // Dodge quests
            { id: 'q11', name: 'Nimble', icon: 'ðŸ’¨', objective: 'Dodge 15 times in one game', type: 'dodges', target: 15, reward: { relic: 'shadow', xp: 150 } },
            { id: 'q12', name: 'Untouchable', icon: 'ðŸ‘»', objective: 'Dodge 30 times in one game', type: 'dodges', target: 30, reward: { relic: 'wind', xp: 200 } },

            // No damage quests
            { id: 'q13', name: 'Flawless Wave', icon: 'âœ¨', objective: 'Complete a wave without taking damage', type: 'flawlessWave', target: 1, reward: { relic: 'earth', xp: 150 } },
            { id: 'q14', name: 'Perfect Run', icon: 'ðŸŒŸ', objective: 'Complete 3 waves without taking damage', type: 'flawlessWaves', target: 3, reward: { relic: 'temporal', xp: 250 } },

            // Quick kills
            { id: 'q15', name: 'Swift Death', icon: 'âš¡', objective: 'Kill 3 enemies within 2 seconds', type: 'quickKills', target: 3, reward: { relic: 'assassin', xp: 150 } },
            { id: 'q16', name: 'Lightning Reflexes', icon: 'ðŸŒ©ï¸', objective: 'Kill 5 enemies within 3 seconds', type: 'quickKills5', target: 5, reward: { relic: 'fury', xp: 200 } },

            // Survival quests
            { id: 'q17', name: 'Close Call', icon: 'ðŸ’”', objective: 'Win a game with less than 20% HP', type: 'lowHPWin', target: 20, reward: { relic: 'desert', xp: 200 } },
            { id: 'q18', name: 'Tank', icon: 'ðŸ›¡ï¸', objective: 'Take 300 damage and survive the game', type: 'damageTaken', target: 300, reward: { relic: 'phoenix', xp: 200 } },

            // Character-specific quests
            { id: 'q19', name: 'Way of the Samurai', icon: 'ðŸŽŒ', objective: 'Kill 40 enemies as Samurai', type: 'charKills', char: 'standard', target: 40, reward: { relic: 'graveyard', xp: 150 } },
            { id: 'q20', name: 'Knight\'s Honor', icon: 'ðŸ°', objective: 'Kill 40 enemies as Knight', type: 'charKills', char: 'knight', target: 40, reward: { relic: 'volcano', xp: 150 } },
            { id: 'q21', name: 'Archer\'s Precision', icon: 'ðŸŽ¯', objective: 'Kill 40 enemies as Archer', type: 'charKills', char: 'archer', target: 40, reward: { relic: 'sky', xp: 150 } },
            { id: 'q22', name: 'Pikeman\'s Reach', icon: 'ðŸ”±', objective: 'Kill 40 enemies as Pikeman', type: 'charKills', char: 'pikeman', target: 40, reward: { relic: 'swamp', xp: 150 } },

            // Upgrade card quests
            { id: 'q23', name: 'Collector', icon: 'ðŸƒ', objective: 'Choose 5 upgrade cards in one game', type: 'cards', target: 5, reward: { relic: 'fortune', xp: 150 } },
            { id: 'q24', name: 'Power Builder', icon: 'ðŸ“ˆ', objective: 'Choose 10 upgrade cards in one game', type: 'cards', target: 10, reward: { relic: 'vampire', xp: 200 } },

            // Boss quest
            { id: 'q25', name: 'Dragon Slayer', icon: 'ðŸ‰', objective: 'Defeat the Dragon Boss', type: 'dragonKill', target: 1, reward: { relic: 'dragonscale', xp: 300 } }
        ];

        // Quest state
        let activeQuest = JSON.parse(localStorage.getItem('samuraiActiveQuest')) || null;
        let questProgress = JSON.parse(localStorage.getItem('samuraiQuestProgress')) || {};
        let currentQuestSelection = JSON.parse(localStorage.getItem('samuraiQuestSelection')) || [];
        let completedQuests = JSON.parse(localStorage.getItem('samuraiCompletedQuests')) || [];
        let questRefreshes = parseInt(localStorage.getItem('samuraiQuestRefreshes')) || 1; // Start with 1 free refresh

        // Quest tracking variables (reset each game)
        let questKills = 0;
        let questDamageDealt = 0;
        let questDodges = 0;
        let questFlawlessWaves = 0;
        let questCurrentWaveFlawless = true;
        let questDamageTaken = 0;
        let questCardsChosen = 0;
        let questQuickKillTimes = [];
        let questCharKills = {};

        function saveQuestState() {
            localStorage.setItem('samuraiActiveQuest', JSON.stringify(activeQuest));
            localStorage.setItem('samuraiQuestProgress', JSON.stringify(questProgress));
            localStorage.setItem('samuraiQuestSelection', JSON.stringify(currentQuestSelection));
            localStorage.setItem('samuraiCompletedQuests', JSON.stringify(completedQuests));
            localStorage.setItem('samuraiQuestRefreshes', questRefreshes.toString());
        }

        function useQuestRefresh() {
            if (questRefreshes <= 0) return false;
            questRefreshes--;
            generateQuestSelection();
            saveQuestState();
            updateQuestUI();
            return true;
        }

        function generateQuestSelection() {
            // Get 3 random quests that haven't been completed
            const availableQuests = ALL_QUESTS.filter(q => !completedQuests.includes(q.id));
            const shuffled = availableQuests.sort(() => Math.random() - 0.5);
            currentQuestSelection = shuffled.slice(0, 3).map(q => q.id);
            saveQuestState();
            return currentQuestSelection;
        }

        function acceptQuest(questId) {
            if (activeQuest) return false; // Can only have one active quest
            const quest = ALL_QUESTS.find(q => q.id === questId);
            if (!quest) return false;

            activeQuest = questId;
            questProgress = { current: 0, target: quest.target };
            saveQuestState();
            updateQuestUI();
            return true;
        }

        function abandonQuest() {
            activeQuest = null;
            questProgress = {};
            saveQuestState();
            updateQuestUI();
        }

        function resetQuestTracking() {
            questKills = 0;
            questDamageDealt = 0;
            questDodges = 0;
            questFlawlessWaves = 0;
            questCurrentWaveFlawless = true;
            questDamageTaken = 0;
            questCardsChosen = 0;
            questQuickKillTimes = [];
            questCharKills = {};
        }

        function trackQuestKill(charType) {
            if (!activeQuest) return;
            const quest = ALL_QUESTS.find(q => q.id === activeQuest);
            if (!quest) return;

            questKills++;
            questQuickKillTimes.push(Date.now());
            // Keep only kills from last 3 seconds
            const now = Date.now();
            questQuickKillTimes = questQuickKillTimes.filter(t => now - t < 3000);

            if (!questCharKills[charType]) questCharKills[charType] = 0;
            questCharKills[charType]++;

            updateQuestProgress();
        }

        function trackQuestDamage(amount) {
            if (!activeQuest) return;
            questDamageDealt += amount;
            updateQuestProgress();
        }

        function trackQuestDodge() {
            if (!activeQuest) return;
            questDodges++;
            updateQuestProgress();
        }

        function trackQuestDamageTaken(amount) {
            if (!activeQuest) return;
            questDamageTaken += amount;
            questCurrentWaveFlawless = false;
            updateQuestProgress();
        }

        function trackQuestWaveComplete(waveNum) {
            if (!activeQuest) return;
            if (questCurrentWaveFlawless) {
                questFlawlessWaves++;
            }
            questCurrentWaveFlawless = true; // Reset for next wave
            updateQuestProgress();
        }

        function trackQuestCardChosen() {
            if (!activeQuest) return;
            questCardsChosen++;
            updateQuestProgress();
        }

        function updateQuestProgress() {
            if (!activeQuest) return;
            const quest = ALL_QUESTS.find(q => q.id === activeQuest);
            if (!quest) return;

            let current = 0;
            switch (quest.type) {
                case 'kills':
                    current = questKills;
                    break;
                case 'wave':
                    current = currentWave || 0;
                    break;
                case 'damage':
                    current = questDamageDealt;
                    break;
                case 'dodges':
                    current = questDodges;
                    break;
                case 'flawlessWave':
                case 'flawlessWaves':
                    current = questFlawlessWaves;
                    break;
                case 'quickKills':
                    const recentKills3 = questQuickKillTimes.filter(t => Date.now() - t < 2000).length;
                    current = recentKills3 >= quest.target ? quest.target : 0;
                    break;
                case 'quickKills5':
                    const recentKills5 = questQuickKillTimes.filter(t => Date.now() - t < 3000).length;
                    current = recentKills5 >= quest.target ? quest.target : 0;
                    break;
                case 'damageTaken':
                    current = questDamageTaken;
                    break;
                case 'charKills':
                    current = questCharKills[quest.char] || 0;
                    break;
                case 'cards':
                    current = questCardsChosen;
                    break;
                case 'dragonKill':
                    // Will be set to 1 when dragon is killed
                    current = questProgress.current || 0;
                    break;
                case 'lowHPWin':
                    // Checked at game win
                    current = questProgress.current || 0;
                    break;
            }

            questProgress.current = current;
            saveQuestState();
            updateQuestHUD();

            // Check completion
            if (current >= quest.target) {
                completeQuest();
            }
        }

        function completeQuest() {
            if (!activeQuest) return;
            const quest = ALL_QUESTS.find(q => q.id === activeQuest);
            if (!quest) return;

            // Award relic
            const relicId = quest.reward.relic;
            const newRelic = unlockRelic(relicId);

            // Award XP to current character
            const xpGain = quest.reward.xp;
            if (selectedChar && charXP[selectedChar] !== undefined) {
                charXP[selectedChar] += xpGain;
                saveXP();
            }

            // Mark quest as completed
            completedQuests.push(activeQuest);

            // Grant a quest refresh
            questRefreshes++;

            // Show completion message
            const relicInfo = relics[relicId];
            alert(`Quest Complete: ${quest.name}!\n\nReward:\nâ€¢ ${relicInfo.icon} ${relicInfo.name} (Relic)\nâ€¢ +${xpGain} XP\nâ€¢ +1 Quest Refresh`);

            // Clear active quest
            activeQuest = null;
            questProgress = {};

            // Generate new selection
            generateQuestSelection();
            saveQuestState();
            updateQuestUI();
        }

        function updateQuestHUD() {
            const hud = document.getElementById('activeQuestHUD');
            if (!hud) return;

            if (!activeQuest) {
                hud.classList.remove('visible');
                return;
            }

            const quest = ALL_QUESTS.find(q => q.id === activeQuest);
            if (!quest) return;

            hud.classList.add('visible');
            hud.querySelector('.quest-hud-name').textContent = `${quest.icon} ${quest.name}`;
            hud.querySelector('.quest-hud-progress').textContent = `${questProgress.current || 0} / ${quest.target}`;
        }

        function updateQuestUI() {
            const container = document.getElementById('questCardsContainer');
            const activeDisplay = document.getElementById('questActiveDisplay');
            const refreshBtn = document.getElementById('questRefreshBtn');
            if (!container) return;

            // Update refresh button
            if (refreshBtn) {
                refreshBtn.textContent = `ðŸ”„ Refresh (${questRefreshes})`;
                refreshBtn.disabled = questRefreshes <= 0;
                refreshBtn.style.opacity = questRefreshes <= 0 ? '0.5' : '1';
                refreshBtn.style.cursor = questRefreshes <= 0 ? 'not-allowed' : 'pointer';
            }

            // Update active quest display
            if (activeQuest) {
                const quest = ALL_QUESTS.find(q => q.id === activeQuest);
                activeDisplay.innerHTML = `Active: <strong>${quest.icon} ${quest.name}</strong> (${questProgress.current || 0}/${quest.target})<br><button onclick="abandonQuest()" style="margin-top:5px;padding:5px 10px;background:#662222;border:1px solid #aa4444;color:#ff6666;border-radius:4px;cursor:pointer;">Abandon Quest</button>`;
                activeDisplay.classList.add('has-quest');
            } else {
                activeDisplay.textContent = 'No active quest - Choose one below!';
                activeDisplay.classList.remove('has-quest');
            }

            // Generate selection if empty
            if (currentQuestSelection.length === 0) {
                generateQuestSelection();
            }

            container.innerHTML = '';
            currentQuestSelection.forEach(questId => {
                const quest = ALL_QUESTS.find(q => q.id === questId);
                if (!quest) return;

                const relicInfo = relics[quest.reward.relic];
                const isLocked = activeQuest !== null;
                const isCompleted = completedQuests.includes(questId);

                const card = document.createElement('div');
                card.className = 'quest-card' + (isLocked ? ' locked' : '');
                card.innerHTML = `
                    <div class="quest-icon">${quest.icon}</div>
                    <div class="quest-name">${quest.name}</div>
                    <div class="quest-objective">${quest.objective}</div>
                    <div class="quest-reward">
                        <div class="quest-reward-title">REWARD</div>
                        <div class="quest-reward-relic">${relicInfo.icon} ${relicInfo.name}</div>
                        <div class="quest-reward-xp">+${quest.reward.xp} XP</div>
                    </div>
                    <button class="quest-accept-btn" ${isLocked || isCompleted ? 'disabled' : ''} onclick="acceptQuest('${quest.id}')">${isCompleted ? 'Completed' : 'Accept'}</button>
                `;
                container.appendChild(card);
            });
        }

        function openQuestOverlay() {
            document.getElementById('questOverlay').classList.remove('hidden');
            updateQuestUI();
        }

        function closeQuestOverlay() {
            document.getElementById('questOverlay').classList.add('hidden');
        }

        // Map unlock order - beat one to unlock the next
        const mapOrder = ['forest', 'desert', 'volcano', 'frost', 'swamp', 'shadow', 'crystal', 'graveyard', 'sky', 'abyss'];
        let unlockedMaps = JSON.parse(localStorage.getItem('samuraiUnlockedMaps')) || ['forest'];
        let selectedMap = localStorage.getItem('samuraiSelectedMap') || 'forest';

        function saveMapUnlocks() {
            localStorage.setItem('samuraiUnlockedMaps', JSON.stringify(unlockedMaps));
            localStorage.setItem('samuraiSelectedMap', selectedMap);
        }

        function unlockNextMap(currentMapId) {
            const currentIndex = mapOrder.indexOf(currentMapId);
            if (currentIndex >= 0 && currentIndex < mapOrder.length - 1) {
                const nextMapId = mapOrder[currentIndex + 1];
                if (!unlockedMaps.includes(nextMapId)) {
                    unlockedMaps.push(nextMapId);
                    saveMapUnlocks();
                    return nextMapId;
                }
            }
            return null;
        }

        let currentMapId = 'forest';
        let currentMap = gameMaps.forest;
        let environmentObjects = []; // Track objects to remove when changing maps

        // Enemy type translation for themed maps
        // Maps base enemy types to map-specific versions
        const enemyTypeTranslation = {
            desert: {
                ashigaru: 'bandit',
                ronin: 'desert_warrior',
                oni: 'sandOni'
            },
            volcano: {
                ashigaru: 'fireImp',
                ronin: 'ashWraith',
                scout: 'fireImp',
                brute: 'lavaGolem',
                oni: 'infernoOni'
            },
            frost: {
                ashigaru: 'frostWarrior',
                ronin: 'frostWarrior',
                archer: 'iceArcher',
                scout: 'frostNinja',
                brute: 'snowBrute',
                oni: 'iceOni'
            },
            swamp: {
                ashigaru: 'swampZombie',
                ronin: 'mireCreeper',
                archer: 'bogWitch',
                scout: 'mireCreeper',
                brute: 'plagueBearer',
                oni: 'swampOni'
            },
            shadow: {
                ashigaru: 'shadowWraith',
                ronin: 'voidStalker',
                archer: 'shadowWraith',
                scout: 'shadowNinja',
                brute: 'darkKnight',
                oni: 'shadowOni'
            },
            crystal: {
                ashigaru: 'gemSprite',
                ronin: 'caveHunter',
                archer: 'crystalArcher',
                scout: 'gemSprite',
                brute: 'crystalGolem',
                oni: 'crystalOni'
            },
            graveyard: {
                ashigaru: 'skeleton',
                ronin: 'ghoul',
                archer: 'ghost',
                scout: 'ghost',
                brute: 'ghoul',
                oni: 'graveOni'
            },
            sky: {
                ashigaru: 'templeMonk',
                ronin: 'skyGuardian',
                archer: 'stormArcher',
                scout: 'cloudNinja',
                brute: 'skyGuardian',
                oni: 'skyOni'
            },
            abyss: {
                ashigaru: 'hellSpawn',
                ronin: 'demonGuard',
                archer: 'hellArcher',
                scout: 'hellSpawn',
                brute: 'abyssalKnight',
                oni: 'abyssOni'
            }
        };

        // Translates an enemy type based on current map
        function getThemedEnemyType(baseType) {
            // Bosses stay the same on all maps
            const bosses = ['knight', 'tengu', 'yokai', 'dragon'];
            if (bosses.includes(baseType)) {
                return baseType;
            }

            // Forest uses default enemies
            if (currentMapId === 'forest') {
                return baseType;
            }

            // Check if there's a translation for this enemy type on current map
            const mapTranslations = enemyTypeTranslation[currentMapId];
            if (mapTranslations && mapTranslations[baseType]) {
                return mapTranslations[baseType];
            }

            // No translation, use base type
            return baseType;
        }
        let groundMesh = null;
        let gridMesh = null;

        // Camera setup
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 100, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        scene.add(directionalLight);

        // Ground (created by map system)
        const groundGeometry = new THREE.PlaneGeometry(200, 200);
        let groundMaterial = new THREE.MeshStandardMaterial({
            color: currentMap.groundColor,
            roughness: 0.9,
            metalness: 0.0
        });
        groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);

        // Grid for visual reference
        gridMesh = new THREE.GridHelper(200, 40, currentMap.gridColor, currentMap.gridColor);
        gridMesh.position.y = 0.01;
        scene.add(gridMesh);

        // Spawn beam at center of map
        let spawnBeam = null;
        let spawnBeamGlow = null;
        function createSpawnBeam() {
            // Main beam cylinder
            const beamGeo = new THREE.CylinderGeometry(0.5, 0.5, 100, 16);
            const beamMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.3
            });
            spawnBeam = new THREE.Mesh(beamGeo, beamMat);
            spawnBeam.position.set(0, 50, 0);
            scene.add(spawnBeam);

            // Inner glow beam
            const glowGeo = new THREE.CylinderGeometry(0.2, 0.2, 100, 8);
            const glowMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.6
            });
            spawnBeamGlow = new THREE.Mesh(glowGeo, glowMat);
            spawnBeamGlow.position.set(0, 50, 0);
            scene.add(spawnBeamGlow);

            // Base ring
            const ringGeo = new THREE.TorusGeometry(2, 0.2, 8, 32);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            const baseRing = new THREE.Mesh(ringGeo, ringMat);
            baseRing.rotation.x = Math.PI / 2;
            baseRing.position.set(0, 0.1, 0);
            scene.add(baseRing);
            spawnBeam.baseRing = baseRing;
        }
        createSpawnBeam();

        // Animals system
        const animals = [];
        const animalTypes = ['rabbit', 'deer', 'bird', 'fox'];

        function createAnimal(type) {
            const animal = new THREE.Group();
            let animalData = { type: type, speed: 2, mesh: animal };

            if (type === 'rabbit') {
                // Small rabbit
                const bodyGeo = new THREE.SphereGeometry(0.3, 8, 6);
                const bodyMat = new THREE.MeshLambertMaterial({ color: 0xccaa88 });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = 0.3;
                body.scale.set(1, 0.8, 1.2);
                animal.add(body);
                // Head
                const headGeo = new THREE.SphereGeometry(0.2, 8, 6);
                const head = new THREE.Mesh(headGeo, bodyMat);
                head.position.set(0, 0.45, 0.25);
                animal.add(head);
                // Ears
                const earGeo = new THREE.BoxGeometry(0.06, 0.25, 0.04);
                const ear1 = new THREE.Mesh(earGeo, bodyMat);
                ear1.position.set(-0.08, 0.7, 0.2);
                animal.add(ear1);
                const ear2 = ear1.clone();
                ear2.position.x = 0.08;
                animal.add(ear2);
                animalData.speed = 4;
            } else if (type === 'deer') {
                // Deer body
                const bodyGeo = new THREE.BoxGeometry(0.5, 0.6, 1);
                const bodyMat = new THREE.MeshLambertMaterial({ color: 0x8b6914 });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = 0.8;
                animal.add(body);
                // Head
                const headGeo = new THREE.BoxGeometry(0.25, 0.3, 0.4);
                const head = new THREE.Mesh(headGeo, bodyMat);
                head.position.set(0, 1.1, 0.6);
                animal.add(head);
                // Legs
                const legGeo = new THREE.BoxGeometry(0.1, 0.5, 0.1);
                const legMat = new THREE.MeshLambertMaterial({ color: 0x6b4914 });
                for (let i = 0; i < 4; i++) {
                    const leg = new THREE.Mesh(legGeo, legMat);
                    leg.position.set((i % 2 === 0 ? -0.15 : 0.15), 0.25, (i < 2 ? 0.35 : -0.35));
                    animal.add(leg);
                }
                animalData.speed = 3;
            } else if (type === 'bird') {
                // Bird body
                const bodyGeo = new THREE.SphereGeometry(0.15, 8, 6);
                const bodyMat = new THREE.MeshLambertMaterial({ color: 0x4488ff });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = 2;
                body.scale.set(1, 0.8, 1.3);
                animal.add(body);
                // Wings
                const wingGeo = new THREE.BoxGeometry(0.4, 0.02, 0.15);
                const wing1 = new THREE.Mesh(wingGeo, bodyMat);
                wing1.position.set(-0.2, 2, 0);
                animal.add(wing1);
                const wing2 = wing1.clone();
                wing2.position.x = 0.2;
                animal.add(wing2);
                animalData.speed = 5;
                animalData.flying = true;
            } else if (type === 'fox') {
                // Fox body
                const bodyGeo = new THREE.BoxGeometry(0.35, 0.35, 0.7);
                const bodyMat = new THREE.MeshLambertMaterial({ color: 0xff6600 });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = 0.4;
                animal.add(body);
                // Head
                const headGeo = new THREE.BoxGeometry(0.25, 0.2, 0.3);
                const head = new THREE.Mesh(headGeo, bodyMat);
                head.position.set(0, 0.5, 0.4);
                animal.add(head);
                // Tail
                const tailGeo = new THREE.BoxGeometry(0.15, 0.15, 0.5);
                const tailMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
                const tail = new THREE.Mesh(tailGeo, tailMat);
                tail.position.set(0, 0.4, -0.5);
                tail.rotation.x = 0.3;
                animal.add(tail);
                animalData.speed = 3.5;
            }

            // Random spawn position (away from center)
            const angle = Math.random() * Math.PI * 2;
            const dist = 20 + Math.random() * 30;
            animal.position.set(Math.cos(angle) * dist, 0, Math.sin(angle) * dist);

            animalData.targetX = animal.position.x;
            animalData.targetZ = animal.position.z;
            animalData.wanderTimer = Math.random() * 5;

            // Add health for hunting
            animalData.health = type === 'deer' ? 20 : type === 'fox' ? 15 : type === 'bird' ? 5 : 10;
            animalData.foodAmount = type === 'deer' ? 5 : type === 'fox' ? 3 : type === 'bird' ? 1 : 2;

            scene.add(animal);
            return animalData;
        }

        function spawnAnimals(count = 5) {
            for (let i = 0; i < count; i++) {
                const type = animalTypes[Math.floor(Math.random() * animalTypes.length)];
                animals.push(createAnimal(type));
            }
        }

        function updateAnimals(deltaTime) {
            for (const animal of animals) {
                // Update wander timer
                animal.wanderTimer -= deltaTime;
                if (animal.wanderTimer <= 0) {
                    // Pick new target
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 5 + Math.random() * 15;
                    animal.targetX = animal.mesh.position.x + Math.cos(angle) * dist;
                    animal.targetZ = animal.mesh.position.z + Math.sin(angle) * dist;
                    // Keep in bounds
                    animal.targetX = Math.max(-80, Math.min(80, animal.targetX));
                    animal.targetZ = Math.max(-80, Math.min(80, animal.targetZ));
                    animal.wanderTimer = 3 + Math.random() * 5;
                }

                // Move toward target
                const dx = animal.targetX - animal.mesh.position.x;
                const dz = animal.targetZ - animal.mesh.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist > 0.5) {
                    animal.mesh.position.x += (dx / dist) * animal.speed * deltaTime;
                    animal.mesh.position.z += (dz / dist) * animal.speed * deltaTime;
                    // Face movement direction
                    animal.mesh.rotation.y = Math.atan2(dx, dz);
                }

                // Birds bob up and down
                if (animal.flying) {
                    animal.mesh.position.y = 2 + Math.sin(Date.now() * 0.003) * 0.5;
                }
            }
        }

        function clearAnimals() {
            for (const animal of animals) {
                scene.remove(animal.mesh);
            }
            animals.length = 0;
        }

        // Function to apply map theme
        function applyMapTheme(mapId) {
            currentMapId = mapId;
            currentMap = gameMaps[mapId];

            // Update sky
            scene.background = new THREE.Color(currentMap.skyColor);

            // Update ground
            groundMesh.material.color.setHex(currentMap.groundColor);

            // Update grid
            scene.remove(gridMesh);
            gridMesh = new THREE.GridHelper(200, 40, currentMap.gridColor, currentMap.gridColor);
            gridMesh.position.y = 0.01;
            scene.add(gridMesh);

            // Update lighting
            ambientLight.intensity = currentMap.ambientIntensity;
            directionalLight.color.setHex(currentMap.lightColor);
        }

        // ========== OBSTACLES SYSTEM ==========
        const obstacles = [];

        // Lake definition
        const lake = {
            x: -30,
            z: 25,
            radiusX: 18,
            radiusZ: 14,
            speedReduction: 0.4 // 40% speed in water
        };

        // Create the lake (uses current map colors)
        function createLake() {
            // Water surface (or lava in volcano map)
            const waterMat = new THREE.MeshStandardMaterial({
                color: currentMap.lake.color,
                roughness: currentMapId === 'volcano' ? 0.3 : 0.1,
                metalness: currentMapId === 'volcano' ? 0.1 : 0.3,
                transparent: true,
                opacity: currentMapId === 'volcano' ? 0.9 : 0.7,
                emissive: currentMapId === 'volcano' ? 0xff2200 : 0x000000,
                emissiveIntensity: currentMapId === 'volcano' ? 0.5 : 0
            });

            const waterGeo = new THREE.BoxGeometry(lake.radiusX * 2, 0.3, lake.radiusZ * 2);
            const water = new THREE.Mesh(waterGeo, waterMat);
            water.position.set(lake.x, -0.1, lake.z);
            water.receiveShadow = true;
            scene.add(water);
            environmentObjects.push(water);

            // Darker bottom
            const bottomMat = new THREE.MeshStandardMaterial({
                color: currentMap.lake.bottomColor,
                roughness: 0.9
            });
            const bottomGeo = new THREE.BoxGeometry(lake.radiusX * 2 - 1, 0.1, lake.radiusZ * 2 - 1);
            const bottom = new THREE.Mesh(bottomGeo, bottomMat);
            bottom.position.set(lake.x, -0.4, lake.z);
            scene.add(bottom);
            environmentObjects.push(bottom);

            // Shore/edge rocks around lake
            const shoreMat = new THREE.MeshStandardMaterial({ color: currentMap.rockColor, roughness: 0.9 });
            for (let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 2;
                const rx = lake.radiusX + Math.random() * 2;
                const rz = lake.radiusZ + Math.random() * 2;
                const sx = lake.x + Math.cos(angle) * rx;
                const sz = lake.z + Math.sin(angle) * rz;

                const shoreGeo = new THREE.BoxGeometry(
                    1 + Math.random() * 1.5,
                    0.3 + Math.random() * 0.3,
                    1 + Math.random() * 1.5
                );
                const shore = new THREE.Mesh(shoreGeo, shoreMat);
                shore.position.set(sx, 0.1, sz);
                shore.rotation.y = Math.random() * Math.PI;
                shore.castShadow = true;
                scene.add(shore);
                environmentObjects.push(shore);
            }

            // Some lily pads (not in volcano - they'd burn in lava!)
            if (currentMapId !== 'volcano') {
                const lilyMat = new THREE.MeshStandardMaterial({ color: currentMap.treeColors.leaves, roughness: 0.8 });
                for (let i = 0; i < 8; i++) {
                    const lx = lake.x + (Math.random() - 0.5) * lake.radiusX * 1.5;
                    const lz = lake.z + (Math.random() - 0.5) * lake.radiusZ * 1.5;
                    const lilyGeo = new THREE.BoxGeometry(0.8 + Math.random() * 0.5, 0.05, 0.8 + Math.random() * 0.5);
                    const lily = new THREE.Mesh(lilyGeo, lilyMat);
                    lily.position.set(lx, 0.05, lz);
                    lily.rotation.y = Math.random() * Math.PI;
                    scene.add(lily);
                    environmentObjects.push(lily);
                }
            }
        }

        // Check if position is in water
        function isInWater(x, z) {
            const dx = (x - lake.x) / lake.radiusX;
            const dz = (z - lake.z) / lake.radiusZ;
            return (dx * dx + dz * dz) < 1;
        }

        // Create a rock
        function createRock(x, z, size = 1) {
            const rock = new THREE.Group();
            const rockMat = new THREE.MeshStandardMaterial({
                color: currentMap.rockColor,
                roughness: 0.9,
                metalness: 0.1
            });

            const mainGeo = new THREE.BoxGeometry(1.2 * size, 0.8 * size, 1.0 * size);
            const main = new THREE.Mesh(mainGeo, rockMat);
            main.position.y = 0.4 * size;
            main.rotation.y = Math.random() * Math.PI;
            main.castShadow = true;
            main.receiveShadow = true;
            rock.add(main);

            for (let i = 0; i < 3; i++) {
                const bumpGeo = new THREE.BoxGeometry(0.5 * size, 0.4 * size, 0.5 * size);
                const bump = new THREE.Mesh(bumpGeo, rockMat);
                bump.position.set(
                    (Math.random() - 0.5) * 0.8 * size,
                    0.6 * size,
                    (Math.random() - 0.5) * 0.8 * size
                );
                bump.rotation.set(Math.random() * 0.3, Math.random() * Math.PI, Math.random() * 0.3);
                bump.castShadow = true;
                rock.add(bump);
            }

            rock.position.set(x, 0, z);
            scene.add(rock);
            environmentObjects.push(rock);

            obstacles.push({
                mesh: rock,
                x: x,
                z: z,
                radius: 1.5 * size,
                height: 1.0 * size,
                type: 'rock'
            });

            return rock;
        }

        // Create a MASSIVE boulder
        function createBoulder(x, z, size = 3) {
            const boulder = new THREE.Group();
            const boulderMat = new THREE.MeshStandardMaterial({
                color: currentMap.rockColor,
                roughness: 0.95,
                metalness: 0.05
            });

            // Main massive body
            const mainGeo = new THREE.BoxGeometry(2.5 * size, 2.0 * size, 2.2 * size);
            const main = new THREE.Mesh(mainGeo, boulderMat);
            main.position.y = 1.0 * size;
            main.rotation.y = Math.random() * Math.PI;
            main.rotation.z = (Math.random() - 0.5) * 0.2;
            main.castShadow = true;
            main.receiveShadow = true;
            boulder.add(main);

            // Add large irregular chunks
            for (let i = 0; i < 6; i++) {
                const chunkGeo = new THREE.BoxGeometry(
                    (0.8 + Math.random() * 0.8) * size,
                    (0.6 + Math.random() * 0.6) * size,
                    (0.8 + Math.random() * 0.8) * size
                );
                const chunk = new THREE.Mesh(chunkGeo, boulderMat);
                chunk.position.set(
                    (Math.random() - 0.5) * 1.5 * size,
                    (0.8 + Math.random() * 1.2) * size,
                    (Math.random() - 0.5) * 1.5 * size
                );
                chunk.rotation.set(Math.random() * 0.4, Math.random() * Math.PI, Math.random() * 0.4);
                chunk.castShadow = true;
                boulder.add(chunk);
            }

            boulder.position.set(x, 0, z);
            scene.add(boulder);
            environmentObjects.push(boulder);

            obstacles.push({
                mesh: boulder,
                x: x,
                z: z,
                radius: 3.0 * size,
                height: 2.5 * size,
                type: 'boulder'
            });

            return boulder;
        }

        // Create a tree
        function createTree(x, z, size = 1) {
            const tree = new THREE.Group();

            const trunkMat = new THREE.MeshStandardMaterial({ color: currentMap.treeColors.trunk, roughness: 0.9 });
            const trunkGeo = new THREE.BoxGeometry(0.4 * size, 2.5 * size, 0.4 * size);
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 1.25 * size;
            trunk.castShadow = true;
            tree.add(trunk);

            const leavesMat = new THREE.MeshStandardMaterial({ color: currentMap.treeColors.leaves, roughness: 0.8 });

            const leaves1Geo = new THREE.BoxGeometry(2.0 * size, 1.0 * size, 2.0 * size);
            const leaves1 = new THREE.Mesh(leaves1Geo, leavesMat);
            leaves1.position.y = 2.5 * size;
            leaves1.castShadow = true;
            tree.add(leaves1);

            const leaves2Geo = new THREE.BoxGeometry(1.5 * size, 0.8 * size, 1.5 * size);
            const leaves2 = new THREE.Mesh(leaves2Geo, leavesMat);
            leaves2.position.y = 3.3 * size;
            leaves2.castShadow = true;
            tree.add(leaves2);

            const leaves3Geo = new THREE.BoxGeometry(0.8 * size, 0.6 * size, 0.8 * size);
            const leaves3 = new THREE.Mesh(leaves3Geo, leavesMat);
            leaves3.position.y = 3.9 * size;
            leaves3.castShadow = true;
            tree.add(leaves3);

            tree.position.set(x, 0, z);
            scene.add(tree);
            environmentObjects.push(tree);

            obstacles.push({
                mesh: tree,
                x: x,
                z: z,
                radius: 0.8 * size,
                height: 0.5 * size,
                type: 'tree',
                isBlocking: true
            });

            return tree;
        }

        // Create a GIANT tree
        function createGiantTree(x, z, size = 2.5) {
            const tree = new THREE.Group();

            const trunkMat = new THREE.MeshStandardMaterial({ color: currentMap.treeColors.trunk, roughness: 0.95 });

            // Thick trunk
            const trunkGeo = new THREE.BoxGeometry(1.2 * size, 6 * size, 1.2 * size);
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 3 * size;
            trunk.castShadow = true;
            tree.add(trunk);

            // Trunk roots
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const rootGeo = new THREE.BoxGeometry(0.5 * size, 1 * size, 1.5 * size);
                const root = new THREE.Mesh(rootGeo, trunkMat);
                root.position.set(Math.cos(angle) * 0.8 * size, 0.3 * size, Math.sin(angle) * 0.8 * size);
                root.rotation.y = angle;
                root.rotation.x = 0.3;
                root.castShadow = true;
                tree.add(root);
            }

            const leavesMat = new THREE.MeshStandardMaterial({ color: currentMap.treeColors.leaves, roughness: 0.85 });

            // Massive canopy layers
            const canopy1Geo = new THREE.BoxGeometry(5 * size, 2 * size, 5 * size);
            const canopy1 = new THREE.Mesh(canopy1Geo, leavesMat);
            canopy1.position.y = 5 * size;
            canopy1.castShadow = true;
            tree.add(canopy1);

            const canopy2Geo = new THREE.BoxGeometry(4 * size, 1.5 * size, 4 * size);
            const canopy2 = new THREE.Mesh(canopy2Geo, leavesMat);
            canopy2.position.y = 6.5 * size;
            canopy2.castShadow = true;
            tree.add(canopy2);

            const canopy3Geo = new THREE.BoxGeometry(2.5 * size, 1.2 * size, 2.5 * size);
            const canopy3 = new THREE.Mesh(canopy3Geo, leavesMat);
            canopy3.position.y = 7.8 * size;
            canopy3.castShadow = true;
            tree.add(canopy3);

            tree.position.set(x, 0, z);
            scene.add(tree);

            obstacles.push({
                mesh: tree,
                x: x,
                z: z,
                radius: 2.0 * size,
                height: 1.0 * size,
                type: 'giantTree',
                isBlocking: true
            });

            environmentObjects.push(tree);
            return tree;
        }

        // Create a small platform/stone
        function createPlatform(x, z, size = 1) {
            const platform = new THREE.Group();
            const platMat = new THREE.MeshStandardMaterial({
                color: currentMap.rockColor,
                roughness: 0.7,
                metalness: 0.2
            });

            const platGeo = new THREE.BoxGeometry(2.0 * size, 0.5 * size, 2.0 * size);
            const plat = new THREE.Mesh(platGeo, platMat);
            plat.position.y = 0.25 * size;
            plat.castShadow = true;
            plat.receiveShadow = true;
            platform.add(plat);

            platform.position.set(x, 0, z);
            scene.add(platform);

            obstacles.push({
                mesh: platform,
                x: x,
                z: z,
                radius: 1.2 * size,
                height: 0.5 * size,
                type: 'platform'
            });

            environmentObjects.push(platform);
            return platform;
        }

        // Create a log
        function createLog(x, z, rotation = 0) {
            const log = new THREE.Group();
            const logMat = new THREE.MeshStandardMaterial({ color: currentMap.treeColors.trunk, roughness: 0.9 });

            const logGeo = new THREE.BoxGeometry(3, 0.6, 0.6);
            const logMesh = new THREE.Mesh(logGeo, logMat);
            logMesh.position.y = 0.3;
            logMesh.castShadow = true;
            log.add(logMesh);

            log.position.set(x, 0, z);
            log.rotation.y = rotation;
            scene.add(log);

            obstacles.push({
                mesh: log,
                x: x,
                z: z,
                radius: 1.8,
                height: 0.6,
                type: 'log',
                rotation: rotation
            });

            environmentObjects.push(log);
            return log;
        }

        // Spawn obstacles around the arena
        function spawnObstacles() {
            // Create the lake first
            createLake();

            // MASSIVE BOULDERS
            createBoulder(35, -25, 3.5);
            createBoulder(-40, -35, 4.0);
            createBoulder(45, 30, 3.0);
            createBoulder(-35, 0, 3.2);

            // GIANT TREES
            createGiantTree(30, 35, 2.8);
            createGiantTree(-45, 20, 3.0);
            createGiantTree(40, -10, 2.5);
            createGiantTree(-30, -40, 2.7);
            createGiantTree(0, 40, 2.6);

            // Regular rocks
            createRock(-15, -15, 1.2);
            createRock(18, -12, 0.9);
            createRock(-20, 10, 1.0);
            createRock(12, 20, 1.3);
            createRock(25, 5, 1.1);
            createRock(8, -18, 0.7);

            // Regular trees
            createTree(-12, 15, 1.0);
            createTree(20, 18, 1.2);
            createTree(-22, -18, 0.9);
            createTree(15, -20, 1.1);
            createTree(25, -15, 0.8);
            createTree(10, 10, 1.1);

            // Trees around the lake
            createTree(-50, 30, 1.3);
            createTree(-15, 35, 1.1);
            createTree(-45, 15, 1.0);

            // Platforms
            createPlatform(0, 15, 1.0);
            createPlatform(0, -15, 0.8);
            createPlatform(15, 0, 0.9);
            createPlatform(-15, 0, 1.1);

            // Logs
            createLog(-5, 20, Math.PI / 4);
            createLog(22, 0, Math.PI / 2);
            createLog(-20, -20, 0);
            createLog(5, -25, Math.PI / 3);
        }

        // Spawn the obstacles
        spawnObstacles();

        // Function to clear and rebuild environment for new map
        function rebuildEnvironment() {
            // Remove all existing environment objects
            for (const obj of environmentObjects) {
                scene.remove(obj);
            }
            environmentObjects = [];

            // Clear obstacles array
            obstacles.length = 0;

            // Respawn obstacles with current map theme
            spawnObstacles();
        }

        // Check if position is on an obstacle (returns obstacle or null)
        function getObstacleAt(x, z) {
            for (const obs of obstacles) {
                const dx = x - obs.x;
                const dz = z - obs.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                if (dist < obs.radius && !obs.isBlocking) {
                    return obs;
                }
            }
            return null;
        }

        // Check if position collides with obstacle (for blocking movement)
        function collidesWithObstacle(x, z, currentY = 0) {
            for (const obs of obstacles) {
                const dx = x - obs.x;
                const dz = z - obs.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                // Only block if we're at ground level and obstacle is blocking type
                if (dist < obs.radius * 0.7 && obs.isBlocking && currentY < obs.height) {
                    return true;
                }
            }
            return false;
        }

        // Samurai Warrior
        const player = new THREE.Group();

        // Materials
        const skinMaterial = new THREE.MeshStandardMaterial({ color: 0xffdbac, roughness: 0.8 });
        const armorMaterial = new THREE.MeshStandardMaterial({ color: 0x8B0000, roughness: 0.4, metalness: 0.3 }); // Dark red armor
        const armorAccent = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.3, metalness: 0.5 });
        const swordBlade = new THREE.MeshStandardMaterial({ color: 0xc0c0c0, roughness: 0.2, metalness: 0.9 });
        const swordHandle = new THREE.MeshStandardMaterial({ color: 0x4a3728, roughness: 0.9 });
        const hairMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.8 });

        // Body (torso with armor)
        const bodyGeom = new THREE.BoxGeometry(0.8, 1, 0.5);
        const body = new THREE.Mesh(bodyGeom, armorMaterial);
        body.position.y = 1.2;
        body.castShadow = true;
        player.add(body);

        // Armor shoulder pads
        const shoulderGeom = new THREE.BoxGeometry(0.35, 0.15, 0.4);
        const leftShoulder = new THREE.Mesh(shoulderGeom, armorAccent);
        leftShoulder.position.set(-0.55, 1.6, 0);
        leftShoulder.castShadow = true;
        player.add(leftShoulder);

        const rightShoulder = new THREE.Mesh(shoulderGeom, armorAccent);
        rightShoulder.position.set(0.55, 1.6, 0);
        rightShoulder.castShadow = true;
        player.add(rightShoulder);

        // Head
        const headGeom = new THREE.BoxGeometry(0.4, 0.45, 0.4);
        const head = new THREE.Mesh(headGeom, skinMaterial);
        head.position.y = 2;
        head.castShadow = true;
        player.add(head);

        // Samurai helmet (kabuto)
        const helmetGeom = new THREE.BoxGeometry(0.5, 0.25, 0.5);
        const helmet = new THREE.Mesh(helmetGeom, armorAccent);
        helmet.position.y = 2.3;
        helmet.castShadow = true;
        player.add(helmet);

        // Helmet crest
        const crestGeom = new THREE.BoxGeometry(0.05, 0.3, 0.3);
        const crest = new THREE.Mesh(crestGeom, armorMaterial);
        crest.position.set(0, 2.5, 0);
        crest.castShadow = true;
        player.add(crest);

        // Hair/ponytail
        const hairGeom = new THREE.BoxGeometry(0.15, 0.4, 0.15);
        const hair = new THREE.Mesh(hairGeom, hairMaterial);
        hair.position.set(0, 2.1, -0.3);
        hair.castShadow = true;
        player.add(hair);

        // Left arm
        const armGeom = new THREE.BoxGeometry(0.2, 0.7, 0.25);
        const leftArm = new THREE.Mesh(armGeom, armorMaterial);
        leftArm.position.set(-0.55, 1.1, 0);
        leftArm.castShadow = true;
        player.add(leftArm);

        // Right arm (holding sword) - this will be animated
        const rightArmPivot = new THREE.Group();
        rightArmPivot.position.set(0.55, 1.5, 0);
        player.add(rightArmPivot);

        const rightArm = new THREE.Mesh(armGeom, armorMaterial);
        rightArm.position.set(0, -0.35, 0);
        rightArm.castShadow = true;
        rightArmPivot.add(rightArm);

        // Sword
        const swordPivot = new THREE.Group();
        swordPivot.position.set(0, -0.7, 0.15); // Position at hand
        swordPivot.rotation.x = Math.PI / 2; // Rotate so blade points forward (away from body)
        rightArmPivot.add(swordPivot);

        // Sword handle (held by hand - closest to pivot)
        const handleGeom = new THREE.BoxGeometry(0.08, 0.35, 0.08);
        const handle = new THREE.Mesh(handleGeom, swordHandle);
        handle.position.set(0, 0.1, 0); // Handle near the hand
        handle.castShadow = true;
        swordPivot.add(handle);

        // Sword guard (tsuba) - between handle and blade
        const guardGeom = new THREE.BoxGeometry(0.2, 0.05, 0.15);
        const guard = new THREE.Mesh(guardGeom, armorAccent);
        guard.position.set(0, 0.3, 0);
        guard.castShadow = true;
        swordPivot.add(guard);

        // Sword blade (katana) - extends away from hand
        const bladeGeom = new THREE.BoxGeometry(0.06, 1.8, 0.02);
        const blade = new THREE.Mesh(bladeGeom, swordBlade);
        blade.position.set(0, 1.25, 0); // Blade extends outward
        blade.castShadow = true;
        swordPivot.add(blade);

        // Store default sword rotation for idle pose
        const defaultSwordRotX = Math.PI / 2;

        // Legs
        const legGeom = new THREE.BoxGeometry(0.25, 0.8, 0.3);
        const leftLeg = new THREE.Mesh(legGeom, armorAccent);
        leftLeg.position.set(-0.2, 0.4, 0);
        leftLeg.castShadow = true;
        player.add(leftLeg);

        const rightLeg = new THREE.Mesh(legGeom, armorAccent);
        rightLeg.position.set(0.2, 0.4, 0);
        rightLeg.castShadow = true;
        player.add(rightLeg);

        scene.add(player);

        // First-person arm and sword (attached to camera, always visible)
        const fpArmGroup = new THREE.Group();
        camera.add(fpArmGroup);
        scene.add(camera); // Need to add camera to scene for children to render

        // First-person arm pivot (for animations)
        const fpArmPivot = new THREE.Group();
        fpArmPivot.position.set(0.4, -0.3, -0.5); // Position in front-right of camera
        fpArmGroup.add(fpArmPivot);

        // First-person arm
        const fpArmGeom = new THREE.BoxGeometry(0.15, 0.5, 0.15);
        const fpArm = new THREE.Mesh(fpArmGeom, armorMaterial);
        fpArm.position.set(0, -0.2, 0);
        fpArmPivot.add(fpArm);

        // First-person hand
        const fpHandGeom = new THREE.BoxGeometry(0.12, 0.15, 0.12);
        const fpHand = new THREE.Mesh(fpHandGeom, skinMaterial);
        fpHand.position.set(0, -0.5, 0);
        fpArmPivot.add(fpHand);

        // First-person sword pivot
        const fpSwordPivot = new THREE.Group();
        fpSwordPivot.position.set(0, -0.55, 0.1);
        fpSwordPivot.rotation.x = Math.PI / 2; // Default: blade pointing forward
        fpArmPivot.add(fpSwordPivot);

        // FP Sword handle
        const fpHandleGeom = new THREE.BoxGeometry(0.06, 0.25, 0.06);
        const fpHandle = new THREE.Mesh(fpHandleGeom, swordHandle);
        fpHandle.position.set(0, 0.08, 0);
        fpSwordPivot.add(fpHandle);

        // FP Sword guard
        const fpGuardGeom = new THREE.BoxGeometry(0.15, 0.04, 0.1);
        const fpGuard = new THREE.Mesh(fpGuardGeom, armorAccent);
        fpGuard.position.set(0, 0.22, 0);
        fpSwordPivot.add(fpGuard);

        // FP Sword blade
        const fpBladeGeom = new THREE.BoxGeometry(0.04, 1.2, 0.015);
        const fpBlade = new THREE.Mesh(fpBladeGeom, swordBlade);
        fpBlade.position.set(0, 0.85, 0);
        fpSwordPivot.add(fpBlade);

        // Default FP sword rotation
        const fpDefaultSwordRotX = Math.PI / 2;

        // Player stats
        let playerHealth = 100;
        const baseHealthRegenRate = 2; // HP per second
        let regenTimer = 0;
        const regenDelay = 3; // Seconds after taking damage before regen starts
        let timeSinceLastHit = 10; // Start with regen active

        // Stamina system
        let playerStamina = 100;
        let isStaminaStunned = false; // True when stamina hits 0, until reaches 10%
        let isMoving = false; // Track if player is moving for stamina drain

        // Wizard energy system
        let wizardEnergy = 0;
        let wizardMaxEnergy = 100;
        let wizardFireballCooldown = 0;
        let wizardHomingCooldown = 0;
        const wizardFireballCooldownTime = 1.2; // 20% shorter than 1.5
        const wizardHomingCooldownTime = 0.8; // 20% shorter than 1.0

        // Necromancer mana and minion system
        let necroMana = 0;
        let necroMaxMana = 150;
        let necroMinions = []; // Array of active minions
        let necroMaxMinions = 4; // Base max minions

        // UI elements for health
        const healthBarInner = document.getElementById('healthBarInner');
        const healthText = document.getElementById('healthText');

        function updatePlayerHealth() {
            const percent = (playerHealth / playerStats.maxHealth) * 100;
            healthBarInner.style.width = percent + '%';
            healthText.textContent = `${Math.max(0, Math.floor(playerHealth))} / ${playerStats.maxHealth}`;
            if (playerHealth <= 0) {
                // Check for Scorched Hourglass relic (death save)
                if (hasRelic('desert') && !deathSaveUsedThisWave) {
                    deathSaveUsedThisWave = true;
                    playerHealth = 1;
                    isInvincible = true;
                    setTimeout(() => { isInvincible = false; }, 2000);
                    showAbilityEffect('â³ Time Rewinds!');
                    updatePlayerHealth();
                    return;
                }
                // Check for Phoenix Rise ability
                const phoenixAbility = playerAbilities.find(a => a.id === 'l6');
                if (phoenixAbility && !phoenixUsedThisWave) {
                    phoenixUsedThisWave = true;
                    const healPercent = legendaryCards[5].levels[phoenixAbility.level - 1];
                    playerHealth = playerStats.maxHealth * (healPercent / 100);
                    showAbilityEffect('ðŸ”¥ Phoenix Rise!');
                    updatePlayerHealth();
                    return;
                }
                // Phoenix Plume relic - one revive per game
                if (hasRelic('phoenix') && !phoenixReviveUsed) {
                    phoenixReviveUsed = true;
                    playerHealth = playerStats.maxHealth * 0.3;
                    isInvincible = true;
                    setTimeout(() => { isInvincible = false; }, 2000);
                    showAbilityEffect('ðŸ”¥ PHOENIX REVIVE!');
                    updatePlayerHealth();
                    return;
                }
                // Game over
                waveAnnouncementEl.textContent = 'GAME OVER';
                waveAnnouncementEl.style.color = '#ff0000';
                waveAnnouncementEl.style.opacity = '1';
                showGameOver();
            }
        }

        function regenHealth(deltaTime) {
            timeSinceLastHit += deltaTime;
            if (timeSinceLastHit >= regenDelay && playerHealth < playerStats.maxHealth && playerHealth > 0) {
                const regenAmount = baseHealthRegenRate * playerStats.regenRate * deltaTime;
                playerHealth = Math.min(playerStats.maxHealth, playerHealth + regenAmount);
                updatePlayerHealth();
            }
        }

        // Wizard energy functions
        function updateWizardEnergyUI() {
            const energyBar = document.getElementById('energyBarInner');
            const energyText = document.getElementById('energyText');
            const spellQ = document.getElementById('spellQ');
            const spellE = document.getElementById('spellE');

            if (!energyBar || !spellQ || !spellE) return;

            const percent = (wizardEnergy / wizardMaxEnergy) * 100;
            energyBar.style.width = percent + '%';
            if (energyText) energyText.textContent = `${Math.floor(wizardEnergy)} / ${wizardMaxEnergy}`;

            const char = characters[currentRunCharacter];
            const fireballCost = char?.fireballCost || 30;
            const homingCost = char?.homingBallCost || 25;

            // Update spell availability
            if (wizardEnergy >= fireballCost && wizardFireballCooldown <= 0) {
                spellQ.classList.remove('disabled');
                spellQ.classList.add('ready');
            } else {
                spellQ.classList.add('disabled');
                spellQ.classList.remove('ready');
            }

            if (wizardEnergy >= homingCost && wizardHomingCooldown <= 0) {
                spellE.classList.remove('disabled');
                spellE.classList.add('ready');
            } else {
                spellE.classList.add('disabled');
                spellE.classList.remove('ready');
            }
        }

        function gainWizardEnergy(amount) {
            if (currentRunCharacter !== 'wizard') return;
            wizardEnergy = Math.min(wizardMaxEnergy, wizardEnergy + amount);
            updateWizardEnergyUI();
        }

        function castFireball() {
            if (currentRunCharacter !== 'wizard') return false;
            const char = characters.wizard;
            const spellCostMult = playerStats.skillBonuses?.spellCost?.mult || 1;
            const actualCost = Math.floor(char.fireballCost * spellCostMult);
            if (wizardEnergy < actualCost || wizardFireballCooldown > 0) return false;

            wizardEnergy -= actualCost;
            wizardFireballCooldown = wizardFireballCooldownTime;
            updateWizardEnergyUI();
            playAttackAnimation('spell');

            // Create fireball projectile
            const fireballGeo = new THREE.SphereGeometry(0.4);
            const fireballMat = new THREE.MeshBasicMaterial({ color: 0xff4400 });
            const fireball = new THREE.Mesh(fireballGeo, fireballMat);
            fireball.position.copy(player.position);
            fireball.position.y = 1.5;

            // Add glow
            const glowGeo = new THREE.SphereGeometry(0.6);
            const glowMat = new THREE.MeshBasicMaterial({ color: 0xff8800, transparent: true, opacity: 0.5 });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            fireball.add(glow);

            scene.add(fireball);

            // Direction player is facing
            const dir = new THREE.Vector3(
                -Math.sin(cameraRotationY),
                0,
                -Math.cos(cameraRotationY)
            ).normalize();

            visualProjectiles.push({
                mesh: fireball,
                velocity: dir.multiplyScalar(25),
                damage: char.fireballDamage * (playerStats.skillBonuses?.fireballDamage?.mult || 1) * (playerStats.skillBonuses?.allSpellDamage?.mult || 1),
                life: 3,
                isFireball: true,
                explosionRadius: 5,
                startPos: player.position.clone(),
                maxRange: 25 // Fireball has 25 unit range
            });

            showAbilityEffect('ðŸ”¥ Fireball!');
            return true;
        }

        function castHomingBall() {
            if (currentRunCharacter !== 'wizard') return false;
            const char = characters.wizard;
            const spellCostMult = playerStats.skillBonuses?.spellCost?.mult || 1;
            const actualCost = Math.floor(char.homingBallCost * spellCostMult);
            if (wizardEnergy < actualCost || wizardHomingCooldown > 0) return false;

            wizardEnergy -= actualCost;
            wizardHomingCooldown = wizardHomingCooldownTime;
            updateWizardEnergyUI();
            playAttackAnimation('spell');

            // Create homing energy ball
            const ballGeo = new THREE.SphereGeometry(0.3);
            const ballMat = new THREE.MeshBasicMaterial({ color: 0x9966ff });
            const ball = new THREE.Mesh(ballGeo, ballMat);
            ball.position.copy(player.position);
            ball.position.y = 1.5;

            // Add glow trail
            const glowGeo = new THREE.SphereGeometry(0.5);
            const glowMat = new THREE.MeshBasicMaterial({ color: 0xcc99ff, transparent: true, opacity: 0.4 });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            ball.add(glow);

            scene.add(ball);

            // Find closest enemy to target
            let closestEnemy = null;
            let closestDist = Infinity;
            for (const enemy of enemies) {
                const dist = player.position.distanceTo(enemy.mesh.position);
                if (dist < closestDist) {
                    closestDist = dist;
                    closestEnemy = enemy;
                }
            }

            visualProjectiles.push({
                mesh: ball,
                velocity: new THREE.Vector3(-Math.sin(cameraRotationY) * 15, 0, -Math.cos(cameraRotationY) * 15),
                damage: char.homingBallDamage * (playerStats.skillBonuses?.homingDamage?.mult || 1) * (playerStats.skillBonuses?.allSpellDamage?.mult || 1),
                life: 5,
                isHomingBall: true,
                target: closestEnemy,
                startPos: player.position.clone(),
                maxRange: 35 // Homing ball has 35 unit range (longer since it tracks)
            });

            showAbilityEffect('âœ¨ Homing Ball!');
            return true;
        }

        // ========== NECROMANCER FUNCTIONS ==========
        function updateNecroManaUI() {
            const energyBar = document.getElementById('energyBarInner');
            const energyText = document.getElementById('energyText');
            const spellQ = document.getElementById('spellQ');
            const spellE = document.getElementById('spellE');

            if (!energyBar || !spellQ || !spellE) return;

            const percent = (necroMana / necroMaxMana) * 100;
            energyBar.style.width = percent + '%';
            if (energyText) energyText.textContent = `${Math.floor(necroMana)} / ${necroMaxMana}`;

            const char = characters.necromancer;
            const spellCostMult = playerStats.skillBonuses?.spellCost?.mult || 1;
            const warriorCost = Math.floor((char?.skeletonWarriorCost || 30) * spellCostMult);
            const archerCost = Math.floor((char?.skeletonArcherCost || 25) * spellCostMult);

            // Update spell text
            spellQ.textContent = `Q: Warrior (${warriorCost})`;
            spellE.textContent = `E: Archer (${archerCost})`;

            // Update spell availability
            const canSummon = necroMinions.length < necroMaxMinions;
            if (necroMana >= warriorCost && canSummon) {
                spellQ.classList.remove('disabled');
                spellQ.classList.add('ready');
            } else {
                spellQ.classList.add('disabled');
                spellQ.classList.remove('ready');
            }

            if (necroMana >= archerCost && canSummon) {
                spellE.classList.remove('disabled');
                spellE.classList.add('ready');
            } else {
                spellE.classList.add('disabled');
                spellE.classList.remove('ready');
            }
        }

        function gainNecroMana(amount) {
            if (currentRunCharacter !== 'necromancer') return;
            necroMana = Math.min(necroMaxMana, necroMana + amount);
            updateNecroManaUI();
        }

        function summonSkeletonWarrior() {
            if (currentRunCharacter !== 'necromancer') return false;
            const char = characters.necromancer;
            const spellCostMult = playerStats.skillBonuses?.spellCost?.mult || 1;
            const actualCost = Math.floor(char.skeletonWarriorCost * spellCostMult);

            if (necroMana < actualCost || necroMinions.length >= necroMaxMinions) return false;

            necroMana -= actualCost;
            updateNecroManaUI();
            playAttackAnimation('summon');

            // Create skeleton warrior mesh
            const skeleton = new THREE.Group();

            // Body (ribcage)
            const bodyGeo = new THREE.BoxGeometry(0.5, 0.6, 0.3);
            const boneMat = new THREE.MeshLambertMaterial({ color: 0xf5f5dc, emissive: 0x222211 });
            const body = new THREE.Mesh(bodyGeo, boneMat);
            body.position.y = 1.0;
            skeleton.add(body);

            // Head (skull)
            const headGeo = new THREE.SphereGeometry(0.25, 8, 6);
            const head = new THREE.Mesh(headGeo, boneMat);
            head.position.y = 1.5;
            skeleton.add(head);

            // Eyes (glowing)
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const eyeGeo = new THREE.SphereGeometry(0.05);
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(-0.08, 1.52, 0.2);
            skeleton.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(0.08, 1.52, 0.2);
            skeleton.add(rightEye);

            // Sword
            const swordGeo = new THREE.BoxGeometry(0.08, 0.6, 0.02);
            const swordMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
            const sword = new THREE.Mesh(swordGeo, swordMat);
            sword.position.set(0.4, 0.9, 0);
            skeleton.add(sword);

            // Legs
            const legGeo = new THREE.BoxGeometry(0.12, 0.5, 0.12);
            const leftLeg = new THREE.Mesh(legGeo, boneMat);
            leftLeg.position.set(-0.15, 0.4, 0);
            skeleton.add(leftLeg);
            const rightLeg = new THREE.Mesh(legGeo, boneMat);
            rightLeg.position.set(0.15, 0.4, 0);
            skeleton.add(rightLeg);

            // Position near player
            const angle = Math.random() * Math.PI * 2;
            skeleton.position.set(
                player.position.x + Math.cos(angle) * 2,
                0,
                player.position.z + Math.sin(angle) * 2
            );

            scene.add(skeleton);

            // Minion stats with skill bonuses
            const healthMult = playerStats.skillBonuses?.minionHealth?.mult || 1;
            const damageMult = playerStats.skillBonuses?.minionDamage?.mult || 1;

            necroMinions.push({
                mesh: skeleton,
                type: 'warrior',
                health: 40 * healthMult,
                maxHealth: 40 * healthMult,
                damage: 3 * damageMult,
                attackSpeed: 1.0,
                attackTimer: 0,
                moveSpeed: 4,
                range: 2.5
            });

            showAbilityEffect('ðŸ’€ Skeleton Warrior!');

            // Double summon chance (Twin Souls skill)
            const doubleSummonChance = playerStats.skillBonuses?.doubleSummon?.add || 0;
            if (doubleSummonChance > 0 && Math.random() < doubleSummonChance && necroMinions.length < necroMaxMinions) {
                setTimeout(() => summonSkeletonWarrior(), 100); // Slight delay for extra summon
                showAbilityEffect('ðŸ‘¥ TWIN SOULS!');
            }

            return true;
        }

        function summonSkeletonArcher() {
            if (currentRunCharacter !== 'necromancer') return false;
            const char = characters.necromancer;
            const spellCostMult = playerStats.skillBonuses?.spellCost?.mult || 1;
            const actualCost = Math.floor(char.skeletonArcherCost * spellCostMult);

            if (necroMana < actualCost || necroMinions.length >= necroMaxMinions) return false;

            necroMana -= actualCost;
            updateNecroManaUI();
            playAttackAnimation('summon');

            // Create skeleton archer mesh
            const skeleton = new THREE.Group();

            // Body
            const bodyGeo = new THREE.BoxGeometry(0.4, 0.5, 0.25);
            const boneMat = new THREE.MeshLambertMaterial({ color: 0xf5f5dc, emissive: 0x222211 });
            const body = new THREE.Mesh(bodyGeo, boneMat);
            body.position.y = 1.0;
            skeleton.add(body);

            // Head
            const headGeo = new THREE.SphereGeometry(0.22, 8, 6);
            const head = new THREE.Mesh(headGeo, boneMat);
            head.position.y = 1.45;
            skeleton.add(head);

            // Eyes (red for archer)
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const eyeGeo = new THREE.SphereGeometry(0.04);
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(-0.07, 1.47, 0.18);
            skeleton.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(0.07, 1.47, 0.18);
            skeleton.add(rightEye);

            // Bow
            const bowGeo = new THREE.TorusGeometry(0.3, 0.03, 8, 16, Math.PI);
            const bowMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const bow = new THREE.Mesh(bowGeo, bowMat);
            bow.position.set(0.35, 1.1, 0);
            bow.rotation.z = Math.PI / 2;
            skeleton.add(bow);

            // Legs (thinner)
            const legGeo = new THREE.BoxGeometry(0.1, 0.45, 0.1);
            const leftLeg = new THREE.Mesh(legGeo, boneMat);
            leftLeg.position.set(-0.12, 0.4, 0);
            skeleton.add(leftLeg);
            const rightLeg = new THREE.Mesh(legGeo, boneMat);
            rightLeg.position.set(0.12, 0.4, 0);
            skeleton.add(rightLeg);

            // Position near player
            const angle = Math.random() * Math.PI * 2;
            skeleton.position.set(
                player.position.x + Math.cos(angle) * 2,
                0,
                player.position.z + Math.sin(angle) * 2
            );

            scene.add(skeleton);

            // Minion stats - archer is weaker but ranged
            const healthMult = playerStats.skillBonuses?.minionHealth?.mult || 1;
            const damageMult = playerStats.skillBonuses?.minionDamage?.mult || 1;

            necroMinions.push({
                mesh: skeleton,
                type: 'archer',
                health: 25 * healthMult,
                maxHealth: 25 * healthMult,
                damage: 5 * damageMult,
                attackSpeed: 0.5, // Slower attacks
                attackTimer: 0,
                moveSpeed: 3,
                range: 12 // Ranged attack
            });

            showAbilityEffect('ðŸ¹ Skeleton Archer!');

            // Double summon chance (Twin Souls skill)
            const doubleSummonChance = playerStats.skillBonuses?.doubleSummon?.add || 0;
            if (doubleSummonChance > 0 && Math.random() < doubleSummonChance && necroMinions.length < necroMaxMinions) {
                setTimeout(() => summonSkeletonArcher(), 100); // Slight delay for extra summon
                showAbilityEffect('ðŸ‘¥ TWIN SOULS!');
            }

            return true;
        }

        function updateNecroMinions(deltaTime) {
            if (currentRunCharacter !== 'necromancer') return;

            for (let i = necroMinions.length - 1; i >= 0; i--) {
                const minion = necroMinions[i];

                // Check if minion is dead
                if (minion.health <= 0) {
                    scene.remove(minion.mesh);
                    necroMinions.splice(i, 1);
                    updateNecroManaUI();
                    continue;
                }

                // Find nearest enemy
                let nearestEnemy = null;
                let nearestDist = Infinity;
                for (const enemy of enemies) {
                    const dx = enemy.mesh.position.x - minion.mesh.position.x;
                    const dz = enemy.mesh.position.z - minion.mesh.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestEnemy = enemy;
                    }
                }

                if (nearestEnemy) {
                    const dx = nearestEnemy.mesh.position.x - minion.mesh.position.x;
                    const dz = nearestEnemy.mesh.position.z - minion.mesh.position.z;

                    // Face enemy
                    minion.mesh.rotation.y = Math.atan2(dx, dz);

                    if (nearestDist > minion.range) {
                        // Move towards enemy
                        const moveX = (dx / nearestDist) * minion.moveSpeed * deltaTime;
                        const moveZ = (dz / nearestDist) * minion.moveSpeed * deltaTime;
                        minion.mesh.position.x += moveX;
                        minion.mesh.position.z += moveZ;
                    } else {
                        // Attack enemy
                        minion.attackTimer -= deltaTime;
                        if (minion.attackTimer <= 0) {
                            minion.attackTimer = 1 / minion.attackSpeed;

                            // Deal damage
                            nearestEnemy.health -= minion.damage;

                            // Visual feedback
                            if (minion.type === 'archer') {
                                // Shoot arrow visual
                                const arrowGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.4);
                                const arrowMat = new THREE.MeshBasicMaterial({ color: 0x8B4513 });
                                const arrow = new THREE.Mesh(arrowGeo, arrowMat);
                                arrow.position.copy(minion.mesh.position);
                                arrow.position.y = 1.2;
                                arrow.rotation.x = Math.PI / 2;
                                arrow.rotation.z = Math.atan2(dx, dz);
                                scene.add(arrow);

                                // Move arrow quickly to target
                                let arrowLife = 0;
                                const arrowInterval = setInterval(() => {
                                    arrowLife += 0.05;
                                    arrow.position.x += (dx / nearestDist) * 2;
                                    arrow.position.z += (dz / nearestDist) * 2;
                                    if (arrowLife >= 0.3) {
                                        scene.remove(arrow);
                                        clearInterval(arrowInterval);
                                    }
                                }, 16);
                            }

                            // Flash enemy
                            nearestEnemy.mesh.children.forEach(child => {
                                if (child.material && child.material.emissive) {
                                    child.material.emissive.setHex(0x00ff00);
                                    setTimeout(() => child.material.emissive.setHex(0x000000), 100);
                                }
                            });

                            // Check if enemy died
                            if (nearestEnemy.health <= 0) {
                                const enemyIndex = enemies.indexOf(nearestEnemy);
                                if (enemyIndex >= 0) {
                                    createGibs(nearestEnemy);
                                    scene.remove(nearestEnemy.mesh);
                                    enemies.splice(enemyIndex, 1);
                                    onEnemyKilled(nearestEnemy);
                                    updateEnemyCount();
                                }
                            }
                        }
                    }
                } else {
                    // No enemies, follow player
                    const dx = player.position.x - minion.mesh.position.x;
                    const dz = player.position.z - minion.mesh.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist > 4) {
                        minion.mesh.position.x += (dx / dist) * minion.moveSpeed * deltaTime;
                        minion.mesh.position.z += (dz / dist) * minion.moveSpeed * deltaTime;
                    }
                }
            }
        }
        // ========== END NECROMANCER ==========

        // Enemy types configuration with full stats
        // Stats: health, armor (damage reduction), damage, moveSpeed, attackSpeed (attacks per second), range
        const enemyTypes = {
            // Basic enemies
            ashigaru: {
                name: 'Ashigaru',
                health: 20, armor: 0, damage: 5, moveSpeed: 3, attackSpeed: 1.0, range: 2.5,
                color: 0x4a3830, accentColor: 0x2a1810, scale: 0.9
            },
            ronin: {
                name: 'Ronin',
                health: 30, armor: 1, damage: 8, moveSpeed: 4, attackSpeed: 1.2, range: 3.0,
                color: 0x2d1b4e, accentColor: 0x1a1a1a, scale: 1.0
            },
            scout: {
                name: 'Scout',
                health: 15, armor: 0, damage: 4, moveSpeed: 6, attackSpeed: 1.5, range: 2.0,
                color: 0x1a4d1a, accentColor: 0x0a2a0a, scale: 0.8
            },
            // Medium enemies
            samurai: {
                name: 'Samurai',
                health: 45, armor: 2, damage: 10, moveSpeed: 3.5, attackSpeed: 1.0, range: 3.5,
                color: 0x1a1a4d, accentColor: 0x0a0a2a, scale: 1.05
            },
            spearman: {
                name: 'Yari Samurai',
                health: 35, armor: 1, damage: 12, moveSpeed: 3, attackSpeed: 0.8, range: 4.0,
                color: 0x4d3a1a, accentColor: 0x2a1a0a, scale: 1.1
            },
            ninja: {
                name: 'Ninja',
                health: 25, armor: 0, damage: 15, moveSpeed: 7, attackSpeed: 2.0, range: 2.5,
                color: 0x1a1a1a, accentColor: 0x0a0a0a, scale: 0.85
            },
            // Heavy enemies
            brute: {
                name: 'Oni Brute',
                health: 80, armor: 3, damage: 18, moveSpeed: 2, attackSpeed: 0.6, range: 3.0,
                color: 0x4d1a1a, accentColor: 0x2a0a0a, scale: 1.4
            },
            guardian: {
                name: 'Temple Guardian',
                health: 60, armor: 5, damage: 12, moveSpeed: 2.5, attackSpeed: 0.8, range: 3.5,
                color: 0x3d3d3d, accentColor: 0x1d1d1d, scale: 1.3
            },
            berserker: {
                name: 'Berserker',
                health: 50, armor: 0, damage: 22, moveSpeed: 5, attackSpeed: 1.8, range: 2.5,
                color: 0x6d1a1a, accentColor: 0x4a0a0a, scale: 1.2
            },
            // Elite enemies
            elite: {
                name: 'Elite Samurai',
                health: 70, armor: 4, damage: 15, moveSpeed: 4, attackSpeed: 1.3, range: 3.5,
                color: 0x4d4d1a, accentColor: 0x2a2a0a, scale: 1.15
            },
            shadow: {
                name: 'Shadow Warrior',
                health: 40, armor: 2, damage: 20, moveSpeed: 6, attackSpeed: 1.8, range: 3.0,
                color: 0x0f0f1f, accentColor: 0x050510, scale: 1.0
            },
            warlord: {
                name: 'Warlord',
                health: 100, armor: 5, damage: 18, moveSpeed: 3, attackSpeed: 1.0, range: 4.0,
                color: 0x8b0000, accentColor: 0x4a0000, scale: 1.25
            },
            // Special enemies
            monk: {
                name: 'Warrior Monk',
                health: 55, armor: 2, damage: 14, moveSpeed: 4.5, attackSpeed: 1.4, range: 3.0,
                color: 0xff6600, accentColor: 0x993300, scale: 1.0
            },
            shogun: {
                name: 'Shogun Guard',
                health: 90, armor: 6, damage: 16, moveSpeed: 2.5, attackSpeed: 0.9, range: 3.5,
                color: 0xcc9900, accentColor: 0x664400, scale: 1.3
            },
            phantom: {
                name: 'Phantom',
                health: 30, armor: 0, damage: 25, moveSpeed: 8, attackSpeed: 2.2, range: 2.0,
                color: 0x4a4a6a, accentColor: 0x2a2a4a, scale: 0.9
            },
            titan: {
                name: 'Oni Titan',
                health: 150, armor: 4, damage: 25, moveSpeed: 1.5, attackSpeed: 0.5, range: 4.5,
                color: 0x330033, accentColor: 0x1a001a, scale: 1.8
            },
            // Ranged enemies (VERY slow attack, easy to dodge, can friendly fire)
            shuriken: {
                name: 'Shuriken Ninja',
                health: 20, armor: 0, damage: 3, moveSpeed: 5, attackSpeed: 0.15, range: 15,
                color: 0x222222, accentColor: 0x111111, scale: 0.85, ranged: true, projectileType: 'shuriken'
            },
            archer: {
                name: 'Archer',
                health: 25, armor: 0, damage: 4, moveSpeed: 3, attackSpeed: 0.12, range: 20,
                color: 0x2d4a1a, accentColor: 0x1a2d0a, scale: 0.95, ranged: true, projectileType: 'arrow'
            },
            crossbow: {
                name: 'Crossbowman',
                health: 30, armor: 1, damage: 5, moveSpeed: 2.5, attackSpeed: 0.1, range: 22,
                color: 0x4a3a2a, accentColor: 0x2a1a0a, scale: 1.0, ranged: true, projectileType: 'bolt'
            },
            fireArcher: {
                name: 'Fire Archer',
                health: 35, armor: 1, damage: 6, moveSpeed: 3, attackSpeed: 0.1, range: 18,
                color: 0x8b2500, accentColor: 0x4a1000, scale: 1.0, ranged: true, projectileType: 'firearrow'
            },
            // BOSS - Wave 10: Knight in Shining Armor (lower HP, epic abilities)
            knight: {
                name: 'KNIGHT',
                health: 225, armor: 8, damage: 12, moveSpeed: 3, attackSpeed: 1.0, range: 4,
                color: 0xc0c0c0, accentColor: 0xffd700, scale: 2.0, isBoss: true,
                special: 'knight',
                abilities: ['shieldBash', 'swordSpin', 'charge']
            },
            // BOSS - Wave 20: Werewolf (lower HP, feral abilities)
            werewolf: {
                name: 'WEREWOLF',
                health: 175, armor: 3, damage: 15, moveSpeed: 8, attackSpeed: 2.0, range: 3.5,
                color: 0x4a3a2a, accentColor: 0xff4400, scale: 2.2, isBoss: true,
                special: 'werewolf',
                abilities: ['leap', 'howl', 'frenzy', 'clawCombo']
            },
            // BOSS - Wave 30: Dragon (lower HP, devastating abilities)
            dragon: {
                name: 'DRAGON',
                health: 200, armor: 5, damage: 18, moveSpeed: 5, attackSpeed: 0.8, range: 20,
                color: 0x8b0000, accentColor: 0xff4400, scale: 3.5, isBoss: true,
                special: 'dragon', ranged: true, projectileType: 'fireball',
                abilities: ['fireBreath', 'tailSwipe', 'wingGust', 'meteorShower', 'diveBomb']
            },

            // ========== BONUS WAVE ENEMIES (31-50) ==========
            // Elite enemies - harder versions
            eliteSamurai: {
                name: 'Elite Samurai',
                health: 80, armor: 4, damage: 22, moveSpeed: 5, attackSpeed: 1.8, range: 3.5,
                color: 0x8b0000, accentColor: 0x4a0000, scale: 1.15
            },
            shadowNinja: {
                name: 'Shadow Ninja',
                health: 40, armor: 0, damage: 30, moveSpeed: 10, attackSpeed: 2.5, range: 2.5,
                color: 0x1a1a2e, accentColor: 0x0a0a1e, scale: 0.9
            },
            warMage: {
                name: 'War Mage',
                health: 50, armor: 2, damage: 8, moveSpeed: 3, attackSpeed: 0.2, range: 18,
                color: 0x4a0080, accentColor: 0x2a0050, scale: 1.0, ranged: true, projectileType: 'fireball'
            },
            berserker: {
                name: 'Berserker',
                health: 120, armor: 0, damage: 35, moveSpeed: 6, attackSpeed: 2.0, range: 3.0,
                color: 0x8b2500, accentColor: 0x5a1500, scale: 1.3
            },
            shieldBearer: {
                name: 'Shield Bearer',
                health: 100, armor: 12, damage: 12, moveSpeed: 2, attackSpeed: 0.6, range: 3.0,
                color: 0x666688, accentColor: 0x444466, scale: 1.2
            },
            spearman: {
                name: 'Halberdier',
                health: 70, armor: 3, damage: 20, moveSpeed: 3.5, attackSpeed: 1.0, range: 5.0,
                color: 0x556655, accentColor: 0x334433, scale: 1.1
            },
            demonSpawn: {
                name: 'Demon Spawn',
                health: 60, armor: 2, damage: 28, moveSpeed: 7, attackSpeed: 1.8, range: 3.0,
                color: 0x660022, accentColor: 0x440011, scale: 1.0
            },
            iceArcher: {
                name: 'Ice Archer',
                health: 35, armor: 1, damage: 5, moveSpeed: 3, attackSpeed: 0.12, range: 22,
                color: 0x4488cc, accentColor: 0x2266aa, scale: 1.0, ranged: true, projectileType: 'arrow'
            },
            deathKnight: {
                name: 'Death Knight',
                health: 140, armor: 8, damage: 30, moveSpeed: 3, attackSpeed: 1.0, range: 4.0,
                color: 0x2a2a3a, accentColor: 0x1a1a2a, scale: 1.4
            },
            voidWalker: {
                name: 'Void Walker',
                health: 45, armor: 0, damage: 40, moveSpeed: 12, attackSpeed: 3.0, range: 2.0,
                color: 0x220033, accentColor: 0x110022, scale: 0.85
            },

            // ========== WATER ENEMIES ==========
            waterSerpent: {
                name: 'Water Serpent',
                health: 55, armor: 1, damage: 18, moveSpeed: 7, attackSpeed: 1.8, range: 3.0,
                color: 0x1565C0, accentColor: 0x0D47A1, scale: 1.1,
                isWaterEnemy: true
            },
            drownedWarrior: {
                name: 'Drowned Warrior',
                health: 70, armor: 3, damage: 14, moveSpeed: 4, attackSpeed: 1.2, range: 3.5,
                color: 0x37474F, accentColor: 0x263238, scale: 1.2,
                isWaterEnemy: true
            },
            kappa: {
                name: 'Kappa',
                health: 40, armor: 0, damage: 22, moveSpeed: 9, attackSpeed: 2.0, range: 2.5,
                color: 0x2E7D32, accentColor: 0x1B5E20, scale: 0.9,
                isWaterEnemy: true
            },
            seaMonk: {
                name: 'Sea Monk',
                health: 50, armor: 2, damage: 10, moveSpeed: 5, attackSpeed: 0.15, range: 16,
                color: 0x00838F, accentColor: 0x006064, scale: 1.0,
                isWaterEnemy: true, ranged: true, projectileType: 'arrow'
            },
            tidalWraith: {
                name: 'Tidal Wraith',
                health: 85, armor: 4, damage: 25, moveSpeed: 6, attackSpeed: 1.5, range: 4.0,
                color: 0x4DD0E1, accentColor: 0x00BCD4, scale: 1.3,
                isWaterEnemy: true
            },
            deepOne: {
                name: 'Deep One',
                health: 120, armor: 6, damage: 30, moveSpeed: 5, attackSpeed: 1.0, range: 4.5,
                color: 0x0277BD, accentColor: 0x01579B, scale: 1.5,
                isWaterEnemy: true
            },

            // BOSS - Wave 40: Demon Lord
            demonLord: {
                name: 'DEMON LORD',
                health: 250, armor: 6, damage: 20, moveSpeed: 5, attackSpeed: 1.2, range: 5,
                color: 0x440000, accentColor: 0xff2200, scale: 2.8, isBoss: true,
                special: 'demonLord',
                abilities: ['hellfire', 'demonSummon', 'darkSlash', 'soulDrain']
            },
            // BOSS - Wave 50: Ancient God
            ancientGod: {
                name: 'ANCIENT GOD',
                health: 350, armor: 10, damage: 25, moveSpeed: 4, attackSpeed: 1.0, range: 8,
                color: 0xffd700, accentColor: 0xffffff, scale: 4.0, isBoss: true,
                special: 'ancientGod',
                abilities: ['divineSmite', 'holyNova', 'judgment', 'celestialBeam', 'ascend']
            },

            // ========== DESERT MAP ENEMIES ==========
            bandit: {
                name: 'Desert Bandit',
                health: 25, armor: 0, damage: 7, moveSpeed: 5, attackSpeed: 1.3, range: 2.5,
                color: 0xc2a366, accentColor: 0x8b7355, scale: 0.95
            },
            desert_warrior: {
                name: 'Sand Warrior',
                health: 50, armor: 2, damage: 12, moveSpeed: 3.5, attackSpeed: 1.0, range: 3.5,
                color: 0xdaa520, accentColor: 0xb8860b, scale: 1.1
            },
            sandOni: {
                name: 'Sand Demon',
                health: 90, armor: 3, damage: 20, moveSpeed: 2.5, attackSpeed: 0.7, range: 3.5,
                color: 0xd2691e, accentColor: 0x8b4513, scale: 1.5
            },

            // ========== VOLCANO MAP ENEMIES ==========
            fireImp: {
                name: 'Fire Imp',
                health: 18, armor: 0, damage: 6, moveSpeed: 6, attackSpeed: 1.5, range: 2.0,
                color: 0xff4400, accentColor: 0xaa2200, scale: 0.7
            },
            lavaGolem: {
                name: 'Lava Golem',
                health: 100, armor: 5, damage: 22, moveSpeed: 1.5, attackSpeed: 0.5, range: 3.5,
                color: 0x330000, accentColor: 0xff4400, scale: 1.6
            },
            ashWraith: {
                name: 'Ash Wraith',
                health: 35, armor: 0, damage: 18, moveSpeed: 7, attackSpeed: 1.8, range: 2.5,
                color: 0x333333, accentColor: 0xff2200, scale: 0.9
            },
            infernoOni: {
                name: 'Inferno Oni',
                health: 110, armor: 4, damage: 25, moveSpeed: 2, attackSpeed: 0.6, range: 4.0,
                color: 0x660000, accentColor: 0xff6600, scale: 1.6
            },

            // ========== FROST MAP ENEMIES ==========
            frostWarrior: {
                name: 'Frost Warrior',
                health: 40, armor: 3, damage: 10, moveSpeed: 3, attackSpeed: 0.9, range: 3.0,
                color: 0x88aacc, accentColor: 0x6688aa, scale: 1.0
            },
            snowBrute: {
                name: 'Snow Brute',
                health: 95, armor: 4, damage: 20, moveSpeed: 2, attackSpeed: 0.6, range: 3.5,
                color: 0xddeeff, accentColor: 0xaaccee, scale: 1.5
            },
            frostNinja: {
                name: 'Frost Ninja',
                health: 28, armor: 0, damage: 16, moveSpeed: 8, attackSpeed: 2.0, range: 2.5,
                color: 0x4466aa, accentColor: 0x224488, scale: 0.85
            },
            iceOni: {
                name: 'Ice Oni',
                health: 100, armor: 5, damage: 18, moveSpeed: 2.5, attackSpeed: 0.7, range: 4.0,
                color: 0x88bbdd, accentColor: 0x66aacc, scale: 1.5
            },

            // ========== SWAMP MAP ENEMIES ==========
            swampZombie: {
                name: 'Swamp Zombie',
                health: 45, armor: 1, damage: 8, moveSpeed: 2, attackSpeed: 0.7, range: 2.5,
                color: 0x445533, accentColor: 0x334422, scale: 1.0
            },
            bogWitch: {
                name: 'Bog Witch',
                health: 30, armor: 0, damage: 12, moveSpeed: 3, attackSpeed: 0.5, range: 15,
                color: 0x2a3a2a, accentColor: 0x556644, scale: 0.9, ranged: true, projectileType: 'fireball'
            },
            mireCreeper: {
                name: 'Mire Creeper',
                health: 35, armor: 0, damage: 14, moveSpeed: 6, attackSpeed: 1.6, range: 2.5,
                color: 0x334422, accentColor: 0x556633, scale: 0.8
            },
            plagueBearer: {
                name: 'Plague Bearer',
                health: 85, armor: 2, damage: 16, moveSpeed: 2.5, attackSpeed: 0.6, range: 3.5,
                color: 0x4a5a3a, accentColor: 0x667744, scale: 1.4
            },
            swampOni: {
                name: 'Swamp Oni',
                health: 95, armor: 3, damage: 20, moveSpeed: 2.5, attackSpeed: 0.7, range: 4.0,
                color: 0x3a4a2a, accentColor: 0x66aa44, scale: 1.5
            },

            // ========== SHADOW MAP ENEMIES ==========
            shadowWraith: {
                name: 'Shadow Wraith',
                health: 32, armor: 0, damage: 15, moveSpeed: 7, attackSpeed: 1.5, range: 2.5,
                color: 0x2a1a3a, accentColor: 0x4a2a5a, scale: 0.9
            },
            voidStalker: {
                name: 'Void Stalker',
                health: 50, armor: 2, damage: 18, moveSpeed: 5, attackSpeed: 1.2, range: 3.0,
                color: 0x1a1a2a, accentColor: 0x6633aa, scale: 1.1
            },
            darkKnight: {
                name: 'Dark Knight',
                health: 90, armor: 6, damage: 20, moveSpeed: 2.5, attackSpeed: 0.7, range: 3.5,
                color: 0x1a0a2a, accentColor: 0x4a2a6a, scale: 1.3
            },
            shadowOni: {
                name: 'Shadow Oni',
                health: 105, armor: 4, damage: 22, moveSpeed: 3, attackSpeed: 0.8, range: 4.0,
                color: 0x2a1a4a, accentColor: 0x8844cc, scale: 1.5
            },

            // ========== CRYSTAL CAVERN ENEMIES ==========
            crystalGolem: {
                name: 'Crystal Golem',
                health: 110, armor: 6, damage: 18, moveSpeed: 1.8, attackSpeed: 0.5, range: 3.5,
                color: 0x4466aa, accentColor: 0x88ccff, scale: 1.6
            },
            gemSprite: {
                name: 'Gem Sprite',
                health: 25, armor: 0, damage: 10, moveSpeed: 7, attackSpeed: 1.8, range: 2.0,
                color: 0x88aaff, accentColor: 0xaaccff, scale: 0.7
            },
            caveHunter: {
                name: 'Cave Hunter',
                health: 50, armor: 2, damage: 14, moveSpeed: 4, attackSpeed: 1.2, range: 3.0,
                color: 0x5566aa, accentColor: 0x7788cc, scale: 1.0
            },
            crystalArcher: {
                name: 'Crystal Archer',
                health: 35, armor: 1, damage: 12, moveSpeed: 3, attackSpeed: 0.6, range: 18,
                color: 0x6688cc, accentColor: 0x99bbee, scale: 0.95, ranged: true, projectileType: 'arrow'
            },
            crystalOni: {
                name: 'Crystal Oni',
                health: 100, armor: 5, damage: 20, moveSpeed: 2.5, attackSpeed: 0.7, range: 4.0,
                color: 0x5577bb, accentColor: 0x88aaff, scale: 1.5
            },

            // ========== HAUNTED GRAVEYARD ENEMIES ==========
            skeleton: {
                name: 'Skeleton',
                health: 30, armor: 0, damage: 8, moveSpeed: 4, attackSpeed: 1.3, range: 2.5,
                color: 0xcccccc, accentColor: 0x999999, scale: 0.9
            },
            ghost: {
                name: 'Ghost',
                health: 25, armor: 0, damage: 12, moveSpeed: 6, attackSpeed: 1.0, range: 12,
                color: 0x8888aa, accentColor: 0xaaaacc, scale: 0.85, ranged: true, projectileType: 'fireball'
            },
            ghoul: {
                name: 'Ghoul',
                health: 60, armor: 2, damage: 16, moveSpeed: 5, attackSpeed: 1.4, range: 3.0,
                color: 0x445544, accentColor: 0x667766, scale: 1.1
            },
            banshee: {
                name: 'Banshee',
                health: 40, armor: 0, damage: 18, moveSpeed: 7, attackSpeed: 1.6, range: 2.5,
                color: 0x666688, accentColor: 0x8888aa, scale: 0.9
            },
            graveOni: {
                name: 'Grave Oni',
                health: 95, armor: 4, damage: 22, moveSpeed: 2.8, attackSpeed: 0.8, range: 4.0,
                color: 0x4a4a5a, accentColor: 0x666688, scale: 1.5
            },

            // ========== SKY TEMPLE ENEMIES ==========
            skyGuardian: {
                name: 'Sky Guardian',
                health: 70, armor: 5, damage: 15, moveSpeed: 3, attackSpeed: 0.9, range: 3.5,
                color: 0xddddff, accentColor: 0xffffaa, scale: 1.2
            },
            cloudNinja: {
                name: 'Cloud Ninja',
                health: 35, armor: 0, damage: 18, moveSpeed: 9, attackSpeed: 2.0, range: 2.5,
                color: 0xeeeeff, accentColor: 0xffffff, scale: 0.85
            },
            templeMonk: {
                name: 'Temple Monk',
                health: 45, armor: 2, damage: 12, moveSpeed: 3.5, attackSpeed: 1.1, range: 3.0,
                color: 0xffeecc, accentColor: 0xffffdd, scale: 1.0
            },
            stormArcher: {
                name: 'Storm Archer',
                health: 40, armor: 1, damage: 14, moveSpeed: 3, attackSpeed: 0.7, range: 20,
                color: 0xccddff, accentColor: 0xeeeeff, scale: 0.95, ranged: true, projectileType: 'arrow'
            },
            skyOni: {
                name: 'Sky Oni',
                health: 90, armor: 4, damage: 20, moveSpeed: 3, attackSpeed: 0.8, range: 4.0,
                color: 0xddddff, accentColor: 0xffffcc, scale: 1.5
            },

            // ========== INFERNAL ABYSS ENEMIES ==========
            hellSpawn: {
                name: 'Hell Spawn',
                health: 40, armor: 1, damage: 14, moveSpeed: 6, attackSpeed: 1.5, range: 2.5,
                color: 0x880000, accentColor: 0xff2200, scale: 0.9
            },
            demonGuard: {
                name: 'Demon Guard',
                health: 80, armor: 5, damage: 20, moveSpeed: 3, attackSpeed: 0.9, range: 3.5,
                color: 0x660000, accentColor: 0xaa0000, scale: 1.3
            },
            abyssalKnight: {
                name: 'Abyssal Knight',
                health: 120, armor: 8, damage: 25, moveSpeed: 2, attackSpeed: 0.6, range: 4.0,
                color: 0x440000, accentColor: 0x880000, scale: 1.4
            },
            hellArcher: {
                name: 'Hell Archer',
                health: 45, armor: 2, damage: 16, moveSpeed: 3, attackSpeed: 0.6, range: 18,
                color: 0x770000, accentColor: 0xcc0000, scale: 1.0, ranged: true, projectileType: 'firearrow'
            },
            abyssOni: {
                name: 'Abyssal Oni',
                health: 130, armor: 6, damage: 28, moveSpeed: 2.5, attackSpeed: 0.7, range: 4.5,
                color: 0x550000, accentColor: 0xff0000, scale: 1.6
            }
        };

        // Projectiles array for ranged enemies
        const projectiles = [];

        // Enemy creation function with type support
        function createEnemy(x, z, rotation = 0, type = 'basic') {
            const enemy = new THREE.Group();
            const config = enemyTypes[type];

            // Enemy materials based on type
            const enemyArmorMaterial = new THREE.MeshStandardMaterial({ color: config.color, roughness: 0.4, metalness: 0.3 });
            const enemyArmorAccent = new THREE.MeshStandardMaterial({ color: config.accentColor, roughness: 0.3, metalness: 0.5 });
            const enemySkinMaterial = new THREE.MeshStandardMaterial({ color: 0xd4a574, roughness: 0.8 });

            // Store body parts for dismemberment
            const bodyParts = {};

            // Special boss models
            if (type === 'knight') {
                // Knight in Shining Armor - bulky armored warrior
                const kBody = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.4, 0.8), enemyArmorMaterial);
                kBody.position.y = 1.4; bodyParts.body = kBody; enemy.add(kBody);
                const kHead = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), enemyArmorMaterial);
                kHead.position.y = 2.4; bodyParts.head = kHead; enemy.add(kHead);
                // Visor slit
                const visor = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.08, 0.1), new THREE.MeshBasicMaterial({color: 0x000000}));
                visor.position.set(0, 2.4, 0.26); enemy.add(visor);
                // Shield
                const shield = new THREE.Mesh(new THREE.BoxGeometry(0.15, 1.2, 0.8), enemyArmorAccent);
                shield.position.set(-0.8, 1.2, 0.2); bodyParts.leftArm = shield; enemy.add(shield);
                // Sword arm
                const kRArm = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1, 0.3), enemyArmorMaterial);
                kRArm.position.set(0.7, 1.2, 0); bodyParts.rightArm = kRArm; enemy.add(kRArm);
                // Big sword
                const kSword = new THREE.Mesh(new THREE.BoxGeometry(0.1, 2.5, 0.05), swordBlade);
                kSword.position.set(0.7, 0.2, 0.5); enemy.add(kSword);
                // Legs
                const kLLeg = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1, 0.4), enemyArmorAccent);
                kLLeg.position.set(-0.3, 0.5, 0); bodyParts.leftLeg = kLLeg; enemy.add(kLLeg);
                const kRLeg = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1, 0.4), enemyArmorAccent);
                kRLeg.position.set(0.3, 0.5, 0); bodyParts.rightLeg = kRLeg; enemy.add(kRLeg);
            } else if (type === 'werewolf') {
                // Werewolf - hunched beast
                const wBody = new THREE.Mesh(new THREE.BoxGeometry(1, 1.2, 0.7), enemyArmorMaterial);
                wBody.position.y = 1.3; wBody.rotation.x = 0.3; bodyParts.body = wBody; enemy.add(wBody);
                const wHead = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.4, 0.7), enemyArmorMaterial);
                wHead.position.set(0, 1.9, 0.3); bodyParts.head = wHead; enemy.add(wHead);
                // Snout
                const snout = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.2, 0.4), enemyArmorAccent);
                snout.position.set(0, 1.85, 0.7); enemy.add(snout);
                // Ears
                const ear1 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.25, 0.1), enemyArmorMaterial);
                ear1.position.set(-0.2, 2.2, 0.2); enemy.add(ear1);
                const ear2 = ear1.clone(); ear2.position.x = 0.2; enemy.add(ear2);
                // Arms (claws)
                const wLArm = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.9, 0.25), enemyArmorMaterial);
                wLArm.position.set(-0.6, 1.1, 0.2); bodyParts.leftArm = wLArm; enemy.add(wLArm);
                const wRArm = wLArm.clone(); wRArm.position.x = 0.6; bodyParts.rightArm = wRArm; enemy.add(wRArm);
                // Claws
                for (let i = 0; i < 3; i++) {
                    const claw = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.2, 0.05), new THREE.MeshStandardMaterial({color: 0xffffff}));
                    claw.position.set(-0.6 + (i-1)*0.08, 0.55, 0.2); enemy.add(claw);
                    const claw2 = claw.clone(); claw2.position.x = 0.6 + (i-1)*0.08; enemy.add(claw2);
                }
                // Legs
                const wLLeg = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.9, 0.35), enemyArmorAccent);
                wLLeg.position.set(-0.3, 0.45, -0.1); bodyParts.leftLeg = wLLeg; enemy.add(wLLeg);
                const wRLeg = wLLeg.clone(); wRLeg.position.x = 0.3; bodyParts.rightLeg = wRLeg; enemy.add(wRLeg);
                // Tail
                const tail = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.8), enemyArmorMaterial);
                tail.position.set(0, 1.1, -0.7); enemy.add(tail);
            } else if (type === 'dragon') {
                // Dragon - massive flying beast, themed by current map
                const dragonTheme = currentMap.dragonTheme;
                const dragonBodyMat = new THREE.MeshStandardMaterial({ color: dragonTheme.bodyColor, roughness: 0.4, metalness: 0.3 });
                const dragonAccentMat = new THREE.MeshStandardMaterial({ color: dragonTheme.accentColor, roughness: 0.3, metalness: 0.5 });

                const dBody = new THREE.Mesh(new THREE.BoxGeometry(2, 1.5, 3), dragonBodyMat);
                dBody.position.y = 2; bodyParts.body = dBody; enemy.add(dBody);
                // Head
                const dHead = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.7, 1.2), dragonBodyMat);
                dHead.position.set(0, 2.5, 2); bodyParts.head = dHead; enemy.add(dHead);
                // Snout
                const dSnout = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.4, 0.8), dragonAccentMat);
                dSnout.position.set(0, 2.3, 2.8); enemy.add(dSnout);
                // Eyes (glowing, themed)
                const eyeMat = new THREE.MeshBasicMaterial({color: dragonTheme.eyeColor});
                const dEye1 = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.1), eyeMat);
                dEye1.position.set(-0.25, 2.6, 2.5); enemy.add(dEye1);
                const dEye2 = dEye1.clone(); dEye2.position.x = 0.25; enemy.add(dEye2);
                // Horns
                const horn1 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.5, 0.1), dragonAccentMat);
                horn1.position.set(-0.3, 3, 1.8); horn1.rotation.x = -0.3; enemy.add(horn1);
                const horn2 = horn1.clone(); horn2.position.x = 0.3; enemy.add(horn2);
                // Wings
                const wingMat = new THREE.MeshStandardMaterial({color: dragonTheme.accentColor, side: THREE.DoubleSide});
                const wing1 = new THREE.Mesh(new THREE.BoxGeometry(3, 0.05, 1.5), wingMat);
                wing1.position.set(-2.5, 2.5, 0); wing1.rotation.z = 0.3; bodyParts.leftArm = wing1; enemy.add(wing1);
                const wing2 = wing1.clone(); wing2.position.x = 2.5; wing2.rotation.z = -0.3; bodyParts.rightArm = wing2; enemy.add(wing2);
                // Legs
                const dLeg1 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.2, 0.5), dragonAccentMat);
                dLeg1.position.set(-0.7, 0.6, -0.5); bodyParts.leftLeg = dLeg1; enemy.add(dLeg1);
                const dLeg2 = dLeg1.clone(); dLeg2.position.x = 0.7; bodyParts.rightLeg = dLeg2; enemy.add(dLeg2);
                // Tail
                const dTail = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 2.5), dragonBodyMat);
                dTail.position.set(0, 1.8, -2.5); enemy.add(dTail);
                // Store fire color for abilities
                enemy.userData.fireColor = dragonTheme.fireColor;
            } else {
                // Standard samurai enemy
                // Body
                const eBodyGeom = new THREE.BoxGeometry(0.8, 1, 0.5);
                const eBody = new THREE.Mesh(eBodyGeom, enemyArmorMaterial);
                eBody.position.y = 1.2; eBody.castShadow = true;
                bodyParts.body = eBody; enemy.add(eBody);

                // Shoulder pads
                const eShoulderGeom = new THREE.BoxGeometry(0.35, 0.15, 0.4);
                const eLeftShoulder = new THREE.Mesh(eShoulderGeom, enemyArmorAccent);
                eLeftShoulder.position.set(-0.55, 1.6, 0); eLeftShoulder.castShadow = true;
                enemy.add(eLeftShoulder);
                const eRightShoulder = new THREE.Mesh(eShoulderGeom, enemyArmorAccent);
                eRightShoulder.position.set(0.55, 1.6, 0); eRightShoulder.castShadow = true;
                enemy.add(eRightShoulder);

                // Head
                const eHeadGeom = new THREE.BoxGeometry(0.4, 0.45, 0.4);
                const eHead = new THREE.Mesh(eHeadGeom, enemySkinMaterial);
                eHead.position.y = 2; eHead.castShadow = true;
                bodyParts.head = eHead; enemy.add(eHead);

                // Helmet
                const eHelmetGeom = new THREE.BoxGeometry(0.5, 0.25, 0.5);
                const eHelmet = new THREE.Mesh(eHelmetGeom, enemyArmorAccent);
                eHelmet.position.y = 2.3; eHelmet.castShadow = true;
                enemy.add(eHelmet);

                // Helmet crest
                const eCrestGeom = new THREE.BoxGeometry(0.05, 0.4, 0.2);
                const eCrest = new THREE.Mesh(eCrestGeom, enemyArmorMaterial);
                eCrest.position.set(0, 2.55, 0); eCrest.castShadow = true;
                enemy.add(eCrest);

                // Arms with pivots for animation
                const leftArmPivot = new THREE.Group();
                leftArmPivot.position.set(-0.55, 1.5, 0);
                enemy.add(leftArmPivot);
                const eArmGeom = new THREE.BoxGeometry(0.2, 0.7, 0.25);
                const eLeftArm = new THREE.Mesh(eArmGeom, enemyArmorMaterial);
                eLeftArm.position.y = -0.35; eLeftArm.castShadow = true;
                bodyParts.leftArm = eLeftArm; leftArmPivot.add(eLeftArm);

                const rightArmPivot = new THREE.Group();
                rightArmPivot.position.set(0.55, 1.5, 0);
                enemy.add(rightArmPivot);
                const eRightArm = new THREE.Mesh(eArmGeom, enemyArmorMaterial);
                eRightArm.position.y = -0.35; eRightArm.castShadow = true;
                bodyParts.rightArm = eRightArm; rightArmPivot.add(eRightArm);

                // Weapon based on type
                if (config.ranged) {
                    if (config.projectileType === 'arrow' || config.projectileType === 'firearrow') {
                        // Bow
                        const bowGeo = new THREE.TorusGeometry(0.4, 0.03, 8, 16, Math.PI);
                        const bow = new THREE.Mesh(bowGeo, new THREE.MeshStandardMaterial({color: 0x4a3728}));
                        bow.position.set(0, -0.5, 0.2);
                        bow.rotation.z = Math.PI / 2;
                        rightArmPivot.add(bow);
                    } else {
                        // Shuriken pouch visual
                        const pouch = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.15, 0.1), enemyArmorAccent);
                        pouch.position.set(0.3, 1, 0.3);
                        enemy.add(pouch);
                    }
                } else {
                    // Melee weapon - sword
                    const eSwordGroup = new THREE.Group();
                    eSwordGroup.position.set(0, -0.5, 0.15);
                    eSwordGroup.rotation.x = Math.PI / 2;
                    rightArmPivot.add(eSwordGroup);

                    const eHandleGeom = new THREE.BoxGeometry(0.08, 0.35, 0.08);
                    const eHandle = new THREE.Mesh(eHandleGeom, swordHandle);
                    eHandle.position.set(0, 0.1, 0); eHandle.castShadow = true;
                    eSwordGroup.add(eHandle);

                    const eGuardGeom = new THREE.BoxGeometry(0.2, 0.05, 0.15);
                    const eGuard = new THREE.Mesh(eGuardGeom, enemyArmorAccent);
                    eGuard.position.set(0, 0.3, 0); eGuard.castShadow = true;
                    eSwordGroup.add(eGuard);

                    const eBladeGeom = new THREE.BoxGeometry(0.06, 1.5, 0.02);
                    const eBlade = new THREE.Mesh(eBladeGeom, swordBlade);
                    eBlade.position.set(0, 1.1, 0); eBlade.castShadow = true;
                    eSwordGroup.add(eBlade);
                }

                // Legs with pivots for walking animation
                const leftLegPivot = new THREE.Group();
                leftLegPivot.position.set(-0.2, 0.8, 0);
                enemy.add(leftLegPivot);
                const eLegGeom = new THREE.BoxGeometry(0.25, 0.8, 0.3);
                const eLeftLeg = new THREE.Mesh(eLegGeom, enemyArmorAccent);
                eLeftLeg.position.y = -0.4; eLeftLeg.castShadow = true;
                bodyParts.leftLeg = eLeftLeg; leftLegPivot.add(eLeftLeg);

                const rightLegPivot = new THREE.Group();
                rightLegPivot.position.set(0.2, 0.8, 0);
                enemy.add(rightLegPivot);
                const eRightLeg = new THREE.Mesh(eLegGeom, enemyArmorAccent);
                eRightLeg.position.y = -0.4; eRightLeg.castShadow = true;
                bodyParts.rightLeg = eRightLeg; rightLegPivot.add(eRightLeg);

                // Store pivots for animation
                enemy.userData.leftArmPivot = leftArmPivot;
                enemy.userData.rightArmPivot = rightArmPivot;
                enemy.userData.leftLegPivot = leftLegPivot;
                enemy.userData.rightLegPivot = rightLegPivot;
            }

            // Position and rotate enemy
            enemy.position.set(x, 0, z);
            enemy.rotation.y = rotation;

            // Scale based on type
            enemy.scale.set(config.scale, config.scale, config.scale);

            scene.add(enemy);

            // Return enemy object with all stats for AI
            // Apply difficulty health multiplier
            const diff = difficultySettings[selectedDifficulty];
            const healthMult = config.isBoss ? diff.bossHealthMult : diff.enemyHealthMult;
            const adjustedHealth = Math.floor(config.health * healthMult);

            const enemyObj = {
                id: 'enemy_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                mesh: enemy,
                health: adjustedHealth,
                maxHealth: adjustedHealth,
                armor: config.armor,
                damage: config.damage,
                moveSpeed: config.moveSpeed,
                attackSpeed: config.attackSpeed,
                range: config.range,
                type: type,
                name: config.name,
                attackCooldown: 0,
                isAttacking: false,
                ranged: config.ranged || false,
                projectileType: config.projectileType,
                isBoss: config.isBoss || false,
                special: config.special,
                abilities: config.abilities || [],
                bodyParts: bodyParts,
                walkCycle: 0, // For animation
                attackAnim: 0 // For attack animation
            };

            // Initialize boss abilities
            if (enemyObj.isBoss) {
                initBossAbilities(enemyObj);
            }

            return enemyObj;
        }

        // Create gib (body part) when enemy dies
        function createGibs(enemy) {
            const pos = enemy.mesh.position.clone();
            const scale = enemy.mesh.scale.x;
            const parts = enemy.bodyParts;
            const colors = [enemy.mesh.children[0]?.material?.color?.getHex() || 0x444444];

            // Create falling body parts
            const partNames = ['head', 'body', 'leftArm', 'rightArm', 'leftLeg', 'rightLeg'];
            partNames.forEach((partName, i) => {
                const size = partName === 'body' ? 0.5 : (partName === 'head' ? 0.3 : 0.2);
                const gibGeo = new THREE.BoxGeometry(size * scale, size * scale, size * scale);
                const gibMat = new THREE.MeshStandardMaterial({ color: colors[0] });
                const gib = new THREE.Mesh(gibGeo, gibMat);

                // Position based on part
                const offsets = {
                    head: {x: 0, y: 2, z: 0},
                    body: {x: 0, y: 1.2, z: 0},
                    leftArm: {x: -0.5, y: 1.2, z: 0},
                    rightArm: {x: 0.5, y: 1.2, z: 0},
                    leftLeg: {x: -0.2, y: 0.4, z: 0},
                    rightLeg: {x: 0.2, y: 0.4, z: 0}
                };
                const offset = offsets[partName];
                gib.position.set(
                    pos.x + offset.x * scale,
                    pos.y + offset.y * scale,
                    pos.z + offset.z * scale
                );

                // Random velocity
                const vel = new THREE.Vector3(
                    (Math.random() - 0.5) * 8,
                    Math.random() * 5 + 3,
                    (Math.random() - 0.5) * 8
                );
                const rotVel = new THREE.Vector3(
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10
                );

                scene.add(gib);
                gibs.push({ mesh: gib, vel: vel, rotVel: rotVel, life: 3 });
            });
        }

        // Wave system
        const enemies = [];
        let currentWave = 0;
        const totalWaves = 50;
        let waveInProgress = false;
        let waveStartDelay = false;

        // Wave definitions - 30 waves with gradual difficulty increase
        const waves = [
            // Wave 1-5: Introduction (very easy)
            { enemies: [
                { type: 'ashigaru', x: 0, z: -12 }
            ]},
            { enemies: [
                { type: 'ashigaru', x: 6, z: -10 },
                { type: 'ashigaru', x: -6, z: -10 }
            ]},
            { enemies: [
                { type: 'ashigaru', x: 8, z: -8 },
                { type: 'ashigaru', x: -8, z: -8 },
                { type: 'ashigaru', x: 0, z: -12 }
            ]},
            { enemies: [
                { type: 'ashigaru', x: 10, z: -8 },
                { type: 'ashigaru', x: -10, z: -8 },
                { type: 'scout', x: 0, z: -15 }
            ]},
            { enemies: [
                { type: 'ashigaru', x: 8, z: -8 },
                { type: 'ashigaru', x: -8, z: -8 },
                { type: 'scout', x: 5, z: -12 },
                { type: 'scout', x: -5, z: -12 }
            ]},
            // Wave 6-9: Ronin and ranged introduced
            { enemies: [
                { type: 'ashigaru', x: 10, z: -5 },
                { type: 'ashigaru', x: -10, z: -5 },
                { type: 'ronin', x: 0, z: -12 },
                { type: 'shuriken', x: 0, z: -18 }
            ]},
            { enemies: [
                { type: 'ronin', x: 8, z: -10 },
                { type: 'ronin', x: -8, z: -10 },
                { type: 'shuriken', x: 5, z: -15 },
                { type: 'shuriken', x: -5, z: -15 }
            ]},
            { enemies: [
                { type: 'ashigaru', x: 12, z: -5 },
                { type: 'ashigaru', x: -12, z: -5 },
                { type: 'ronin', x: 6, z: -12 },
                { type: 'archer', x: 0, z: -20 }
            ]},
            { enemies: [
                { type: 'ronin', x: 8, z: -8 },
                { type: 'ronin', x: -8, z: -8 },
                { type: 'shuriken', x: 10, z: -12 },
                { type: 'archer', x: -10, z: -18 },
                { type: 'ashigaru', x: 0, z: -15 }
            ]},
            // Wave 10: BOSS - Knight in Shining Armor
            { enemies: [
                { type: 'knight', x: 0, z: -20 }
            ], boss: true },
            // Wave 11-15: Samurai, spearmen and more ranged
            { enemies: [
                { type: 'ronin', x: 10, z: -5 },
                { type: 'ronin', x: -10, z: -5 },
                { type: 'samurai', x: 0, z: -15 },
                { type: 'archer', x: 8, z: -20 },
                { type: 'archer', x: -8, z: -20 }
            ]},
            { enemies: [
                { type: 'samurai', x: 8, z: -10 },
                { type: 'ronin', x: -8, z: -10 },
                { type: 'shuriken', x: 5, z: -15 },
                { type: 'shuriken', x: -5, z: -15 },
                { type: 'crossbow', x: 0, z: -22 }
            ]},
            { enemies: [
                { type: 'ronin', x: 12, z: -5 },
                { type: 'ronin', x: -12, z: -5 },
                { type: 'samurai', x: 6, z: -12 },
                { type: 'spearman', x: 0, z: -18 },
                { type: 'archer', x: 10, z: -20 }
            ]},
            { enemies: [
                { type: 'spearman', x: 8, z: -10 },
                { type: 'spearman', x: -8, z: -10 },
                { type: 'ronin', x: 0, z: -8 },
                { type: 'crossbow', x: 10, z: -18 },
                { type: 'crossbow', x: -10, z: -18 }
            ]},
            { enemies: [
                { type: 'samurai', x: 10, z: -8 },
                { type: 'samurai', x: -10, z: -8 },
                { type: 'spearman', x: 5, z: -12 },
                { type: 'archer', x: -5, z: -18 },
                { type: 'shuriken', x: 0, z: -15 }
            ]},
            // Wave 16-19: Ninja, brute, and fire archers
            { enemies: [
                { type: 'ninja', x: 8, z: -8 },
                { type: 'ninja', x: -8, z: -8 },
                { type: 'ronin', x: 0, z: -12 },
                { type: 'fireArcher', x: 0, z: -22 }
            ]},
            { enemies: [
                { type: 'samurai', x: 10, z: -5 },
                { type: 'samurai', x: -10, z: -5 },
                { type: 'ninja', x: 6, z: -12 },
                { type: 'shuriken', x: -6, z: -12 },
                { type: 'fireArcher', x: 8, z: -20 },
                { type: 'fireArcher', x: -8, z: -20 }
            ]},
            { enemies: [
                { type: 'brute', x: 0, z: -15 },
                { type: 'ronin', x: 10, z: -8 },
                { type: 'ronin', x: -10, z: -8 },
                { type: 'crossbow', x: 8, z: -18 },
                { type: 'crossbow', x: -8, z: -18 }
            ]},
            { enemies: [
                { type: 'ninja', x: 12, z: -5 },
                { type: 'ninja', x: -12, z: -5 },
                { type: 'brute', x: 0, z: -12 },
                { type: 'archer', x: 8, z: -20 },
                { type: 'fireArcher', x: -8, z: -20 }
            ]},
            // Wave 20: BOSS - Werewolf
            { enemies: [
                { type: 'werewolf', x: 0, z: -20 }
            ], boss: true },
            // Wave 21-25: Elite enemies with ranged support (medium-hard)
            { enemies: [
                { type: 'guardian', x: 0, z: -12 },
                { type: 'samurai', x: 10, z: -8 },
                { type: 'samurai', x: -10, z: -8 },
                { type: 'fireArcher', x: 6, z: -22 },
                { type: 'fireArcher', x: -6, z: -22 }
            ]},
            { enemies: [
                { type: 'elite', x: 0, z: -15 },
                { type: 'brute', x: 10, z: -10 },
                { type: 'brute', x: -10, z: -10 },
                { type: 'crossbow', x: 8, z: -20 },
                { type: 'crossbow', x: -8, z: -20 }
            ]},
            { enemies: [
                { type: 'monk', x: 8, z: -10 },
                { type: 'monk', x: -8, z: -10 },
                { type: 'guardian', x: 0, z: -15 },
                { type: 'shuriken', x: 12, z: -18 },
                { type: 'fireArcher', x: -12, z: -20 }
            ]},
            { enemies: [
                { type: 'berserker', x: 8, z: -8 },
                { type: 'berserker', x: -8, z: -8 },
                { type: 'elite', x: 0, z: -12 },
                { type: 'ninja', x: 10, z: -15 },
                { type: 'archer', x: 0, z: -25 }
            ]},
            { enemies: [
                { type: 'elite', x: 8, z: -10 },
                { type: 'elite', x: -8, z: -10 },
                { type: 'guardian', x: 0, z: -8 },
                { type: 'fireArcher', x: 10, z: -20 },
                { type: 'fireArcher', x: -10, z: -20 },
                { type: 'monk', x: 0, z: -20 }
            ]},
            // Wave 26-29: Shadow and warlord with heavy ranged (hard)
            { enemies: [
                { type: 'shadow', x: 10, z: -8 },
                { type: 'shadow', x: -10, z: -8 },
                { type: 'elite', x: 0, z: -12 },
                { type: 'crossbow', x: 8, z: -22 },
                { type: 'crossbow', x: -8, z: -22 },
                { type: 'guardian', x: 0, z: -20 }
            ]},
            { enemies: [
                { type: 'warlord', x: 0, z: -18 },
                { type: 'elite', x: 10, z: -10 },
                { type: 'elite', x: -10, z: -10 },
                { type: 'fireArcher', x: 6, z: -25 },
                { type: 'fireArcher', x: -6, z: -25 }
            ]},
            { enemies: [
                { type: 'phantom', x: 8, z: -8 },
                { type: 'phantom', x: -8, z: -8 },
                { type: 'shadow', x: 0, z: -10 },
                { type: 'warlord', x: 10, z: -15 },
                { type: 'crossbow', x: -10, z: -22 },
                { type: 'crossbow', x: 10, z: -22 }
            ]},
            { enemies: [
                { type: 'shogun', x: 0, z: -15 },
                { type: 'warlord', x: 10, z: -10 },
                { type: 'warlord', x: -10, z: -10 },
                { type: 'fireArcher', x: 8, z: -25 },
                { type: 'fireArcher', x: -8, z: -25 },
                { type: 'phantom', x: 0, z: -8 }
            ]},
            // Wave 30: BOSS - DRAGON (Character unlock milestone)
            { enemies: [
                { type: 'dragon', x: 0, z: -30 }
            ], boss: true },

            // ========== BONUS WAVES 31-50 (Extra challenge, not required for unlocks) ==========

            // Wave 31: Elite Introduction
            { enemies: [
                { type: 'eliteSamurai', x: 10, z: -15 },
                { type: 'eliteSamurai', x: -10, z: -15 },
                { type: 'shadowNinja', x: 0, z: -20 },
                { type: 'basic', x: 15, z: -10 },
                { type: 'basic', x: -15, z: -10 }
            ]},
            // Wave 32: Mage Assault
            { enemies: [
                { type: 'warMage', x: 0, z: -25 },
                { type: 'warMage', x: 12, z: -20 },
                { type: 'warMage', x: -12, z: -20 },
                { type: 'shieldBearer', x: 0, z: -15 },
                { type: 'shieldBearer', x: 8, z: -12 }
            ]},
            // Wave 33: Berserker Rush
            { enemies: [
                { type: 'berserker', x: 0, z: -18 },
                { type: 'berserker', x: 10, z: -15 },
                { type: 'berserker', x: -10, z: -15 },
                { type: 'eliteSamurai', x: 5, z: -22 },
                { type: 'eliteSamurai', x: -5, z: -22 }
            ]},
            // Wave 34: Shadow Legion
            { enemies: [
                { type: 'shadowNinja', x: 8, z: -12 },
                { type: 'shadowNinja', x: -8, z: -12 },
                { type: 'shadowNinja', x: 12, z: -18 },
                { type: 'shadowNinja', x: -12, z: -18 },
                { type: 'shadowNinja', x: 0, z: -25 },
                { type: 'phantom', x: 0, z: -15 }
            ]},
            // Wave 35: Phalanx Formation
            { enemies: [
                { type: 'shieldBearer', x: -6, z: -12 },
                { type: 'shieldBearer', x: 0, z: -12 },
                { type: 'shieldBearer', x: 6, z: -12 },
                { type: 'spearman', x: -6, z: -18 },
                { type: 'spearman', x: 0, z: -18 },
                { type: 'spearman', x: 6, z: -18 },
                { type: 'iceArcher', x: 0, z: -25 }
            ]},
            // Wave 36: Demon Vanguard
            { enemies: [
                { type: 'demonSpawn', x: 10, z: -15 },
                { type: 'demonSpawn', x: -10, z: -15 },
                { type: 'demonSpawn', x: 0, z: -20 },
                { type: 'fireArcher', x: 15, z: -25 },
                { type: 'fireArcher', x: -15, z: -25 },
                { type: 'warMage', x: 0, z: -28 }
            ]},
            // Wave 37: Death Knights
            { enemies: [
                { type: 'deathKnight', x: 8, z: -15 },
                { type: 'deathKnight', x: -8, z: -15 },
                { type: 'shadowNinja', x: 15, z: -20 },
                { type: 'shadowNinja', x: -15, z: -20 },
                { type: 'eliteSamurai', x: 0, z: -22 }
            ]},
            // Wave 38: Void Incursion
            { enemies: [
                { type: 'voidWalker', x: 5, z: -10 },
                { type: 'voidWalker', x: -5, z: -10 },
                { type: 'voidWalker', x: 10, z: -15 },
                { type: 'voidWalker', x: -10, z: -15 },
                { type: 'warMage', x: 0, z: -25 },
                { type: 'warMage', x: 8, z: -25 }
            ]},
            // Wave 39: Pre-Boss Gauntlet
            { enemies: [
                { type: 'deathKnight', x: 0, z: -12 },
                { type: 'berserker', x: 10, z: -15 },
                { type: 'berserker', x: -10, z: -15 },
                { type: 'demonSpawn', x: 5, z: -20 },
                { type: 'demonSpawn', x: -5, z: -20 },
                { type: 'warMage', x: 12, z: -25 },
                { type: 'warMage', x: -12, z: -25 },
                { type: 'voidWalker', x: 0, z: -8 }
            ]},
            // Wave 40: BOSS - DEMON LORD
            { enemies: [
                { type: 'demonLord', x: 0, z: -25 }
            ], boss: true },

            // Wave 41: Hell's Army
            { enemies: [
                { type: 'demonSpawn', x: 8, z: -12 },
                { type: 'demonSpawn', x: -8, z: -12 },
                { type: 'demonSpawn', x: 12, z: -18 },
                { type: 'demonSpawn', x: -12, z: -18 },
                { type: 'fireArcher', x: 0, z: -25 },
                { type: 'fireArcher', x: 10, z: -25 },
                { type: 'berserker', x: 0, z: -15 }
            ]},
            // Wave 42: Elite Guard
            { enemies: [
                { type: 'eliteSamurai', x: 6, z: -12 },
                { type: 'eliteSamurai', x: -6, z: -12 },
                { type: 'eliteSamurai', x: 10, z: -18 },
                { type: 'eliteSamurai', x: -10, z: -18 },
                { type: 'deathKnight', x: 0, z: -15 },
                { type: 'shieldBearer', x: 0, z: -22 }
            ]},
            // Wave 43: Lake Awakens (WATER ENEMIES!)
            { enemies: [
                { type: 'waterSerpent', x: -30, z: 20 },
                { type: 'waterSerpent', x: -35, z: 28 },
                { type: 'waterSerpent', x: -25, z: 30 },
                { type: 'kappa', x: -28, z: 22 },
                { type: 'kappa', x: -32, z: 26 },
                { type: 'drownedWarrior', x: -30, z: 35 }
            ]},
            // Wave 44: Tidal Terror
            { enemies: [
                { type: 'tidalWraith', x: -30, z: 18 },
                { type: 'tidalWraith', x: -35, z: 25 },
                { type: 'drownedWarrior', x: -25, z: 22 },
                { type: 'drownedWarrior', x: -28, z: 30 },
                { type: 'seaMonk', x: -40, z: 28 },
                { type: 'seaMonk', x: -20, z: 28 },
                { type: 'waterSerpent', x: -30, z: 32 }
            ]},
            // Wave 45: Deep Ones Rise
            { enemies: [
                { type: 'deepOne', x: -30, z: 20 },
                { type: 'deepOne', x: -35, z: 30 },
                { type: 'tidalWraith', x: -25, z: 25 },
                { type: 'tidalWraith', x: -32, z: 28 },
                { type: 'kappa', x: -28, z: 18 },
                { type: 'kappa', x: -30, z: 35 },
                { type: 'seaMonk', x: -40, z: 22 }
            ]},
            // Wave 46: Land and Sea
            { enemies: [
                { type: 'deepOne', x: -30, z: 25 },
                { type: 'tidalWraith', x: -28, z: 30 },
                { type: 'waterSerpent', x: -35, z: 22 },
                { type: 'deathKnight', x: 10, z: -15 },
                { type: 'deathKnight', x: -10, z: -15 },
                { type: 'demonSpawn', x: 5, z: -12 },
                { type: 'demonSpawn', x: -5, z: -12 },
                { type: 'fireArcher', x: 0, z: -25 }
            ]},
            // Wave 47: Champions
            { enemies: [
                { type: 'deathKnight', x: 0, z: -15 },
                { type: 'deathKnight', x: 10, z: -18 },
                { type: 'deathKnight', x: -10, z: -18 },
                { type: 'berserker', x: 5, z: -12 },
                { type: 'berserker', x: -5, z: -12 },
                { type: 'eliteSamurai', x: 8, z: -22 },
                { type: 'eliteSamurai', x: -8, z: -22 }
            ]},
            // Wave 48: Apocalypse (All Forces)
            { enemies: [
                { type: 'voidWalker', x: 6, z: -10 },
                { type: 'voidWalker', x: -6, z: -10 },
                { type: 'deepOne', x: -30, z: 22 },
                { type: 'deepOne', x: -32, z: 28 },
                { type: 'tidalWraith', x: -25, z: 25 },
                { type: 'demonSpawn', x: 0, z: -18 },
                { type: 'demonSpawn', x: 8, z: -20 },
                { type: 'deathKnight', x: -8, z: -20 },
                { type: 'warMage', x: 0, z: -28 }
            ]},
            // Wave 49: Final Gauntlet
            { enemies: [
                { type: 'deathKnight', x: 0, z: -12 },
                { type: 'deathKnight', x: 8, z: -15 },
                { type: 'deathKnight', x: -8, z: -15 },
                { type: 'berserker', x: 12, z: -18 },
                { type: 'berserker', x: -12, z: -18 },
                { type: 'voidWalker', x: 5, z: -8 },
                { type: 'voidWalker', x: -5, z: -8 },
                { type: 'warMage', x: 10, z: -25 },
                { type: 'warMage', x: -10, z: -25 },
                { type: 'demonSpawn', x: 0, z: -22 }
            ]},
            // Wave 50: TRUE FINAL BOSS - ANCIENT GOD
            { enemies: [
                { type: 'ancientGod', x: 0, z: -30 }
            ], boss: true }
        ];

        // UI elements
        const waveNumberEl = document.getElementById('waveNumber');
        const enemyCountEl = document.getElementById('enemyCount');
        const waveAnnouncementEl = document.getElementById('waveAnnouncement');
        const bossHealthBarEl = document.getElementById('bossHealthBar');
        const bossHealthBarInnerEl = document.getElementById('bossHealthBarInner');
        const bossHealthBarTextEl = document.getElementById('bossHealthBarText');
        const bossNameEl = document.getElementById('bossName');
        let currentBoss = null;

        function showBossHealthBar(boss) {
            currentBoss = boss;
            bossNameEl.textContent = boss.config.name;
            bossHealthBarEl.classList.remove('hidden');
            updateBossHealthBar();
        }

        function updateBossHealthBar() {
            if (!currentBoss || !currentBoss.mesh) {
                hideBossHealthBar();
                return;
            }
            const percent = Math.max(0, (currentBoss.health / currentBoss.maxHealth) * 100);
            bossHealthBarInnerEl.style.width = percent + '%';
            bossHealthBarTextEl.textContent = Math.ceil(currentBoss.health) + ' / ' + currentBoss.maxHealth;
        }

        function hideBossHealthBar() {
            currentBoss = null;
            bossHealthBarEl.classList.add('hidden');
        }

        const bossAttackWarningEl = document.getElementById('bossAttackWarning');
        let attackWarningTimeout = null;

        function showBossAttackWarning(attackName, duration = 1000) {
            if (attackWarningTimeout) clearTimeout(attackWarningTimeout);
            bossAttackWarningEl.textContent = 'âš  ' + attackName + ' âš ';
            bossAttackWarningEl.classList.add('visible');
            attackWarningTimeout = setTimeout(() => {
                bossAttackWarningEl.classList.remove('visible');
            }, duration);
        }

        // Function to show wave announcement
        function announceWave(waveNum) {
            if (waveNum <= totalWaves) {
                const wave = waves[waveNum - 1];
                if (wave.boss) {
                    // Boss wave announcements
                    if (waveNum === 10) {
                        waveAnnouncementEl.textContent = 'BOSS: KNIGHT!';
                        waveAnnouncementEl.style.color = '#c0c0c0';
                    } else if (waveNum === 20) {
                        waveAnnouncementEl.textContent = 'BOSS: WEREWOLF!';
                        waveAnnouncementEl.style.color = '#ff8800';
                    } else if (waveNum === 30) {
                        // Use themed dragon name based on map
                        waveAnnouncementEl.textContent = `BOSS: ${currentMap.dragonTheme.name.toUpperCase()}!`;
                        waveAnnouncementEl.style.color = '#ff4400';
                    } else if (waveNum === 40) {
                        waveAnnouncementEl.textContent = 'BOSS: DEMON LORD!';
                        waveAnnouncementEl.style.color = '#ff0044';
                    } else if (waveNum === 50) {
                        waveAnnouncementEl.textContent = 'TRUE FINAL BOSS: ANCIENT GOD!';
                        waveAnnouncementEl.style.color = '#ffd700';
                    }
                } else if (waveNum === 31) {
                    waveAnnouncementEl.textContent = 'BONUS WAVES BEGIN!';
                    waveAnnouncementEl.style.color = '#ff88ff';
                } else if (waveNum > 30) {
                    waveAnnouncementEl.textContent = `Bonus Wave ${waveNum}`;
                    waveAnnouncementEl.style.color = '#ff88ff';
                } else if (waveNum === 1) {
                    // Show map name on first wave
                    waveAnnouncementEl.textContent = `${currentMap.name} - Wave 1`;
                    waveAnnouncementEl.style.color = 'white';
                } else {
                    waveAnnouncementEl.textContent = `Wave ${waveNum}`;
                    waveAnnouncementEl.style.color = 'white';
                }
                waveAnnouncementEl.style.opacity = '1';
                setTimeout(() => {
                    waveAnnouncementEl.style.opacity = '0';
                }, 2000);
            } else {
                waveAnnouncementEl.textContent = 'ULTIMATE VICTORY!';
                waveAnnouncementEl.style.color = '#ffd700';
                waveAnnouncementEl.style.opacity = '1';
            }
        }

        // Create enemy projectile (slow, inaccurate, can friendly fire)
        function createEnemyProjectile(enemy, targetX, targetZ) {
            const pos = enemy.mesh.position.clone();
            pos.y = 1.5 * enemy.mesh.scale.y;

            // Add inaccuracy - random spread (larger = easier to dodge)
            const inaccuracy = 0.35; // 35% directional spread
            const spreadX = (Math.random() - 0.5) * inaccuracy * 10;
            const spreadZ = (Math.random() - 0.5) * inaccuracy * 10;
            const aimX = targetX + spreadX;
            const aimZ = targetZ + spreadZ;

            const dir = new THREE.Vector3(aimX - pos.x, 0, aimZ - pos.z).normalize();

            let geo, mat, speed, size;
            const pType = enemy.projectileType;

            // VERY slow enemy projectile speeds - extremely easy to dodge
            if (pType === 'shuriken') {
                geo = new THREE.BoxGeometry(0.15, 0.02, 0.15);
                mat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8 });
                speed = 4; // Super slow, easy sidestep
            } else if (pType === 'arrow') {
                geo = new THREE.BoxGeometry(0.05, 0.05, 0.8);
                mat = new THREE.MeshStandardMaterial({ color: 0x4a3728 });
                speed = 5; // Very slow arrow
            } else if (pType === 'bolt') {
                geo = new THREE.BoxGeometry(0.06, 0.06, 0.6);
                mat = new THREE.MeshStandardMaterial({ color: 0x333333 });
                speed = 6; // Slow bolt
            } else if (pType === 'firearrow' || pType === 'fireball') {
                geo = pType === 'fireball' ? new THREE.SphereGeometry(0.4) : new THREE.BoxGeometry(0.05, 0.05, 0.8);
                mat = new THREE.MeshBasicMaterial({ color: 0xff4400 });
                speed = pType === 'fireball' ? 5 : 4; // Slow fire projectiles
            } else {
                geo = new THREE.SphereGeometry(0.1);
                mat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                speed = 4;
            }

            const proj = new THREE.Mesh(geo, mat);
            proj.position.copy(pos);
            proj.lookAt(pos.clone().add(dir));
            scene.add(proj);

            projectiles.push({
                mesh: proj,
                dir: dir,
                speed: speed,
                damage: enemy.damage,
                isRanged: true,
                type: pType,
                life: 5, // Longer life since slower
                sourceEnemy: enemy // Track source for friendly fire
            });

            // Fire effect for fire arrows
            if (pType === 'firearrow' || pType === 'fireball') {
                createFireEffect(pos.x, pos.y, pos.z);
            }
        }

        // Update projectiles
        function updateProjectiles(deltaTime) {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                proj.life -= deltaTime;

                if (proj.life <= 0) {
                    scene.remove(proj.mesh);
                    projectiles.splice(i, 1);
                    continue;
                }

                // Move projectile
                proj.mesh.position.x += proj.dir.x * proj.speed * deltaTime;
                proj.mesh.position.z += proj.dir.z * proj.speed * deltaTime;

                // Spin shurikens
                if (proj.type === 'shuriken') {
                    proj.mesh.rotation.y += deltaTime * 20;
                }

                // Check friendly fire (projectiles hit other enemies!)
                let hitEnemy = false;
                for (let e = enemies.length - 1; e >= 0; e--) {
                    const enemy = enemies[e];
                    // Don't hit the source enemy
                    if (enemy === proj.sourceEnemy) continue;

                    const edx = proj.mesh.position.x - enemy.mesh.position.x;
                    const edz = proj.mesh.position.z - enemy.mesh.position.z;
                    const eDist = Math.sqrt(edx * edx + edz * edz);

                    if (eDist < 1.5) {
                        // Friendly fire! Hit the enemy
                        enemy.health -= proj.damage;

                        // Flash enemy
                        enemy.mesh.children.forEach(child => {
                            if (child.material && child.material.emissive) {
                                child.material.emissive.setHex(0xff0000);
                                setTimeout(() => { child.material.emissive.setHex(0x000000); }, 100);
                            }
                        });

                        // Check if enemy died from friendly fire
                        if (enemy.health <= 0) {
                            createGibs(enemy);
                            scene.remove(enemy.mesh);
                            enemies.splice(e, 1);
                            onEnemyKilled(enemy);
                            updateEnemyCount();
                        }

                        scene.remove(proj.mesh);
                        projectiles.splice(i, 1);
                        hitEnemy = true;
                        break;
                    }
                }
                if (hitEnemy) continue;

                // Check collision with player
                const dx = proj.mesh.position.x - player.position.x;
                const dz = proj.mesh.position.z - player.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < 1) {
                    // Hit player
                    let damage = proj.damage;

                    // Deflect chance
                    if (playerStats.deflectChance && Math.random() < playerStats.deflectChance) {
                        showAbilityEffect('Deflected!');
                        scene.remove(proj.mesh);
                        projectiles.splice(i, 1);
                        continue;
                    }

                    // Ranged resist
                    if (playerStats.rangedResist) {
                        damage *= (1 - playerStats.rangedResist);
                    }

                    // Parry can block ranged too
                    if (isParrying) {
                        damage *= (1 - playerStats.parryDamageReduction);
                    }

                    // Iron fortress
                    if (ironFortressActive) damage = 0;

                    // Dodge
                    if (playerStats.dodgeChance && Math.random() < playerStats.dodgeChance) {
                        damage = 0;
                    }

                    // Knight block chance
                    if (damage > 0 && playerStats.blockChance && Math.random() < playerStats.blockChance) {
                        showAbilityEffect('BLOCKED!');
                        damage = 0;
                    }

                    // Dodge invincibility
                    if (isInvincible) {
                        damage = 0;
                    }

                    if (damage > 0) {
                        playerHealth -= Math.floor(damage);
                        timeSinceLastHit = 0;
                        updatePlayerHealth();
                    }

                    scene.remove(proj.mesh);
                    projectiles.splice(i, 1);
                }
            }
        }

        // Update visual effects (ability particles, shockwaves, etc.)
        function updateVisualEffects(deltaTime) {
            for (let i = visualEffects.length - 1; i >= 0; i--) {
                const effect = visualEffects[i];
                effect.life -= deltaTime;

                if (effect.life <= 0) {
                    scene.remove(effect.mesh);
                    visualEffects.splice(i, 1);
                    continue;
                }

                if (effect.type === 'shockwave') {
                    effect.scale += deltaTime * 15;
                    effect.mesh.scale.set(effect.scale, effect.scale, 1);
                    effect.mesh.material.opacity = effect.life;
                } else if (effect.type === 'drain') {
                    // Move toward player
                    const dx = player.position.x - effect.mesh.position.x;
                    const dy = player.position.y + 1 - effect.mesh.position.y;
                    const dz = player.position.z - effect.mesh.position.z;
                    effect.mesh.position.x += dx * deltaTime * 3;
                    effect.mesh.position.y += dy * deltaTime * 3;
                    effect.mesh.position.z += dz * deltaTime * 3;
                } else if (effect.type === 'fire') {
                    effect.mesh.position.y += deltaTime * 2;
                    effect.mesh.scale.multiplyScalar(0.95);
                } else if (effect.type === 'hit') {
                    // Hit burst expands and fades
                    const scale = 1 + (0.3 - effect.life) * 3;
                    effect.mesh.scale.set(scale, scale, scale);
                    effect.mesh.material.opacity = effect.life / 0.3;
                } else if (effect.type === 'hitParticle') {
                    // Hit particles fly outward
                    if (effect.mesh.userData.velocity) {
                        effect.mesh.position.x += effect.mesh.userData.velocity.x * deltaTime;
                        effect.mesh.position.y += effect.mesh.userData.velocity.y * deltaTime;
                        effect.mesh.position.z += effect.mesh.userData.velocity.z * deltaTime;
                        effect.mesh.userData.velocity.y -= 10 * deltaTime; // gravity
                    }
                    effect.mesh.material.opacity = effect.life / 0.4;
                }
            }

            // Update visual projectiles (wind slash, fireballs, homing balls, etc.)
            for (let i = visualProjectiles.length - 1; i >= 0; i--) {
                const proj = visualProjectiles[i];
                proj.life -= deltaTime;

                if (proj.life <= 0) {
                    scene.remove(proj.mesh);
                    visualProjectiles.splice(i, 1);
                    continue;
                }

                // Handle homing projectiles
                if (proj.isHomingBall && proj.target && enemies.includes(proj.target)) {
                    const targetPos = proj.target.mesh.position;
                    const dx = targetPos.x - proj.mesh.position.x;
                    const dz = targetPos.z - proj.mesh.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist > 0.5) {
                        const homeSpeed = 12;
                        proj.velocity.x += (dx / dist) * homeSpeed * deltaTime * 3;
                        proj.velocity.z += (dz / dist) * homeSpeed * deltaTime * 3;
                        const speed = Math.sqrt(proj.velocity.x * proj.velocity.x + proj.velocity.z * proj.velocity.z);
                        if (speed > 18) {
                            proj.velocity.x = (proj.velocity.x / speed) * 18;
                            proj.velocity.z = (proj.velocity.z / speed) * 18;
                        }
                    }
                    // Trail effect
                    if (Math.random() > 0.5) {
                        const trailGeo = new THREE.SphereGeometry(0.15);
                        const trailMat = new THREE.MeshBasicMaterial({ color: 0x9966ff, transparent: true, opacity: 0.5 });
                        const trail = new THREE.Mesh(trailGeo, trailMat);
                        trail.position.copy(proj.mesh.position);
                        scene.add(trail);
                        setTimeout(() => scene.remove(trail), 150);
                    }
                }

                // Move projectile
                if (proj.velocity) {
                    proj.mesh.position.x += proj.velocity.x * deltaTime;
                    proj.mesh.position.z += proj.velocity.z * deltaTime;
                } else if (proj.dir) {
                    proj.mesh.position.x += proj.dir.x * 20 * deltaTime;
                    proj.mesh.position.z += proj.dir.z * 20 * deltaTime;
                }

                // Check range limit for wizard spells
                if (proj.maxRange && proj.startPos) {
                    const dx = proj.mesh.position.x - proj.startPos.x;
                    const dz = proj.mesh.position.z - proj.startPos.z;
                    const distTraveled = Math.sqrt(dx * dx + dz * dz);
                    if (distTraveled >= proj.maxRange) {
                        // Fireball explodes at max range
                        if (proj.isFireball) {
                            createEpicExplosion(proj.mesh.position.x, 1, proj.mesh.position.z, 0xff4400, 1.5, 10);
                        }
                        scene.remove(proj.mesh);
                        visualProjectiles.splice(i, 1);
                        continue;
                    }
                }

                // Fireball trail effect
                if (proj.isFireball && Math.random() > 0.3) {
                    const trailGeo = new THREE.SphereGeometry(0.2 + Math.random() * 0.2);
                    const trailMat = new THREE.MeshBasicMaterial({ color: Math.random() > 0.5 ? 0xff4400 : 0xff8800, transparent: true, opacity: 0.6 });
                    const trail = new THREE.Mesh(trailGeo, trailMat);
                    trail.position.copy(proj.mesh.position);
                    scene.add(trail);
                    setTimeout(() => scene.remove(trail), 200);
                }

                // Hit enemies
                let hitEnemy = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    const dx = proj.mesh.position.x - enemy.mesh.position.x;
                    const dz = proj.mesh.position.z - enemy.mesh.position.z;
                    const hitDist = proj.isFireball ? 1.5 : (proj.isHomingBall ? 1.2 : 2);
                    if (Math.sqrt(dx*dx + dz*dz) < hitDist) {
                        if (proj.isFireball) {
                            hitEnemy = true;
                            const explosionRadius = proj.explosionRadius || 5;
                            createEpicExplosion(proj.mesh.position.x, 1, proj.mesh.position.z, 0xff4400, 2, 20);
                            screenShake(0.4, 0.3);
                            for (let k = enemies.length - 1; k >= 0; k--) {
                                const e = enemies[k];
                                const edx = proj.mesh.position.x - e.mesh.position.x;
                                const edz = proj.mesh.position.z - e.mesh.position.z;
                                if (Math.sqrt(edx*edx + edz*edz) < explosionRadius) {
                                    dealDamageToEnemy(k, proj.damage);
                                }
                            }
                            break;
                        } else if (proj.isHomingBall) {
                            hitEnemy = true;
                            dealDamageToEnemy(j, proj.damage);
                            createShockwaveEffect(proj.mesh.position.x, proj.mesh.position.z, 0x9966ff);
                            break;
                        } else {
                            dealDamageToEnemy(j, proj.damage);
                        }
                    }
                }

                if (hitEnemy) {
                    scene.remove(proj.mesh);
                    visualProjectiles.splice(i, 1);
                }
            }
        }

        // Update gibs (falling body parts)
        function updateGibs(deltaTime) {
            for (let i = gibs.length - 1; i >= 0; i--) {
                const gib = gibs[i];
                gib.life -= deltaTime;

                if (gib.life <= 0) {
                    scene.remove(gib.mesh);
                    gibs.splice(i, 1);
                    continue;
                }

                // Apply physics
                gib.vel.y -= 20 * deltaTime; // Gravity
                gib.mesh.position.x += gib.vel.x * deltaTime;
                gib.mesh.position.y += gib.vel.y * deltaTime;
                gib.mesh.position.z += gib.vel.z * deltaTime;

                // Rotation
                gib.mesh.rotation.x += gib.rotVel.x * deltaTime;
                gib.mesh.rotation.y += gib.rotVel.y * deltaTime;
                gib.mesh.rotation.z += gib.rotVel.z * deltaTime;

                // Ground collision
                if (gib.mesh.position.y < 0.1) {
                    gib.mesh.position.y = 0.1;
                    gib.vel.y *= -0.3; // Bounce
                    gib.vel.x *= 0.8; // Friction
                    gib.vel.z *= 0.8;
                    gib.rotVel.multiplyScalar(0.5);
                }

                // Fade out
                if (gib.life < 1) {
                    gib.mesh.material.opacity = gib.life;
                    gib.mesh.material.transparent = true;
                }
            }
        }

        // ========== BOSS ABILITY SYSTEM ==========
        const bossAbilityCooldowns = {};

        function initBossAbilities(enemy) {
            if (!enemy.isBoss) return;
            enemy.abilityCooldowns = {};
            enemy.currentAbility = null;
            enemy.abilityTimer = 0;
            enemy.globalCooldown = 0; // Cooldown between ANY abilities
            enemy.phase = 1; // Bosses get more aggressive in later phases
            enemy.enraged = false;

            // Initialize cooldowns
            if (enemy.abilities) {
                enemy.abilities.forEach(ab => {
                    enemy.abilityCooldowns[ab] = 2 + Math.random() * 2; // Start with cooldown
                });
            }

            // Dragon gets a themed ability based on current map
            if (enemy.config && enemy.config.special === 'dragon') {
                enemy.abilityCooldowns.themedAbility = 15; // Start with 15 second cooldown
            }
        }

        function updateBossAbilities(enemy, deltaTime, distance) {
            if (!enemy.isBoss || !enemy.abilities) return false;

            // Update phase based on health
            const healthPercent = enemy.health / enemy.maxHealth;
            if (healthPercent < 0.3 && enemy.phase < 3) {
                enemy.phase = 3;
                enemy.enraged = true;
                showBossMessage('ENRAGED!', 0xff0000);
                createShockwaveEffect(enemy.mesh.position.x, enemy.mesh.position.z, 0xff0000);
            } else if (healthPercent < 0.6 && enemy.phase < 2) {
                enemy.phase = 2;
                showBossMessage('Phase 2!', 0xff8800);
            }

            // Update global cooldown (time between any abilities)
            if (enemy.globalCooldown > 0) {
                enemy.globalCooldown -= deltaTime * (enemy.enraged ? 1.3 : 1);
            }

            // Update individual ability cooldowns
            for (const ab in enemy.abilityCooldowns) {
                if (enemy.abilityCooldowns[ab] > 0) {
                    enemy.abilityCooldowns[ab] -= deltaTime * (enemy.enraged ? 1.3 : 1);
                }
            }

            // Execute current ability animation
            if (enemy.currentAbility) {
                enemy.abilityTimer -= deltaTime;
                if (enemy.abilityTimer <= 0) {
                    enemy.currentAbility = null;
                }
                return true; // Boss is busy with ability
            }

            // Global cooldown prevents ability spam
            if (enemy.globalCooldown > 0) {
                return false; // Can't use abilities yet
            }

            // Try to use abilities based on boss type
            if (enemy.special === 'knight') {
                return updateKnightBoss(enemy, deltaTime, distance);
            } else if (enemy.special === 'werewolf') {
                return updateWerewolfBoss(enemy, deltaTime, distance);
            } else if (enemy.special === 'dragon') {
                return updateDragonBoss(enemy, deltaTime, distance);
            } else if (enemy.special === 'demonLord') {
                return updateDemonLordBoss(enemy, deltaTime, distance);
            } else if (enemy.special === 'ancientGod') {
                return updateAncientGodBoss(enemy, deltaTime, distance);
            }

            return false;
        }

        // Set global cooldown after using an ability
        function setBossGlobalCooldown(enemy, duration) {
            enemy.globalCooldown = duration / enemy.phase; // Faster in later phases
        }

        function showBossMessage(text, color) {
            waveAnnouncementEl.textContent = text;
            waveAnnouncementEl.style.color = '#' + color.toString(16).padStart(6, '0');
            waveAnnouncementEl.style.opacity = '1';
            setTimeout(() => { waveAnnouncementEl.style.opacity = '0'; }, 1500);
        }

        // ========== KNIGHT BOSS ABILITIES ==========
        function updateKnightBoss(enemy, deltaTime, distance) {
            const cd = enemy.abilityCooldowns;

            // Shield Bash - Close range stun
            if (cd.shieldBash <= 0 && distance < 5) {
                performShieldBash(enemy);
                cd.shieldBash = 12;
                setBossGlobalCooldown(enemy, 5);
                return true;
            }

            // Sword Spin - AoE attack
            if (cd.swordSpin <= 0 && distance < 6) {
                performSwordSpin(enemy);
                cd.swordSpin = 14;
                setBossGlobalCooldown(enemy, 6);
                return true;
            }

            // Charge - Rush at player (with warning!) - 25% more frequent
            if (cd.charge <= 0 && distance > 8 && distance < 20) {
                performCharge(enemy);
                cd.charge = 12; // Reduced from 16 for more frequent charges
                setBossGlobalCooldown(enemy, 6);
                return true;
            }

            return false;
        }

        function performShieldBash(enemy) {
            enemy.currentAbility = 'shieldBash';
            enemy.abilityTimer = 1.2;
            showBossMessage('SHIELD BASH!', 0xffd700);
            showBossAttackWarning('SHIELD BASH', 2000);

            const startPos = enemy.mesh.position.clone();
            const targetPos = player.position.clone();
            const dir = new THREE.Vector3(
                targetPos.x - startPos.x, 0, targetPos.z - startPos.z
            ).normalize();

            // Charge-up wind back animation
            let windupTime = 0;
            const windupInterval = setInterval(() => {
                windupTime += 0.03;
                // Boss pulls back and glows
                enemy.mesh.position.x = startPos.x - dir.x * Math.sin(windupTime * 10) * 0.5;
                enemy.mesh.position.z = startPos.z - dir.z * Math.sin(windupTime * 10) * 0.5;

                enemy.mesh.children.forEach(child => {
                    if (child.material && child.material.emissive) {
                        child.material.emissive.setHex(0xffd700);
                        child.material.emissiveIntensity = windupTime * 2;
                    }
                });

                if (windupTime >= 0.4) {
                    clearInterval(windupInterval);
                    enemy.mesh.position.copy(startPos);

                    // SLAM forward with motion blur effect
                    let lungeProgress = 0;
                    const lungeInterval = setInterval(() => {
                        lungeProgress += 0.2;
                        enemy.mesh.position.x = startPos.x + dir.x * lungeProgress * 4;
                        enemy.mesh.position.z = startPos.z + dir.z * lungeProgress * 4;

                        // Motion trail
                        const trailGeo = new THREE.BoxGeometry(1.5, 2, 0.3);
                        const trailMat = new THREE.MeshBasicMaterial({ color: 0xffd700, transparent: true, opacity: 0.5 });
                        const trail = new THREE.Mesh(trailGeo, trailMat);
                        trail.position.copy(enemy.mesh.position);
                        trail.position.y = 1;
                        trail.rotation.y = Math.atan2(dir.x, dir.z);
                        scene.add(trail);
                        setTimeout(() => scene.remove(trail), 100);

                        if (lungeProgress >= 1) {
                            clearInterval(lungeInterval);

                            // EPIC shield impact effect
                            const shieldGeo = new THREE.CircleGeometry(2.5, 16);
                            const shieldMat = new THREE.MeshBasicMaterial({ color: 0xffd700, transparent: true, opacity: 1, side: THREE.DoubleSide });
                            const shield = new THREE.Mesh(shieldGeo, shieldMat);
                            shield.position.copy(enemy.mesh.position);
                            shield.position.x += dir.x * 1.5;
                            shield.position.z += dir.z * 1.5;
                            shield.position.y = 1.5;
                            shield.rotation.y = Math.atan2(dir.x, dir.z);
                            scene.add(shield);

                            // Impact effects
                            createSlamEffect(enemy.mesh.position.x + dir.x * 2, enemy.mesh.position.z + dir.z * 2, 3, 0xffd700);
                            screenShake(0.6, 0.3);

                            // Sparks flying
                            for (let i = 0; i < 15; i++) {
                                const sparkGeo = new THREE.SphereGeometry(0.08);
                                const sparkMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                                const spark = new THREE.Mesh(sparkGeo, sparkMat);
                                spark.position.copy(shield.position);
                                const sAngle = Math.random() * Math.PI * 2;
                                const sSpeed = 3 + Math.random() * 5;
                                scene.add(spark);
                                let sLife = 0;
                                const sVel = { x: Math.cos(sAngle) * sSpeed, y: 2 + Math.random() * 3, z: Math.sin(sAngle) * sSpeed };
                                const sparkInt = setInterval(() => {
                                    sLife += 0.03;
                                    sVel.y -= 0.3;
                                    spark.position.x += sVel.x * 0.03;
                                    spark.position.y += sVel.y * 0.03;
                                    spark.position.z += sVel.z * 0.03;
                                    if (sLife > 0.5) { scene.remove(spark); clearInterval(sparkInt); }
                                }, 30);
                            }

                            // Shield fade
                            let shieldScale = 1;
                            const shieldFade = setInterval(() => {
                                shieldScale += 0.15;
                                shield.scale.set(shieldScale, shieldScale, 1);
                                shield.material.opacity -= 0.1;
                                if (shield.material.opacity <= 0) {
                                    scene.remove(shield);
                                    clearInterval(shieldFade);
                                }
                            }, 30);

                            // Damage check
                            const dx = player.position.x - enemy.mesh.position.x;
                            const dz = player.position.z - enemy.mesh.position.z;
                            if (Math.sqrt(dx*dx + dz*dz) < 5) {
                                playerHealth -= 15;
                                timeSinceLastHit = 0;
                                updatePlayerHealth();
                                showAbilityEffect('STUNNED!');
                                const oldSpeed = playerStats.moveSpeed;
                                playerStats.moveSpeed *= 0.3;
                                setTimeout(() => { playerStats.moveSpeed = oldSpeed; }, 1500);
                            }

                            // Reset emissive
                            enemy.mesh.children.forEach(child => {
                                if (child.material && child.material.emissive) {
                                    child.material.emissiveIntensity = 0;
                                }
                            });
                        }
                    }, 30);
                }
            }, 30);
        }

        function performSwordSpin(enemy) {
            enemy.currentAbility = 'swordSpin';
            enemy.abilityTimer = 2.0;
            showBossMessage('WHIRLWIND!', 0xc0c0c0);
            showBossAttackWarning('WHIRLWIND', 2000);

            // Wind up - crouch and glow
            const startY = enemy.mesh.position.y;
            let windupTime = 0;
            const windupInterval = setInterval(() => {
                windupTime += 0.05;
                enemy.mesh.position.y = startY - Math.sin(windupTime * 5) * 0.3;
                enemy.mesh.children.forEach(child => {
                    if (child.material && child.material.emissive) {
                        child.material.emissive.setHex(0xcccccc);
                        child.material.emissiveIntensity = windupTime;
                    }
                });

                if (windupTime >= 0.5) {
                    clearInterval(windupInterval);
                    enemy.mesh.position.y = startY;

                    // EPIC SPIN
                    let spins = 0;
                    let spinSpeed = 0.5;
                    screenShake(0.3, 1.5);

                    const spinInterval = setInterval(() => {
                        spinSpeed = Math.min(spinSpeed + 0.1, 1.5);
                        enemy.mesh.rotation.y += spinSpeed;
                        spins++;

                        // Multiple layered slash arcs
                        for (let layer = 0; layer < 3; layer++) {
                            const slashGeo = new THREE.RingGeometry(2 + layer, 3.5 + layer, 24);
                            const slashMat = new THREE.MeshBasicMaterial({
                                color: layer === 0 ? 0xffffff : (layer === 1 ? 0xaaaaaa : 0x666666),
                                transparent: true, opacity: 0.7 - layer * 0.2, side: THREE.DoubleSide
                            });
                            const slash = new THREE.Mesh(slashGeo, slashMat);
                            slash.position.copy(enemy.mesh.position);
                            slash.position.y = 1.5 + layer * 0.3;
                            slash.rotation.x = Math.PI / 2;
                            slash.rotation.z = enemy.mesh.rotation.y;
                            scene.add(slash);

                            let slashScale = 1;
                            const slashFade = setInterval(() => {
                                slashScale += 0.1;
                                slash.scale.set(slashScale, slashScale, 1);
                                slash.material.opacity -= 0.1;
                                if (slash.material.opacity <= 0) {
                                    scene.remove(slash);
                                    clearInterval(slashFade);
                                }
                            }, 30);
                        }

                        // Sword trail sparks
                        const trailAngle = enemy.mesh.rotation.y + Math.PI / 2;
                        const sparkGeo = new THREE.SphereGeometry(0.1);
                        const sparkMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                        const spark = new THREE.Mesh(sparkGeo, sparkMat);
                        spark.position.set(
                            enemy.mesh.position.x + Math.cos(trailAngle) * 3,
                            1.5,
                            enemy.mesh.position.z + Math.sin(trailAngle) * 3
                        );
                        scene.add(spark);
                        setTimeout(() => scene.remove(spark), 80);

                        // Wind effect - push dust outward
                        if (spins % 2 === 0) {
                            createDustCloud(enemy.mesh.position.x, enemy.mesh.position.z, 5, 5);
                        }

                        // Damage check each spin
                        const dx = player.position.x - enemy.mesh.position.x;
                        const dz = player.position.z - enemy.mesh.position.z;
                        if (Math.sqrt(dx*dx + dz*dz) < 5.5 && !isParrying) {
                            playerHealth -= 10;
                            timeSinceLastHit = 0;
                            updatePlayerHealth();
                        }

                        if (spins >= 12) {
                            clearInterval(spinInterval);
                            // Final shockwave
                            createShockwaveEffect(enemy.mesh.position.x, enemy.mesh.position.z, 0xffffff);
                            enemy.mesh.children.forEach(child => {
                                if (child.material && child.material.emissive) {
                                    child.material.emissiveIntensity = 0;
                                }
                            });
                        }
                    }, 80);
                }
            }, 30);
        }

        function performCharge(enemy) {
            enemy.currentAbility = 'charge';
            enemy.abilityTimer = 2.5; // Longer duration for warning + charge
            showBossMessage('CHARGING...', 0xff4444);
            showBossAttackWarning('CHARGE - DODGE!', 1500);

            const startPos = enemy.mesh.position.clone();

            // LOCK target position at the START - no tracking!
            const lockedTargetPos = player.position.clone();
            const lockedDir = new THREE.Vector3().subVectors(lockedTargetPos, startPos).normalize();

            // === WARNING PHASE (1.5 seconds) ===
            // Show red warning line - FIXED direction, doesn't follow player
            const warningLine = new THREE.Group();
            scene.add(warningLine);

            // Create pulsing warning indicators
            let warningTime = 0;
            const warningInterval = setInterval(() => {
                warningTime += 0.05;

                // Clear old warning visuals
                while (warningLine.children.length > 0) {
                    warningLine.remove(warningLine.children[0]);
                }

                // Draw warning line using LOCKED direction (doesn't track player!)
                // Pulsing red line on ground showing charge path
                for (let i = 0; i < 10; i++) {
                    const segGeo = new THREE.BoxGeometry(0.8, 0.1, 1.5);
                    const pulse = Math.sin(warningTime * 10 + i) * 0.3 + 0.7;
                    const segMat = new THREE.MeshBasicMaterial({
                        color: 0xff0000,
                        transparent: true,
                        opacity: pulse * 0.6
                    });
                    const seg = new THREE.Mesh(segGeo, segMat);
                    seg.position.set(
                        startPos.x + lockedDir.x * (i * 2),
                        0.1,
                        startPos.z + lockedDir.z * (i * 2)
                    );
                    seg.rotation.y = Math.atan2(lockedDir.x, lockedDir.z);
                    warningLine.add(seg);
                }

                // Boss glows and shakes during windup
                enemy.mesh.position.x = startPos.x + (Math.random() - 0.5) * 0.2;
                enemy.mesh.position.z = startPos.z + (Math.random() - 0.5) * 0.2;

                // Flash boss red
                enemy.mesh.children.forEach(child => {
                    if (child.material && child.material.emissive) {
                        child.material.emissive.setHex(Math.sin(warningTime * 15) > 0 ? 0xff0000 : 0x000000);
                    }
                });

                if (warningTime >= 1.5) {
                    clearInterval(warningInterval);
                    scene.remove(warningLine);

                    // Reset emissive
                    enemy.mesh.children.forEach(child => {
                        if (child.material && child.material.emissive) {
                            child.material.emissive.setHex(0x000000);
                        }
                    });

                    // === ACTUAL CHARGE === (uses the same locked direction)
                    showBossMessage('CHARGE!!!', 0xff0000);
                    enemy.mesh.position.copy(startPos);
                    const chargeDir = lockedDir; // Use the same locked direction

                    let chargeProgress = 0;
                    const chargeInterval = setInterval(() => {
                        chargeProgress += 0.15; // Fast charge
                        enemy.mesh.position.x = startPos.x + chargeDir.x * chargeProgress * 25;
                        enemy.mesh.position.z = startPos.z + chargeDir.z * chargeProgress * 25;

                        // Trail effect
                        const trailGeo = new THREE.BoxGeometry(0.5, 2, 0.5);
                        const trailMat = new THREE.MeshBasicMaterial({ color: 0xffd700, transparent: true, opacity: 0.5 });
                        const trail = new THREE.Mesh(trailGeo, trailMat);
                        trail.position.copy(enemy.mesh.position);
                        trail.position.y = 1;
                        scene.add(trail);
                        setTimeout(() => { scene.remove(trail); }, 200);

                        // Damage check
                        const dx = player.position.x - enemy.mesh.position.x;
                        const dz = player.position.z - enemy.mesh.position.z;
                        if (Math.sqrt(dx*dx + dz*dz) < 3) {
                            playerHealth -= 35; // 40% more ram damage
                            timeSinceLastHit = 0;
                            updatePlayerHealth();
                            clearInterval(chargeInterval);
                            createShockwaveEffect(enemy.mesh.position.x, enemy.mesh.position.z, 0xffd700);
                        }

                        if (chargeProgress >= 1) {
                            clearInterval(chargeInterval);
                            createShockwaveEffect(enemy.mesh.position.x, enemy.mesh.position.z, 0x888888);
                        }
                    }, 40);
                }
            }, 50);
        }

        function performRally(enemy) {
            enemy.currentAbility = 'rally';
            enemy.abilityTimer = 2.5;
            showBossMessage('RALLY!', 0x00ff00);
            showBossAttackWarning('RALLY - INTERRUPT!', 2500);

            // Knight raises sword and glows with healing energy
            const startY = enemy.mesh.position.y;

            // Healing aura
            const auraGeo = new THREE.SphereGeometry(3);
            const auraMat = new THREE.MeshBasicMaterial({
                color: 0x00ff00, transparent: true, opacity: 0.3, side: THREE.BackSide
            });
            const aura = new THREE.Mesh(auraGeo, auraMat);
            enemy.mesh.add(aura);

            // Holy symbols appearing
            for (let s = 0; s < 4; s++) {
                const angle = (s / 4) * Math.PI * 2;
                const symbolGeo = new THREE.RingGeometry(0.3, 0.5, 6);
                const symbolMat = new THREE.MeshBasicMaterial({
                    color: 0x44ff44, transparent: true, opacity: 0.8, side: THREE.DoubleSide
                });
                const symbol = new THREE.Mesh(symbolGeo, symbolMat);
                symbol.position.set(
                    enemy.mesh.position.x + Math.cos(angle) * 2,
                    2,
                    enemy.mesh.position.z + Math.sin(angle) * 2
                );
                symbol.rotation.y = angle;
                scene.add(symbol);

                let sTime = 0;
                const sMove = setInterval(() => {
                    sTime += 0.03;
                    symbol.rotation.z += 0.1;
                    symbol.position.y += 0.05;
                    symbol.material.opacity -= 0.02;
                    if (symbol.material.opacity <= 0) {
                        scene.remove(symbol);
                        clearInterval(sMove);
                    }
                }, 30);
            }

            // Heal over time with epic visuals
            let heals = 0;
            const healInterval = setInterval(() => {
                enemy.health = Math.min(enemy.maxHealth, enemy.health + 6); // 60% less healing
                heals++;

                // Pulse aura
                aura.scale.set(1 + Math.sin(heals) * 0.3, 1 + Math.sin(heals) * 0.3, 1 + Math.sin(heals) * 0.3);

                // Rising healing particles in spiral
                for (let i = 0; i < 8; i++) {
                    const pAngle = (i / 8) * Math.PI * 2 + heals * 0.5;
                    const particleGeo = new THREE.SphereGeometry(0.12);
                    const particleMat = new THREE.MeshBasicMaterial({
                        color: Math.random() > 0.5 ? 0x00ff00 : 0x88ff88
                    });
                    const particle = new THREE.Mesh(particleGeo, particleMat);
                    const startDist = 2;
                    particle.position.set(
                        enemy.mesh.position.x + Math.cos(pAngle) * startDist,
                        0,
                        enemy.mesh.position.z + Math.sin(pAngle) * startDist
                    );
                    scene.add(particle);

                    let pTime = 0;
                    const riseInterval = setInterval(() => {
                        pTime += 0.04;
                        particle.position.y += 0.15;
                        // Spiral inward as rising
                        const dist = startDist * (1 - pTime * 0.5);
                        particle.position.x = enemy.mesh.position.x + Math.cos(pAngle + pTime * 3) * dist;
                        particle.position.z = enemy.mesh.position.z + Math.sin(pAngle + pTime * 3) * dist;
                        particle.scale.multiplyScalar(0.98);

                        if (pTime > 1) {
                            scene.remove(particle);
                            clearInterval(riseInterval);
                        }
                    }, 30);
                }

                // Healing number popup
                const healNum = document.createElement('div');
                healNum.textContent = '+15';
                healNum.style.cssText = 'position:fixed;color:#00ff00;font-size:20px;font-weight:bold;pointer-events:none;text-shadow:0 0 5px #00ff00;';
                document.body.appendChild(healNum);

                // Position above boss (simplified)
                healNum.style.left = '50%';
                healNum.style.top = '40%';
                healNum.style.transform = 'translateX(-50%)';

                setTimeout(() => document.body.removeChild(healNum), 500);

                if (heals >= 6) {
                    clearInterval(healInterval);
                    enemy.mesh.remove(aura);

                    // Final heal burst
                    createShockwaveEffect(enemy.mesh.position.x, enemy.mesh.position.z, 0x00ff00);
                }
            }, 300);
        }

        // ========== WEREWOLF BOSS ABILITIES ==========
        function updateWerewolfBoss(enemy, deltaTime, distance) {
            const cd = enemy.abilityCooldowns;

            // Frenzy - Speed boost when enraged
            if (enemy.enraged && !enemy.frenzyActive) {
                performFrenzy(enemy);
                enemy.frenzyActive = true;
            }

            // Leap - Jump to player (locks position at start)
            if (cd.leap <= 0 && distance > 6 && distance < 18) {
                performLeap(enemy);
                cd.leap = 10;
                setBossGlobalCooldown(enemy, 5);
                return true;
            }

            // Howl - Intimidation
            if (cd.howl <= 0 && distance < 15) {
                performHowl(enemy);
                cd.howl = 18;
                setBossGlobalCooldown(enemy, 6);
                return true;
            }

            // Claw Combo - Rapid attacks
            if (cd.clawCombo <= 0 && distance < 4) {
                performClawCombo(enemy);
                cd.clawCombo = 12;
                setBossGlobalCooldown(enemy, 5);
                return true;
            }

            return false;
        }

        function performLeap(enemy) {
            enemy.currentAbility = 'leap';
            enemy.abilityTimer = 1.5;
            showBossMessage('POUNCE!', 0xff8800);
            showBossAttackWarning('POUNCE - DODGE!', 1500);

            const startPos = enemy.mesh.position.clone();
            const targetPos = player.position.clone();

            // Pre-leap crouch and growl
            let crouchTime = 0;
            const crouchInterval = setInterval(() => {
                crouchTime += 0.05;
                enemy.mesh.scale.y = 1 - crouchTime * 0.3;
                enemy.mesh.scale.x = 1 + crouchTime * 0.1;
                enemy.mesh.scale.z = 1 + crouchTime * 0.1;

                // Eyes glow
                enemy.mesh.children.forEach(child => {
                    if (child.material && child.material.emissive) {
                        child.material.emissive.setHex(0xff4400);
                        child.material.emissiveIntensity = crouchTime * 2;
                    }
                });

                if (crouchTime >= 0.4) {
                    clearInterval(crouchInterval);

                    // LAUNCH with roar effect
                    createBossRoarEffect(enemy, 0xff8800);
                    createDustCloud(startPos.x, startPos.z, 2, 10);

                    // Epic arc jump
                    let jumpProgress = 0;
                    const jumpInterval = setInterval(() => {
                        jumpProgress += 0.08;
                        const t = jumpProgress;

                        // Higher, more dramatic arc
                        enemy.mesh.position.x = startPos.x + (targetPos.x - startPos.x) * t;
                        enemy.mesh.position.z = startPos.z + (targetPos.z - startPos.z) * t;
                        enemy.mesh.position.y = Math.sin(t * Math.PI) * 8;

                        // Dramatic rotation - full flip
                        enemy.mesh.rotation.x = t * Math.PI * 0.8;
                        enemy.mesh.scale.y = 1;
                        enemy.mesh.scale.x = 1 + Math.sin(t * Math.PI) * 0.2;

                        // Shadow/target indicator on ground
                        if (t < 0.8) {
                            const shadowGeo = new THREE.CircleGeometry(1.5 + t * 2, 16);
                            const shadowMat = new THREE.MeshBasicMaterial({
                                color: 0xff0000, transparent: true, opacity: 0.3 + t * 0.3, side: THREE.DoubleSide
                            });
                            const shadow = new THREE.Mesh(shadowGeo, shadowMat);
                            shadow.position.set(targetPos.x, 0.05, targetPos.z);
                            shadow.rotation.x = -Math.PI / 2;
                            scene.add(shadow);
                            setTimeout(() => scene.remove(shadow), 60);
                        }

                        // Claw trail during jump
                        if (t > 0.3) {
                            const clawGeo = new THREE.ConeGeometry(0.2, 0.8, 4);
                            const clawMat = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.6 });
                            const claw = new THREE.Mesh(clawGeo, clawMat);
                            claw.position.copy(enemy.mesh.position);
                            claw.position.y -= 1;
                            scene.add(claw);
                            setTimeout(() => scene.remove(claw), 100);
                        }

                        if (jumpProgress >= 1) {
                            clearInterval(jumpInterval);
                            enemy.mesh.position.y = 0;
                            enemy.mesh.rotation.x = 0;
                            enemy.mesh.scale.set(1, 1, 1);

                            // EPIC LANDING IMPACT
                            createSlamEffect(enemy.mesh.position.x, enemy.mesh.position.z, 5, 0xff6600);
                            createEpicExplosion(enemy.mesh.position.x, 0.5, enemy.mesh.position.z, 0x8b4513, 2, 20);
                            screenShake(0.8, 0.4);

                            // Claw marks on ground
                            for (let i = 0; i < 4; i++) {
                                const angle = (i / 4) * Math.PI * 2 + Math.random() * 0.3;
                                const markGeo = new THREE.BoxGeometry(0.1, 0.02, 1.5);
                                const markMat = new THREE.MeshBasicMaterial({ color: 0x333333 });
                                const mark = new THREE.Mesh(markGeo, markMat);
                                mark.position.set(
                                    enemy.mesh.position.x + Math.cos(angle) * 1,
                                    0.02,
                                    enemy.mesh.position.z + Math.sin(angle) * 1
                                );
                                mark.rotation.y = angle;
                                scene.add(mark);
                                setTimeout(() => scene.remove(mark), 3000);
                            }

                            // Reset emissive
                            enemy.mesh.children.forEach(child => {
                                if (child.material && child.material.emissive) {
                                    child.material.emissiveIntensity = enemy.frenzyActive ? 0.5 : 0;
                                }
                            });

                            // Damage on landing
                            const dx = player.position.x - enemy.mesh.position.x;
                            const dz = player.position.z - enemy.mesh.position.z;
                            if (Math.sqrt(dx*dx + dz*dz) < 5) {
                                playerHealth -= 25;
                                timeSinceLastHit = 0;
                                updatePlayerHealth();
                            }
                        }
                    }, 40);
                }
            }, 30);
        }

        function performHowl(enemy) {
            enemy.currentAbility = 'howl';
            enemy.abilityTimer = 2.5;
            showBossMessage('AWOOOOO!', 0x8844ff);
            showBossAttackWarning('HOWL - FEAR!', 2000);

            // Werewolf rears back dramatically
            const startRotX = enemy.mesh.rotation.x;
            let howlTime = 0;

            const howlInterval = setInterval(() => {
                howlTime += 0.03;

                // Rear up animation
                if (howlTime < 0.3) {
                    enemy.mesh.rotation.x = startRotX - howlTime * 1.5;
                } else if (howlTime > 0.5 && howlTime < 0.8) {
                    enemy.mesh.rotation.x = startRotX - 0.45 + (howlTime - 0.5) * 1.5;
                } else if (howlTime >= 0.8) {
                    enemy.mesh.rotation.x = startRotX;
                }

                // Glow during howl
                enemy.mesh.children.forEach(child => {
                    if (child.material && child.material.emissive) {
                        child.material.emissive.setHex(0x8844ff);
                        child.material.emissiveIntensity = Math.sin(howlTime * 20) * 0.5 + 0.5;
                    }
                });

                if (howlTime >= 1.0) {
                    clearInterval(howlInterval);
                    enemy.mesh.rotation.x = startRotX;

                    if (!enemy.frenzyActive) {
                        enemy.mesh.children.forEach(child => {
                            if (child.material && child.material.emissive) {
                                child.material.emissiveIntensity = 0;
                            }
                        });
                    }
                }
            }, 30);

            // EPIC howl visual - multiple expanding sonic rings
            screenShake(0.4, 1.5);
            createBossRoarEffect(enemy, 0x8844ff);

            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    // Sonic ring
                    const ringGeo = new THREE.TorusGeometry(1, 0.3, 8, 32);
                    const ringMat = new THREE.MeshBasicMaterial({
                        color: i % 2 === 0 ? 0x8844ff : 0xaa66ff,
                        transparent: true, opacity: 0.8
                    });
                    const ring = new THREE.Mesh(ringGeo, ringMat);
                    ring.position.copy(enemy.mesh.position);
                    ring.position.y = 2.5;
                    ring.rotation.x = Math.PI / 2;
                    scene.add(ring);

                    // Distortion particles
                    for (let p = 0; p < 8; p++) {
                        const pAngle = (p / 8) * Math.PI * 2;
                        const pGeo = new THREE.SphereGeometry(0.15);
                        const pMat = new THREE.MeshBasicMaterial({ color: 0xaa88ff });
                        const particle = new THREE.Mesh(pGeo, pMat);
                        particle.position.copy(ring.position);
                        scene.add(particle);

                        let pLife = 0;
                        const pExpand = setInterval(() => {
                            pLife += 0.05;
                            const radius = pLife * 15;
                            particle.position.x = enemy.mesh.position.x + Math.cos(pAngle) * radius;
                            particle.position.z = enemy.mesh.position.z + Math.sin(pAngle) * radius;
                            particle.material.opacity = 1 - pLife;
                            particle.material.transparent = true;
                            if (pLife > 1) { scene.remove(particle); clearInterval(pExpand); }
                        }, 30);
                    }

                    let scale = 1;
                    const expandInterval = setInterval(() => {
                        scale += 0.8;
                        ring.scale.set(scale, scale, 1);
                        ring.material.opacity -= 0.05;
                        if (ring.material.opacity <= 0) {
                            scene.remove(ring);
                            clearInterval(expandInterval);
                        }
                    }, 30);
                }, i * 150);
            }

            // Fear effect with visual distortion
            const oldSpeed = playerStats.moveSpeed;
            const oldDamage = playerStats.damage;
            playerStats.moveSpeed *= 0.6;
            playerStats.damage *= 0.7;
            showAbilityEffect('FEARED!');

            // Purple tint during fear
            const oldFog = scene.fog;
            scene.fog = new THREE.Fog(0x220033, 10, 50);

            setTimeout(() => {
                playerStats.moveSpeed = oldSpeed;
                playerStats.damage = oldDamage;
                scene.fog = oldFog;
            }, 2500);
        }

        function performClawCombo(enemy) {
            enemy.currentAbility = 'clawCombo';
            enemy.abilityTimer = 1.5; // Extended for warning
            showBossMessage('CLAW FURY!', 0xff4400);
            showBossAttackWarning('CLAW FURY', 2000);

            // Rapid claw swipes
            let swipes = 0;
            const swipeInterval = setInterval(() => {
                swipes++;

                // Alternate left/right swipe visual
                const side = swipes % 2 === 0 ? 1 : -1;
                const slashGeo = new THREE.PlaneGeometry(3, 0.3);
                const slashMat = new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.8, side: THREE.DoubleSide });
                const slash = new THREE.Mesh(slashGeo, slashMat);
                slash.position.copy(enemy.mesh.position);
                slash.position.y = 1.5;
                slash.position.x += side * 1.5;
                slash.rotation.z = side * 0.5;
                slash.rotation.y = enemy.mesh.rotation.y;
                scene.add(slash);
                setTimeout(() => { scene.remove(slash); }, 100);

                // Damage check
                const dx = player.position.x - enemy.mesh.position.x;
                const dz = player.position.z - enemy.mesh.position.z;
                if (Math.sqrt(dx*dx + dz*dz) < 4 && !isParrying) {
                    playerHealth -= 8;
                    timeSinceLastHit = 0;
                    updatePlayerHealth();
                }

                if (swipes >= 6) clearInterval(swipeInterval);
            }, 120);
        }

        function performFrenzy(enemy) {
            showBossMessage('FRENZY!!!', 0xff0000);
            showBossAttackWarning('FRENZY - ENRAGED!', 3000);

            // DRAMATIC transformation sequence
            screenShake(0.8, 1.5);
            createBossRoarEffect(enemy, 0xff0000);

            // Explosion of rage particles
            createEpicExplosion(enemy.mesh.position.x, 1.5, enemy.mesh.position.z, 0xff0000, 3, 30);

            // Ground cracks from raw power
            createGroundCrack(enemy.mesh.position.x, enemy.mesh.position.z, 6, 0x440000);

            // Speed boost
            enemy.moveSpeed *= 1.5;
            enemy.attackSpeed *= 1.5;

            // Intense red glow and scale up slightly
            enemy.mesh.scale.set(1.15, 1.15, 1.15);

            enemy.mesh.children.forEach(child => {
                if (child.material) {
                    if (!child.material.emissive) {
                        child.material.emissive = new THREE.Color(0xff0000);
                    } else {
                        child.material.emissive.setHex(0xff0000);
                    }
                    child.material.emissiveIntensity = 0.8;
                }
            });

            // Persistent rage aura
            const auraGeo = new THREE.SphereGeometry(2.5);
            const auraMat = new THREE.MeshBasicMaterial({
                color: 0xff0000, transparent: true, opacity: 0.2, side: THREE.BackSide
            });
            const aura = new THREE.Mesh(auraGeo, auraMat);
            aura.name = 'frenzyAura';
            enemy.mesh.add(aura);

            // Pulsing aura effect
            let pulseTime = 0;
            const pulseInterval = setInterval(() => {
                pulseTime += 0.05;
                const pulse = 1 + Math.sin(pulseTime * 10) * 0.2;
                aura.scale.set(pulse, pulse, pulse);
                auraMat.opacity = 0.15 + Math.sin(pulseTime * 10) * 0.1;

                // Occasional rage sparks
                if (Math.random() > 0.8) {
                    const sparkGeo = new THREE.SphereGeometry(0.1);
                    const sparkMat = new THREE.MeshBasicMaterial({ color: 0xff4400 });
                    const spark = new THREE.Mesh(sparkGeo, sparkMat);
                    spark.position.copy(enemy.mesh.position);
                    spark.position.x += (Math.random() - 0.5) * 2;
                    spark.position.y += Math.random() * 2;
                    spark.position.z += (Math.random() - 0.5) * 2;
                    scene.add(spark);
                    setTimeout(() => scene.remove(spark), 150);
                }

                // Check if enemy still exists
                if (!enemy.mesh.parent) {
                    clearInterval(pulseInterval);
                }
            }, 30);
        }

        // ========== DRAGON BOSS ABILITIES ==========
        function updateDragonBoss(enemy, deltaTime, distance) {
            const cd = enemy.abilityCooldowns;

            // Fire Breath - Cone attack (locks direction at start)
            if (cd.fireBreath <= 0 && distance < 15) {
                performFireBreath(enemy);
                cd.fireBreath = 14;
                setBossGlobalCooldown(enemy, 6);
                return true;
            }

            // Tail Swipe - Close range AoE
            if (cd.tailSwipe <= 0 && distance < 8) {
                performTailSwipe(enemy);
                cd.tailSwipe = 10;
                setBossGlobalCooldown(enemy, 5);
                return true;
            }

            // Wing Gust - Knockback
            if (cd.wingGust <= 0 && distance < 12) {
                performWingGust(enemy);
                cd.wingGust = 16;
                setBossGlobalCooldown(enemy, 6);
                return true;
            }

            // THEMED SPECIAL ABILITY - Phase 2+ (unique to each map's dragon)
            if (cd.themedAbility <= 0 && enemy.phase >= 2) {
                if (currentMapId === 'forest') {
                    performNaturesWrath(enemy);
                } else if (currentMapId === 'desert') {
                    performSandstorm(enemy);
                } else if (currentMapId === 'volcano') {
                    performVolcanicEruption(enemy);
                } else if (currentMapId === 'frost') {
                    performFrozenPrison(enemy);
                } else if (currentMapId === 'swamp') {
                    performToxicMiasma(enemy);
                } else if (currentMapId === 'shadow') {
                    performShadowRift(enemy);
                } else if (currentMapId === 'crystal') {
                    performCrystalShatter(enemy);
                } else if (currentMapId === 'graveyard') {
                    performGraveRise(enemy);
                } else if (currentMapId === 'sky') {
                    performThunderStorm(enemy);
                } else if (currentMapId === 'abyss') {
                    performHellfireRain(enemy);
                }
                cd.themedAbility = 25; // 25 second cooldown
                setBossGlobalCooldown(enemy, 8);
                return true;
            }

            // Meteor Shower - Phase 2+ (targets locked positions)
            if (cd.meteorShower <= 0 && enemy.phase >= 2) {
                performMeteorShower(enemy);
                cd.meteorShower = 22;
                setBossGlobalCooldown(enemy, 7);
                return true;
            }

            // Dive Bomb - Phase 3 (locks target at start)
            if (cd.diveBomb <= 0 && enemy.phase >= 3 && distance > 10) {
                performDiveBomb(enemy);
                cd.diveBomb = 20;
                setBossGlobalCooldown(enemy, 6);
                return true;
            }

            return false;
        }

        function performFireBreath(enemy) {
            enemy.currentAbility = 'fireBreath';
            enemy.abilityTimer = 3.0;
            showBossMessage('FIRE BREATH!', 0xff4400);
            showBossAttackWarning('FIRE BREATH - RUN!', 2500);

            const lockedDir = new THREE.Vector3(
                player.position.x - enemy.mesh.position.x,
                0,
                player.position.z - enemy.mesh.position.z
            ).normalize();

            // Inhale animation - dragon pulls back and glows
            let inhaleTime = 0;
            const inhaleInterval = setInterval(() => {
                inhaleTime += 0.04;

                // Glow intensifies
                enemy.mesh.children.forEach(child => {
                    if (child.material && child.material.emissive) {
                        child.material.emissive.setHex(0xff4400);
                        child.material.emissiveIntensity = inhaleTime * 1.5;
                    }
                });

                // Particles being sucked in
                if (inhaleTime < 0.6) {
                    for (let i = 0; i < 3; i++) {
                        const pGeo = new THREE.SphereGeometry(0.15);
                        const pMat = new THREE.MeshBasicMaterial({ color: 0xff6600 });
                        const p = new THREE.Mesh(pGeo, pMat);
                        const angle = Math.random() * Math.PI * 2;
                        const dist = 5 + Math.random() * 3;
                        p.position.set(
                            enemy.mesh.position.x + Math.cos(angle) * dist,
                            2 + Math.random() * 2,
                            enemy.mesh.position.z + Math.sin(angle) * dist
                        );
                        scene.add(p);

                        const suckInterval = setInterval(() => {
                            const dx = enemy.mesh.position.x - p.position.x;
                            const dy = 2.5 - p.position.y;
                            const dz = enemy.mesh.position.z - p.position.z;
                            p.position.x += dx * 0.15;
                            p.position.y += dy * 0.15;
                            p.position.z += dz * 0.15;
                            p.scale.multiplyScalar(0.95);
                            if (p.scale.x < 0.1) {
                                scene.remove(p);
                                clearInterval(suckInterval);
                            }
                        }, 30);
                    }
                }

                if (inhaleTime >= 0.8) {
                    clearInterval(inhaleInterval);

                    // UNLEASH THE FIRE
                    screenShake(0.4, 2.0);
                    createBossRoarEffect(enemy, 0xff4400);

                    let breathTime = 0;
                    const breathInterval = setInterval(() => {
                        breathTime += 0.04;

                        // Main fire stream - thick beam
                        const beamLength = 15;
                        for (let i = 0; i < 8; i++) {
                            const spread = (Math.random() - 0.5) * 0.6;
                            const vertSpread = (Math.random() - 0.5) * 0.3;
                            const size = 0.3 + Math.random() * 0.5;
                            const fireGeo = new THREE.SphereGeometry(size);
                            const colors = [0xff0000, 0xff4400, 0xff8800, 0xffaa00, 0xffff00];
                            const fireMat = new THREE.MeshBasicMaterial({
                                color: colors[Math.floor(Math.random() * colors.length)]
                            });
                            const fire = new THREE.Mesh(fireGeo, fireMat);

                            fire.position.copy(enemy.mesh.position);
                            fire.position.y = 2.5;
                            fire.position.x += lockedDir.x * 2;
                            fire.position.z += lockedDir.z * 2;

                            const speed = 20 + Math.random() * 8;
                            const fireVel = {
                                x: (lockedDir.x + spread) * speed,
                                y: vertSpread * 3,
                                z: (lockedDir.z + spread) * speed
                            };

                            scene.add(fire);

                            let fireLife = 0;
                            const fireInterval = setInterval(() => {
                                fireLife += 0.025;
                                fire.position.x += fireVel.x * 0.025;
                                fire.position.y += fireVel.y * 0.025;
                                fire.position.z += fireVel.z * 0.025;

                                // Fire expands then shrinks
                                if (fireLife < 0.3) {
                                    fire.scale.multiplyScalar(1.05);
                                } else {
                                    fire.scale.multiplyScalar(0.95);
                                }

                                // Smoke trail
                                if (Math.random() > 0.7) {
                                    const smokeGeo = new THREE.SphereGeometry(size * 0.5);
                                    const smokeMat = new THREE.MeshBasicMaterial({
                                        color: 0x333333, transparent: true, opacity: 0.4
                                    });
                                    const smoke = new THREE.Mesh(smokeGeo, smokeMat);
                                    smoke.position.copy(fire.position);
                                    scene.add(smoke);
                                    setTimeout(() => scene.remove(smoke), 200);
                                }

                                // Damage check
                                const dx = player.position.x - fire.position.x;
                                const dz = player.position.z - fire.position.z;
                                if (Math.sqrt(dx*dx + dz*dz) < 2) {
                                    playerHealth -= 5;
                                    timeSinceLastHit = 0;
                                    updatePlayerHealth();
                                }

                                if (fireLife > 1.0) {
                                    scene.remove(fire);
                                    clearInterval(fireInterval);
                                }
                            }, 25);
                        }

                        // Ground scorching effect
                        const scorchDist = breathTime * 15;
                        const scorchX = enemy.mesh.position.x + lockedDir.x * scorchDist;
                        const scorchZ = enemy.mesh.position.z + lockedDir.z * scorchDist;
                        const scorchGeo = new THREE.CircleGeometry(1 + Math.random(), 8);
                        const scorchMat = new THREE.MeshBasicMaterial({
                            color: 0x220000, transparent: true, opacity: 0.6, side: THREE.DoubleSide
                        });
                        const scorch = new THREE.Mesh(scorchGeo, scorchMat);
                        scorch.position.set(scorchX, 0.02, scorchZ);
                        scorch.rotation.x = -Math.PI / 2;
                        scene.add(scorch);
                        setTimeout(() => scene.remove(scorch), 4000);

                        if (breathTime >= 2.0) {
                            clearInterval(breathInterval);
                            enemy.mesh.children.forEach(child => {
                                if (child.material && child.material.emissive) {
                                    child.material.emissiveIntensity = 0;
                                }
                            });
                        }
                    }, 40);
                }
            }, 30);
        }

        function performTailSwipe(enemy) {
            enemy.currentAbility = 'tailSwipe';
            enemy.abilityTimer = 1.3; // Extended for warning
            showBossMessage('TAIL SWIPE!', 0x8b0000);
            showBossAttackWarning('TAIL SWIPE', 2000);

            // Spin animation
            let rotation = 0;
            const spinInterval = setInterval(() => {
                rotation += 0.3;
                enemy.mesh.rotation.y += 0.3;

                // Tail trail effect
                const trailGeo = new THREE.BoxGeometry(4, 0.5, 0.5);
                const trailMat = new THREE.MeshBasicMaterial({ color: 0x8b0000, transparent: true, opacity: 0.6 });
                const trail = new THREE.Mesh(trailGeo, trailMat);
                trail.position.copy(enemy.mesh.position);
                trail.position.y = 1;
                trail.rotation.y = enemy.mesh.rotation.y;
                scene.add(trail);
                setTimeout(() => { scene.remove(trail); }, 150);

                // Damage check
                const dx = player.position.x - enemy.mesh.position.x;
                const dz = player.position.z - enemy.mesh.position.z;
                if (Math.sqrt(dx*dx + dz*dz) < 6) {
                    playerHealth -= 20;
                    timeSinceLastHit = 0;
                    updatePlayerHealth();
                    // Knockback
                    const knockDir = new THREE.Vector3(dx, 0, dz).normalize();
                    player.position.x += knockDir.x * 5;
                    player.position.z += knockDir.z * 5;
                }

                if (rotation >= Math.PI * 2) clearInterval(spinInterval);
            }, 50);
        }

        function performWingGust(enemy) {
            enemy.currentAbility = 'wingGust';
            enemy.abilityTimer = 1.5; // Extended for warning
            showBossMessage('WING GUST!', 0x88ccff);
            showBossAttackWarning('WING GUST - KNOCKBACK', 2000);

            // Wind effect - lines pushing outward
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    const angle = (i / 20) * Math.PI * 2;
                    const windGeo = new THREE.BoxGeometry(0.2, 0.2, 3);
                    const windMat = new THREE.MeshBasicMaterial({ color: 0x88ccff, transparent: true, opacity: 0.6 });
                    const wind = new THREE.Mesh(windGeo, windMat);
                    wind.position.copy(enemy.mesh.position);
                    wind.position.y = 1.5;
                    wind.rotation.y = angle;
                    scene.add(wind);

                    let dist = 0;
                    const pushInterval = setInterval(() => {
                        dist += 0.8;
                        wind.position.x = enemy.mesh.position.x + Math.sin(angle) * dist;
                        wind.position.z = enemy.mesh.position.z + Math.cos(angle) * dist;
                        wind.material.opacity -= 0.03;

                        if (dist > 15) {
                            scene.remove(wind);
                            clearInterval(pushInterval);
                        }
                    }, 30);
                }, i * 30);
            }

            // Knockback player
            const dx = player.position.x - enemy.mesh.position.x;
            const dz = player.position.z - enemy.mesh.position.z;
            const dist = Math.sqrt(dx*dx + dz*dz);
            if (dist < 12) {
                const knockDir = new THREE.Vector3(dx, 0, dz).normalize();
                player.position.x += knockDir.x * (15 - dist);
                player.position.z += knockDir.z * (15 - dist);
                playerHealth -= 10;
                timeSinceLastHit = 0;
                updatePlayerHealth();
            }
        }

        function performMeteorShower(enemy) {
            enemy.currentAbility = 'meteorShower';
            enemy.abilityTimer = 5.0;
            showBossMessage('METEOR SHOWER!', 0xff8800);
            showBossAttackWarning('METEOR SHOWER - KEEP MOVING!', 3750);

            // Dragon roars and the sky darkens
            createBossRoarEffect(enemy, 0xff4400);
            screenShake(0.3, 4.0);

            // Temporary red fog effect
            const oldFog = scene.fog;
            scene.fog = new THREE.Fog(0x330000, 20, 80);

            // Rain down EPIC meteors
            for (let i = 0; i < 12; i++) {
                setTimeout(() => {
                    const targetX = player.position.x + (Math.random() - 0.5) * 20;
                    const targetZ = player.position.z + (Math.random() - 0.5) * 20;
                    const meteorSize = 0.8 + Math.random() * 0.8;

                    // Pulsing warning indicator
                    const warningGroup = new THREE.Group();
                    const warningGeo = new THREE.RingGeometry(1.5, 2.5, 24);
                    const warningMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
                    const warning = new THREE.Mesh(warningGeo, warningMat);
                    warning.rotation.x = -Math.PI / 2;
                    warningGroup.add(warning);

                    // Inner target
                    const innerGeo = new THREE.CircleGeometry(1.2, 16);
                    const innerMat = new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
                    const inner = new THREE.Mesh(innerGeo, innerMat);
                    inner.rotation.x = -Math.PI / 2;
                    inner.position.y = 0.01;
                    warningGroup.add(inner);

                    warningGroup.position.set(targetX, 0.1, targetZ);
                    scene.add(warningGroup);

                    let warningPulse = 0;
                    const pulseInterval = setInterval(() => {
                        warningPulse += 0.1;
                        const scale = 1 + Math.sin(warningPulse * 8) * 0.2;
                        warningGroup.scale.set(scale, 1, scale);
                        warningMat.opacity = 0.3 + Math.sin(warningPulse * 8) * 0.3;
                    }, 30);

                    // Meteor falls after warning
                    setTimeout(() => {
                        clearInterval(pulseInterval);
                        scene.remove(warningGroup);

                        // Create epic meteor with fire trail
                        const meteorGroup = new THREE.Group();
                        const meteorGeo = new THREE.SphereGeometry(meteorSize);
                        const meteorMat = new THREE.MeshBasicMaterial({ color: 0xff2200 });
                        const meteor = new THREE.Mesh(meteorGeo, meteorMat);
                        meteorGroup.add(meteor);

                        // Glowing core
                        const coreGeo = new THREE.SphereGeometry(meteorSize * 0.6);
                        const coreMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                        const core = new THREE.Mesh(coreGeo, coreMat);
                        meteorGroup.add(core);

                        meteorGroup.position.set(targetX, 35, targetZ);
                        scene.add(meteorGroup);

                        let fallSpeed = 1;
                        const fallInterval = setInterval(() => {
                            fallSpeed += 0.3; // Accelerate
                            meteorGroup.position.y -= fallSpeed;
                            meteorGroup.rotation.x += 0.2;
                            meteorGroup.rotation.z += 0.15;

                            // Fire trail
                            for (let t = 0; t < 3; t++) {
                                const trailGeo = new THREE.SphereGeometry(meteorSize * (0.3 + Math.random() * 0.3));
                                const trailMat = new THREE.MeshBasicMaterial({
                                    color: Math.random() > 0.5 ? 0xff4400 : 0xffaa00,
                                    transparent: true, opacity: 0.8
                                });
                                const trail = new THREE.Mesh(trailGeo, trailMat);
                                trail.position.copy(meteorGroup.position);
                                trail.position.y += Math.random() * 2;
                                trail.position.x += (Math.random() - 0.5);
                                trail.position.z += (Math.random() - 0.5);
                                scene.add(trail);

                                let tLife = 0;
                                const trailFade = setInterval(() => {
                                    tLife += 0.05;
                                    trail.material.opacity -= 0.08;
                                    trail.scale.multiplyScalar(0.92);
                                    if (trail.material.opacity <= 0) {
                                        scene.remove(trail);
                                        clearInterval(trailFade);
                                    }
                                }, 30);
                            }

                            if (meteorGroup.position.y <= 0) {
                                clearInterval(fallInterval);
                                scene.remove(meteorGroup);

                                // MASSIVE EXPLOSION
                                createEpicExplosion(targetX, 0.5, targetZ, 0xff4400, meteorSize * 3, 40);
                                createSlamEffect(targetX, targetZ, 4, 0xff2200);
                                screenShake(0.7, 0.3);

                                // Lingering fire
                                for (let f = 0; f < 5; f++) {
                                    const fireGeo = new THREE.SphereGeometry(0.3 + Math.random() * 0.3);
                                    const fireMat = new THREE.MeshBasicMaterial({ color: 0xff4400 });
                                    const fire = new THREE.Mesh(fireGeo, fireMat);
                                    fire.position.set(
                                        targetX + (Math.random() - 0.5) * 3,
                                        0.3,
                                        targetZ + (Math.random() - 0.5) * 3
                                    );
                                    scene.add(fire);
                                    setTimeout(() => scene.remove(fire), 1500 + Math.random() * 1000);
                                }

                                // Damage check - larger radius
                                const dx = player.position.x - targetX;
                                const dz = player.position.z - targetZ;
                                if (Math.sqrt(dx*dx + dz*dz) < 4) {
                                    playerHealth -= 30;
                                    timeSinceLastHit = 0;
                                    updatePlayerHealth();
                                }
                            }
                        }, 25);
                    }, 1000);
                }, i * 300);
            }

            // Reset fog after ability
            setTimeout(() => {
                scene.fog = oldFog;
            }, 4500);
        }

        function performDiveBomb(enemy) {
            enemy.currentAbility = 'diveBomb';
            enemy.abilityTimer = 4.0;
            showBossMessage('DIVE BOMB!', 0xff0000);
            showBossAttackWarning('DIVE BOMB - DODGE NOW!', 3750);

            const startPos = enemy.mesh.position.clone();
            let targetPos = player.position.clone();

            // Dragon roars and begins ascent
            createBossRoarEffect(enemy, 0xff0000);
            screenShake(0.4, 3.5);

            // Glow intensifies during ascent
            enemy.mesh.children.forEach(child => {
                if (child.material && child.material.emissive) {
                    child.material.emissive.setHex(0xff4400);
                }
            });

            let phase = 'up';
            let progress = 0;

            const diveInterval = setInterval(() => {
                progress += 0.04;

                if (phase === 'up') {
                    enemy.mesh.position.y = progress * 20;
                    enemy.mesh.rotation.x = -progress * 0.6;
                    enemy.mesh.scale.set(1 - progress * 0.3, 1 - progress * 0.3, 1 - progress * 0.3);

                    // Emissive intensity increases
                    enemy.mesh.children.forEach(child => {
                        if (child.material && child.material.emissive) {
                            child.material.emissiveIntensity = progress;
                        }
                    });

                    // Wind effect as dragon rises
                    if (progress > 0.3 && Math.random() > 0.5) {
                        createDustCloud(startPos.x, startPos.z, 3, 3);
                    }

                    if (progress >= 1) {
                        phase = 'hover';
                        progress = 0;
                        targetPos.copy(player.position);

                        // Show massive target reticle
                        showBossMessage('INCOMING!!!', 0xff0000);
                    }
                } else if (phase === 'hover') {
                    // Brief hover with target indicator
                    progress += 0.1;

                    // Pulsing target on ground
                    const targetGeo = new THREE.RingGeometry(4, 6, 32);
                    const targetMat = new THREE.MeshBasicMaterial({
                        color: 0xff0000, transparent: true, opacity: 0.6 + Math.sin(progress * 20) * 0.3, side: THREE.DoubleSide
                    });
                    const target = new THREE.Mesh(targetGeo, targetMat);
                    target.position.set(targetPos.x, 0.1, targetPos.z);
                    target.rotation.x = -Math.PI / 2;
                    scene.add(target);
                    setTimeout(() => scene.remove(target), 60);

                    // Inner crosshairs
                    for (let i = 0; i < 4; i++) {
                        const lineGeo = new THREE.BoxGeometry(0.2, 0.05, 3);
                        const lineMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.8 });
                        const line = new THREE.Mesh(lineGeo, lineMat);
                        line.position.set(targetPos.x, 0.15, targetPos.z);
                        line.rotation.y = (i / 4) * Math.PI;
                        scene.add(line);
                        setTimeout(() => scene.remove(line), 60);
                    }

                    if (progress >= 0.5) {
                        phase = 'dive';
                        progress = 0;
                    }
                } else if (phase === 'dive') {
                    const t = Math.min(progress * 1.5, 1); // Faster dive
                    enemy.mesh.position.x = startPos.x + (targetPos.x - startPos.x) * t;
                    enemy.mesh.position.z = startPos.z + (targetPos.z - startPos.z) * t;
                    enemy.mesh.position.y = 20 * (1 - t * t); // Accelerating descent
                    enemy.mesh.rotation.x = 1.2;
                    enemy.mesh.scale.set(1, 1, 1);

                    // Massive fire trail
                    for (let i = 0; i < 4; i++) {
                        const trailGeo = new THREE.SphereGeometry(0.4 + Math.random() * 0.4);
                        const colors = [0xff0000, 0xff4400, 0xff8800, 0xffff00];
                        const trailMat = new THREE.MeshBasicMaterial({ color: colors[i % 4] });
                        const trail = new THREE.Mesh(trailGeo, trailMat);
                        trail.position.copy(enemy.mesh.position);
                        trail.position.x += (Math.random() - 0.5) * 2;
                        trail.position.z += (Math.random() - 0.5) * 2;
                        trail.position.y += Math.random() * 2;
                        scene.add(trail);

                        let tLife = 0;
                        const trailFade = setInterval(() => {
                            tLife += 0.03;
                            trail.material.opacity = 1 - tLife * 2;
                            trail.scale.multiplyScalar(0.95);
                            if (tLife > 0.5) {
                                scene.remove(trail);
                                clearInterval(trailFade);
                            }
                        }, 30);
                    }

                    // Screen shake intensifies as dragon gets closer
                    screenShakeIntensity = 0.3 + progress * 0.7;
                    screenShakeDuration = 0.1;

                    if (progress >= 0.7) {
                        clearInterval(diveInterval);
                        enemy.mesh.position.y = 0;
                        enemy.mesh.rotation.x = 0;

                        // APOCALYPTIC IMPACT
                        createEpicExplosion(enemy.mesh.position.x, 1, enemy.mesh.position.z, 0xff4400, 5, 60);
                        createSlamEffect(enemy.mesh.position.x, enemy.mesh.position.z, 8, 0xff0000);
                        createGroundCrack(enemy.mesh.position.x, enemy.mesh.position.z, 10, 0x331100);
                        screenShake(1.5, 0.8);

                        // Multiple shockwaves
                        for (let w = 0; w < 4; w++) {
                            setTimeout(() => {
                                createShockwaveEffect(enemy.mesh.position.x, enemy.mesh.position.z,
                                    w === 0 ? 0xffffff : (w === 1 ? 0xff8800 : (w === 2 ? 0xff4400 : 0xff0000)));
                            }, w * 100);
                        }

                        // Fire eruption
                        for (let f = 0; f < 20; f++) {
                            const fireGeo = new THREE.SphereGeometry(0.3 + Math.random() * 0.5);
                            const fireMat = new THREE.MeshBasicMaterial({ color: Math.random() > 0.5 ? 0xff4400 : 0xff8800 });
                            const fire = new THREE.Mesh(fireGeo, fireMat);
                            const fAngle = Math.random() * Math.PI * 2;
                            const fDist = Math.random() * 6;
                            fire.position.set(
                                enemy.mesh.position.x + Math.cos(fAngle) * fDist,
                                0.3,
                                enemy.mesh.position.z + Math.sin(fAngle) * fDist
                            );
                            scene.add(fire);
                            setTimeout(() => scene.remove(fire), 2000 + Math.random() * 1000);
                        }

                        // Reset emissive
                        enemy.mesh.children.forEach(child => {
                            if (child.material && child.material.emissive) {
                                child.material.emissiveIntensity = 0;
                            }
                        });

                        // MASSIVE damage in area
                        const dx = player.position.x - enemy.mesh.position.x;
                        const dz = player.position.z - enemy.mesh.position.z;
                        if (Math.sqrt(dx*dx + dz*dz) < 8) {
                            playerHealth -= 50;
                            timeSinceLastHit = 0;
                            updatePlayerHealth();
                        }
                    }
                }
            }, 35);
        }

        // ========== THEMED DRAGON SPECIAL ABILITIES ==========

        // Forest Dragon - Nature's Wrath: Spawns poison pools that deal damage over time
        function performNaturesWrath(enemy) {
            enemy.currentAbility = 'naturesWrath';
            enemy.abilityTimer = 4.0;
            showBossMessage("NATURE'S WRATH!", 0x00ff44);
            showBossAttackWarning('POISON POOLS - AVOID GREEN!', 3750);

            createBossRoarEffect(enemy, 0x00ff44);
            screenShake(0.3, 2.0);

            // Spawn 8 poison pools around the arena
            for (let i = 0; i < 8; i++) {
                setTimeout(() => {
                    const poolX = player.position.x + (Math.random() - 0.5) * 25;
                    const poolZ = player.position.z + (Math.random() - 0.5) * 25;

                    // Warning indicator
                    const warningGeo = new THREE.CircleGeometry(3, 16);
                    const warningMat = new THREE.MeshBasicMaterial({ color: 0x44ff44, transparent: true, opacity: 0.4, side: THREE.DoubleSide });
                    const warning = new THREE.Mesh(warningGeo, warningMat);
                    warning.position.set(poolX, 0.05, poolZ);
                    warning.rotation.x = -Math.PI / 2;
                    scene.add(warning);

                    setTimeout(() => {
                        scene.remove(warning);

                        // Create poison pool
                        const poolGeo = new THREE.CircleGeometry(3, 16);
                        const poolMat = new THREE.MeshBasicMaterial({ color: 0x22aa22, transparent: true, opacity: 0.7, side: THREE.DoubleSide });
                        const pool = new THREE.Mesh(poolGeo, poolMat);
                        pool.position.set(poolX, 0.08, poolZ);
                        pool.rotation.x = -Math.PI / 2;
                        scene.add(pool);

                        // Bubbling effect
                        let poolLife = 0;
                        const poolInterval = setInterval(() => {
                            poolLife += 0.05;

                            // Bubbles
                            if (Math.random() > 0.7) {
                                const bubbleGeo = new THREE.SphereGeometry(0.15);
                                const bubbleMat = new THREE.MeshBasicMaterial({ color: 0x66ff66 });
                                const bubble = new THREE.Mesh(bubbleGeo, bubbleMat);
                                bubble.position.set(poolX + (Math.random() - 0.5) * 4, 0.2, poolZ + (Math.random() - 0.5) * 4);
                                scene.add(bubble);
                                setTimeout(() => scene.remove(bubble), 300);
                            }

                            // Damage player if in pool
                            const dx = player.position.x - poolX;
                            const dz = player.position.z - poolZ;
                            if (Math.sqrt(dx*dx + dz*dz) < 3) {
                                playerHealth -= 2;
                                timeSinceLastHit = 0;
                                updatePlayerHealth();
                                // Green damage flash
                                const flashGeo = new THREE.SphereGeometry(0.3);
                                const flashMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                                const flash = new THREE.Mesh(flashGeo, flashMat);
                                flash.position.copy(player.position);
                                flash.position.y = 1;
                                scene.add(flash);
                                setTimeout(() => scene.remove(flash), 100);
                            }

                            // Pool fades after 6 seconds
                            if (poolLife > 6) {
                                pool.material.opacity -= 0.05;
                                if (pool.material.opacity <= 0) {
                                    scene.remove(pool);
                                    clearInterval(poolInterval);
                                }
                            }
                        }, 100);
                    }, 800);
                }, i * 200);
            }
        }

        // Sand Wyrm - Sandstorm: Creates blinding sandstorm that damages and obscures
        function performSandstorm(enemy) {
            enemy.currentAbility = 'sandstorm';
            enemy.abilityTimer = 5.0;
            showBossMessage('SANDSTORM!', 0xffcc66);
            showBossAttackWarning('SANDSTORM - VISIBILITY REDUCED!', 3750);

            createBossRoarEffect(enemy, 0xffcc66);
            screenShake(0.4, 4.0);

            // Create sandstorm effect - fog and particles
            const oldFog = scene.fog;
            const oldBackground = scene.background.clone();
            scene.fog = new THREE.Fog(0xc2a366, 5, 30);
            scene.background = new THREE.Color(0xaa8855);

            let stormTime = 0;
            const stormInterval = setInterval(() => {
                stormTime += 0.05;

                // Sand particles everywhere
                for (let i = 0; i < 15; i++) {
                    const sandGeo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                    const sandMat = new THREE.MeshBasicMaterial({ color: 0xddbb77, transparent: true, opacity: 0.8 });
                    const sand = new THREE.Mesh(sandGeo, sandMat);
                    sand.position.set(
                        player.position.x + (Math.random() - 0.5) * 30,
                        Math.random() * 5,
                        player.position.z + (Math.random() - 0.5) * 30
                    );
                    scene.add(sand);

                    // Wind movement
                    const windDir = Math.random() * Math.PI * 2;
                    const windSpeed = 15 + Math.random() * 10;
                    let sandLife = 0;
                    const sandMove = setInterval(() => {
                        sandLife += 0.03;
                        sand.position.x += Math.cos(windDir) * windSpeed * 0.03;
                        sand.position.z += Math.sin(windDir) * windSpeed * 0.03;
                        sand.position.y += (Math.random() - 0.5) * 0.2;
                        if (sandLife > 0.5) {
                            scene.remove(sand);
                            clearInterval(sandMove);
                        }
                    }, 30);
                }

                // Periodic damage ticks
                if (Math.floor(stormTime * 10) % 10 === 0) {
                    playerHealth -= 3;
                    timeSinceLastHit = 0;
                    updatePlayerHealth();
                }

                // Storm ends after 5 seconds
                if (stormTime > 5) {
                    scene.fog = oldFog;
                    scene.background = oldBackground;
                    clearInterval(stormInterval);
                }
            }, 50);
        }

        // Inferno Drake - Volcanic Eruption: Chain explosions that track player
        function performVolcanicEruption(enemy) {
            enemy.currentAbility = 'volcanicEruption';
            enemy.abilityTimer = 5.0;
            showBossMessage('VOLCANIC ERUPTION!', 0xff2200);
            showBossAttackWarning('ERUPTION - KEEP MOVING!', 3750);

            createBossRoarEffect(enemy, 0xff0000);
            screenShake(0.5, 4.0);

            // Ground turns red briefly
            const originalGroundColor = groundMesh.material.color.getHex();
            groundMesh.material.color.setHex(0x441100);

            // Chain of 10 explosions that follow player
            let lastX = player.position.x;
            let lastZ = player.position.z;

            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    // Target slightly ahead of last position toward current player position
                    const dx = player.position.x - lastX;
                    const dz = player.position.z - lastZ;
                    const targetX = lastX + dx * 0.7 + (Math.random() - 0.5) * 3;
                    const targetZ = lastZ + dz * 0.7 + (Math.random() - 0.5) * 3;
                    lastX = targetX;
                    lastZ = targetZ;

                    // Warning crack in ground
                    const crackGeo = new THREE.RingGeometry(1, 2.5, 8);
                    const crackMat = new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.8, side: THREE.DoubleSide });
                    const crack = new THREE.Mesh(crackGeo, crackMat);
                    crack.position.set(targetX, 0.1, targetZ);
                    crack.rotation.x = -Math.PI / 2;
                    scene.add(crack);

                    // Lava glow from below
                    const glowGeo = new THREE.CircleGeometry(2, 16);
                    const glowMat = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.6, side: THREE.DoubleSide });
                    const glow = new THREE.Mesh(glowGeo, glowMat);
                    glow.position.set(targetX, 0.05, targetZ);
                    glow.rotation.x = -Math.PI / 2;
                    scene.add(glow);

                    setTimeout(() => {
                        scene.remove(crack);
                        scene.remove(glow);

                        // EXPLOSION
                        createEpicExplosion(targetX, 1, targetZ, 0xff2200, 3, 30);
                        screenShake(0.3, 0.5);

                        // Lava splatter
                        for (let s = 0; s < 8; s++) {
                            const splatGeo = new THREE.SphereGeometry(0.3);
                            const splatMat = new THREE.MeshBasicMaterial({ color: Math.random() > 0.5 ? 0xff4400 : 0xff8800 });
                            const splat = new THREE.Mesh(splatGeo, splatMat);
                            splat.position.set(targetX, 0.5, targetZ);
                            scene.add(splat);

                            const splatAngle = Math.random() * Math.PI * 2;
                            const splatSpeed = 5 + Math.random() * 5;
                            let splatLife = 0;
                            const splatInterval = setInterval(() => {
                                splatLife += 0.05;
                                splat.position.x += Math.cos(splatAngle) * splatSpeed * 0.05;
                                splat.position.z += Math.sin(splatAngle) * splatSpeed * 0.05;
                                splat.position.y += 0.2 - splatLife * 0.5;
                                if (splat.position.y < 0 || splatLife > 1) {
                                    scene.remove(splat);
                                    clearInterval(splatInterval);
                                }
                            }, 30);
                        }

                        // Damage check
                        const pDx = player.position.x - targetX;
                        const pDz = player.position.z - targetZ;
                        if (Math.sqrt(pDx*pDx + pDz*pDz) < 3) {
                            playerHealth -= 15;
                            timeSinceLastHit = 0;
                            updatePlayerHealth();
                        }
                    }, 500);
                }, i * 400);
            }

            // Reset ground color after eruption
            setTimeout(() => {
                groundMesh.material.color.setHex(originalGroundColor);
            }, 5000);
        }

        // Frost Wyrm - Frozen Prison: Creates ice that slows player and spawns ice spikes
        function performFrozenPrison(enemy) {
            enemy.currentAbility = 'frozenPrison';
            enemy.abilityTimer = 4.0;
            showBossMessage('FROZEN PRISON!', 0x88ddff);
            showBossAttackWarning('FROZEN - SLOW EFFECT!', 3750);

            createBossRoarEffect(enemy, 0x88ddff);
            screenShake(0.3, 2.5);

            // Freeze effect on player - slow them down
            const originalMoveSpeed = playerStats.moveSpeed;
            playerStats.moveSpeed = originalMoveSpeed * 0.4;

            // Ice crystals form around player's last position
            const freezeX = player.position.x;
            const freezeZ = player.position.z;

            // Ice floor
            const iceGeo = new THREE.CircleGeometry(8, 32);
            const iceMat = new THREE.MeshStandardMaterial({ color: 0xaaddff, transparent: true, opacity: 0.7, roughness: 0.1, metalness: 0.8, side: THREE.DoubleSide });
            const ice = new THREE.Mesh(iceGeo, iceMat);
            ice.position.set(freezeX, 0.05, freezeZ);
            ice.rotation.x = -Math.PI / 2;
            scene.add(ice);

            // Frost particles
            let frostTime = 0;
            const frostInterval = setInterval(() => {
                frostTime += 0.05;

                // Snowflakes
                for (let i = 0; i < 5; i++) {
                    const snowGeo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                    const snowMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                    const snow = new THREE.Mesh(snowGeo, snowMat);
                    snow.position.set(
                        freezeX + (Math.random() - 0.5) * 16,
                        5 + Math.random() * 3,
                        freezeZ + (Math.random() - 0.5) * 16
                    );
                    scene.add(snow);

                    let snowLife = 0;
                    const snowFall = setInterval(() => {
                        snowLife += 0.03;
                        snow.position.y -= 0.15;
                        snow.position.x += (Math.random() - 0.5) * 0.1;
                        snow.rotation.y += 0.1;
                        if (snow.position.y < 0 || snowLife > 2) {
                            scene.remove(snow);
                            clearInterval(snowFall);
                        }
                    }, 30);
                }

                if (frostTime > 4) {
                    clearInterval(frostInterval);
                }
            }, 50);

            // Spawn ice spikes that erupt from ground
            for (let i = 0; i < 6; i++) {
                setTimeout(() => {
                    const spikeAngle = (i / 6) * Math.PI * 2;
                    const spikeDist = 4 + Math.random() * 3;
                    const spikeX = freezeX + Math.cos(spikeAngle) * spikeDist;
                    const spikeZ = freezeZ + Math.sin(spikeAngle) * spikeDist;

                    // Warning
                    const warnGeo = new THREE.CircleGeometry(1, 8);
                    const warnMat = new THREE.MeshBasicMaterial({ color: 0x88ccff, transparent: true, opacity: 0.6, side: THREE.DoubleSide });
                    const warn = new THREE.Mesh(warnGeo, warnMat);
                    warn.position.set(spikeX, 0.1, spikeZ);
                    warn.rotation.x = -Math.PI / 2;
                    scene.add(warn);

                    setTimeout(() => {
                        scene.remove(warn);

                        // Ice spike erupts
                        const spikeGeo = new THREE.ConeGeometry(0.8, 4, 6);
                        const spikeMat = new THREE.MeshStandardMaterial({ color: 0xaaddff, transparent: true, opacity: 0.9, roughness: 0.1, metalness: 0.5 });
                        const spike = new THREE.Mesh(spikeGeo, spikeMat);
                        spike.position.set(spikeX, -2, spikeZ);
                        scene.add(spike);

                        // Spike rises from ground
                        let spikeProgress = 0;
                        const spikeRise = setInterval(() => {
                            spikeProgress += 0.1;
                            spike.position.y = -2 + spikeProgress * 4;

                            // Damage if player hit during rise
                            if (spikeProgress < 0.5) {
                                const dx = player.position.x - spikeX;
                                const dz = player.position.z - spikeZ;
                                if (Math.sqrt(dx*dx + dz*dz) < 1.5) {
                                    playerHealth -= 12;
                                    timeSinceLastHit = 0;
                                    updatePlayerHealth();
                                }
                            }

                            if (spikeProgress >= 1) {
                                clearInterval(spikeRise);

                                // Spike shatters after a moment
                                setTimeout(() => {
                                    // Shatter particles
                                    for (let s = 0; s < 6; s++) {
                                        const shardGeo = new THREE.BoxGeometry(0.2, 0.3, 0.15);
                                        const shardMat = new THREE.MeshBasicMaterial({ color: 0xccffff });
                                        const shard = new THREE.Mesh(shardGeo, shardMat);
                                        shard.position.copy(spike.position);
                                        shard.position.y += 1;
                                        scene.add(shard);

                                        const shardAngle = Math.random() * Math.PI * 2;
                                        const shardSpeed = 3 + Math.random() * 3;
                                        let shardLife = 0;
                                        const shardMove = setInterval(() => {
                                            shardLife += 0.05;
                                            shard.position.x += Math.cos(shardAngle) * shardSpeed * 0.05;
                                            shard.position.z += Math.sin(shardAngle) * shardSpeed * 0.05;
                                            shard.position.y += 0.1 - shardLife * 0.3;
                                            shard.rotation.x += 0.2;
                                            shard.rotation.z += 0.15;
                                            if (shard.position.y < 0 || shardLife > 1) {
                                                scene.remove(shard);
                                                clearInterval(shardMove);
                                            }
                                        }, 30);
                                    }
                                    scene.remove(spike);
                                }, 1500);
                            }
                        }, 30);
                    }, 400);
                }, i * 300);
            }

            // Remove ice floor and restore speed after 4 seconds
            setTimeout(() => {
                scene.remove(ice);
                playerStats.moveSpeed = originalMoveSpeed;
            }, 4000);
        }

        // Plague Dragon - Toxic Miasma: Spreads poisonous gas that damages and spawns plague minions
        function performToxicMiasma(enemy) {
            enemy.currentAbility = 'toxicMiasma';
            enemy.abilityTimer = 5.0;
            showBossMessage('TOXIC MIASMA!', 0x66ff22);
            showBossAttackWarning('POISON GAS - GET AWAY!', 3750);

            createBossRoarEffect(enemy, 0x66ff22);
            screenShake(0.3, 2.5);

            // Green fog spreads from dragon
            const oldFog = scene.fog;
            scene.fog = new THREE.Fog(0x334422, 10, 40);

            // Expanding poison cloud
            const cloudCenter = enemy.mesh.position.clone();
            let cloudRadius = 0;
            let miasmaTime = 0;

            const miasmaInterval = setInterval(() => {
                miasmaTime += 0.05;
                cloudRadius = Math.min(miasmaTime * 8, 20);

                // Poison particles
                for (let i = 0; i < 10; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * cloudRadius;
                    const gasGeo = new THREE.SphereGeometry(0.3 + Math.random() * 0.3);
                    const gasMat = new THREE.MeshBasicMaterial({
                        color: Math.random() > 0.5 ? 0x66ff22 : 0x44aa11,
                        transparent: true,
                        opacity: 0.5
                    });
                    const gas = new THREE.Mesh(gasGeo, gasMat);
                    gas.position.set(
                        cloudCenter.x + Math.cos(angle) * dist,
                        0.5 + Math.random() * 2,
                        cloudCenter.z + Math.sin(angle) * dist
                    );
                    scene.add(gas);

                    let gasLife = 0;
                    const gasFloat = setInterval(() => {
                        gasLife += 0.04;
                        gas.position.y += 0.05;
                        gas.position.x += (Math.random() - 0.5) * 0.1;
                        gas.material.opacity -= 0.02;
                        if (gasLife > 1) {
                            scene.remove(gas);
                            clearInterval(gasFloat);
                        }
                    }, 30);
                }

                // Damage player if in cloud
                const dx = player.position.x - cloudCenter.x;
                const dz = player.position.z - cloudCenter.z;
                if (Math.sqrt(dx*dx + dz*dz) < cloudRadius) {
                    playerHealth -= 2;
                    timeSinceLastHit = 0;
                    updatePlayerHealth();
                }

                // Spawn plague minions at intervals
                if (Math.floor(miasmaTime * 10) % 20 === 0 && enemies.length < 8) {
                    const spawnAngle = Math.random() * Math.PI * 2;
                    const spawnDist = 5 + Math.random() * 10;
                    const spawnX = cloudCenter.x + Math.cos(spawnAngle) * spawnDist;
                    const spawnZ = cloudCenter.z + Math.sin(spawnAngle) * spawnDist;

                    // Spawn effect
                    const spawnGeo = new THREE.SphereGeometry(1);
                    const spawnMat = new THREE.MeshBasicMaterial({ color: 0x66ff22, transparent: true, opacity: 0.8 });
                    const spawnEffect = new THREE.Mesh(spawnGeo, spawnMat);
                    spawnEffect.position.set(spawnX, 0.5, spawnZ);
                    scene.add(spawnEffect);
                    setTimeout(() => scene.remove(spawnEffect), 500);

                    const minion = createEnemy(spawnX, spawnZ, 0, 'swampZombie');
                    enemies.push(minion);
                }

                if (miasmaTime > 5) {
                    scene.fog = oldFog;
                    clearInterval(miasmaInterval);
                }
            }, 50);
        }

        // Void Dragon - Shadow Rift: Creates void portals that pull player and spawn shadow clones
        function performShadowRift(enemy) {
            enemy.currentAbility = 'shadowRift';
            enemy.abilityTimer = 5.0;
            showBossMessage('SHADOW RIFT!', 0xaa44ff);
            showBossAttackWarning('VOID PORTALS - AVOID PULL!', 3750);

            createBossRoarEffect(enemy, 0xaa44ff);
            screenShake(0.4, 3.0);

            // Darken the world
            const oldBackground = scene.background.clone();
            scene.background = new THREE.Color(0x0a0a1a);
            ambientLight.intensity = 0.1;

            // Create 4 void portals
            const portals = [];
            for (let i = 0; i < 4; i++) {
                const portalAngle = (i / 4) * Math.PI * 2 + Math.random() * 0.5;
                const portalDist = 10 + Math.random() * 8;
                const portalX = player.position.x + Math.cos(portalAngle) * portalDist;
                const portalZ = player.position.z + Math.sin(portalAngle) * portalDist;

                // Portal visual - swirling void
                const portalGroup = new THREE.Group();

                const ringGeo = new THREE.TorusGeometry(2, 0.3, 8, 24);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0x8844cc });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = Math.PI / 2;
                portalGroup.add(ring);

                const innerGeo = new THREE.CircleGeometry(1.8, 24);
                const innerMat = new THREE.MeshBasicMaterial({ color: 0x1a0a2a, side: THREE.DoubleSide });
                const inner = new THREE.Mesh(innerGeo, innerMat);
                inner.rotation.x = -Math.PI / 2;
                inner.position.y = 0.1;
                portalGroup.add(inner);

                portalGroup.position.set(portalX, 0.5, portalZ);
                scene.add(portalGroup);
                portals.push({ group: portalGroup, x: portalX, z: portalZ });
            }

            let riftTime = 0;
            const riftInterval = setInterval(() => {
                riftTime += 0.05;

                // Rotate portals and create particles
                portals.forEach(portal => {
                    portal.group.rotation.y += 0.1;

                    // Void particles being sucked in
                    if (Math.random() > 0.6) {
                        const pAngle = Math.random() * Math.PI * 2;
                        const pDist = 3 + Math.random() * 2;
                        const particleGeo = new THREE.BoxGeometry(0.15, 0.15, 0.15);
                        const particleMat = new THREE.MeshBasicMaterial({ color: 0xaa66ff });
                        const particle = new THREE.Mesh(particleGeo, particleMat);
                        particle.position.set(
                            portal.x + Math.cos(pAngle) * pDist,
                            0.5 + Math.random(),
                            portal.z + Math.sin(pAngle) * pDist
                        );
                        scene.add(particle);

                        const pullInterval = setInterval(() => {
                            const dx = portal.x - particle.position.x;
                            const dz = portal.z - particle.position.z;
                            particle.position.x += dx * 0.15;
                            particle.position.z += dz * 0.15;
                            if (Math.sqrt(dx*dx + dz*dz) < 0.5) {
                                scene.remove(particle);
                                clearInterval(pullInterval);
                            }
                        }, 30);
                    }

                    // Pull player toward nearest portal
                    const dx = portal.x - player.position.x;
                    const dz = portal.z - player.position.z;
                    const dist = Math.sqrt(dx*dx + dz*dz);
                    if (dist < 8 && dist > 2) {
                        const pullStrength = 0.03 * (8 - dist) / 8;
                        player.position.x += dx * pullStrength;
                        player.position.z += dz * pullStrength;
                    }

                    // Damage if too close to portal
                    if (dist < 2.5) {
                        playerHealth -= 4;
                        timeSinceLastHit = 0;
                        updatePlayerHealth();
                    }
                });

                // Spawn shadow clones from portals
                if (Math.floor(riftTime * 10) % 25 === 0 && enemies.length < 6) {
                    const portal = portals[Math.floor(Math.random() * portals.length)];
                    const clone = createEnemy(portal.x, portal.z, 0, 'shadowWraith');
                    enemies.push(clone);

                    // Spawn flash
                    const flashGeo = new THREE.SphereGeometry(1.5);
                    const flashMat = new THREE.MeshBasicMaterial({ color: 0xaa44ff, transparent: true, opacity: 0.8 });
                    const flash = new THREE.Mesh(flashGeo, flashMat);
                    flash.position.set(portal.x, 1, portal.z);
                    scene.add(flash);
                    setTimeout(() => scene.remove(flash), 300);
                }

                // End ability
                if (riftTime > 5) {
                    // Close portals with implosion effect
                    portals.forEach(portal => {
                        for (let i = 0; i < 10; i++) {
                            const debrisGeo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                            const debrisMat = new THREE.MeshBasicMaterial({ color: 0x6633aa });
                            const debris = new THREE.Mesh(debrisGeo, debrisMat);
                            debris.position.set(portal.x, 0.5, portal.z);
                            scene.add(debris);

                            const debrisAngle = Math.random() * Math.PI * 2;
                            const debrisSpeed = 3 + Math.random() * 3;
                            let debrisLife = 0;
                            const debrisMove = setInterval(() => {
                                debrisLife += 0.05;
                                debris.position.x += Math.cos(debrisAngle) * debrisSpeed * 0.05;
                                debris.position.z += Math.sin(debrisAngle) * debrisSpeed * 0.05;
                                debris.position.y += 0.1 - debrisLife * 0.2;
                                if (debrisLife > 1) {
                                    scene.remove(debris);
                                    clearInterval(debrisMove);
                                }
                            }, 30);
                        }
                        scene.remove(portal.group);
                    });

                    // Restore lighting
                    scene.background = oldBackground;
                    ambientLight.intensity = currentMap.ambientIntensity;
                    clearInterval(riftInterval);
                }
            }, 50);
        }

        // Crystal Dragon - Crystal Shatter: Launches crystal shards in all directions
        function performCrystalShatter(enemy) {
            enemy.currentAbility = 'crystalShatter';
            enemy.abilityTimer = 3.0;
            showBossMessage('CRYSTAL SHATTER!', 0x88ccff);
            showBossAttackWarning('CRYSTAL SHARDS - DODGE!', 2500);

            createBossRoarEffect(enemy, 0x88ccff);
            screenShake(0.4, 2.5);

            // Crystal forms around dragon then explodes
            const crystals = [];
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                const crystalGeo = new THREE.ConeGeometry(0.5, 2, 6);
                const crystalMat = new THREE.MeshStandardMaterial({
                    color: 0x88aaff, transparent: true, opacity: 0.9, roughness: 0.1, metalness: 0.8
                });
                const crystal = new THREE.Mesh(crystalGeo, crystalMat);
                crystal.position.copy(enemy.mesh.position);
                crystal.position.y = 2;
                crystal.rotation.z = Math.PI / 2;
                crystal.rotation.y = angle;
                scene.add(crystal);
                crystals.push({ mesh: crystal, angle: angle });
            }

            // Crystals pulse then launch
            let chargeTime = 0;
            const chargeInterval = setInterval(() => {
                chargeTime += 0.05;
                crystals.forEach(c => {
                    c.mesh.scale.setScalar(1 + Math.sin(chargeTime * 15) * 0.2);
                });

                if (chargeTime > 1) {
                    clearInterval(chargeInterval);

                    // Launch crystals outward
                    crystals.forEach(c => {
                        const speed = 25;
                        const vx = Math.cos(c.angle) * speed;
                        const vz = Math.sin(c.angle) * speed;

                        let flightTime = 0;
                        const flightInterval = setInterval(() => {
                            flightTime += 0.03;
                            c.mesh.position.x += vx * 0.03;
                            c.mesh.position.z += vz * 0.03;
                            c.mesh.rotation.x += 0.2;

                            // Damage check
                            const dx = player.position.x - c.mesh.position.x;
                            const dz = player.position.z - c.mesh.position.z;
                            if (Math.sqrt(dx*dx + dz*dz) < 1.5) {
                                playerHealth -= 15;
                                timeSinceLastHit = 0;
                                updatePlayerHealth();
                            }

                            if (flightTime > 1) {
                                scene.remove(c.mesh);
                                clearInterval(flightInterval);
                            }
                        }, 30);
                    });
                }
            }, 50);
        }

        // Bone Dragon - Grave Rise: Summons skeleton minions from the ground
        function performGraveRise(enemy) {
            enemy.currentAbility = 'graveRise';
            enemy.abilityTimer = 4.0;
            showBossMessage('GRAVE RISE!', 0x88ff88);
            showBossAttackWarning('UNDEAD RISING!', 3750);

            createBossRoarEffect(enemy, 0x88ff88);
            screenShake(0.3, 3.0);

            // Ghostly green fog
            const oldFog = scene.fog;
            scene.fog = new THREE.Fog(0x224422, 15, 50);

            // Spawn graves that erupt with skeletons
            for (let i = 0; i < 6; i++) {
                setTimeout(() => {
                    const graveX = player.position.x + (Math.random() - 0.5) * 25;
                    const graveZ = player.position.z + (Math.random() - 0.5) * 25;

                    // Grave mound appears
                    const moundGeo = new THREE.BoxGeometry(1.5, 0.5, 2);
                    const moundMat = new THREE.MeshStandardMaterial({ color: 0x3a3a2a });
                    const mound = new THREE.Mesh(moundGeo, moundMat);
                    mound.position.set(graveX, 0.25, graveZ);
                    scene.add(mound);

                    // Hand reaches up effect
                    setTimeout(() => {
                        const handGeo = new THREE.BoxGeometry(0.2, 0.8, 0.15);
                        const handMat = new THREE.MeshBasicMaterial({ color: 0xcccccc });
                        const hand = new THREE.Mesh(handGeo, handMat);
                        hand.position.set(graveX, 0, graveZ);
                        scene.add(hand);

                        let riseTime = 0;
                        const riseInterval = setInterval(() => {
                            riseTime += 0.1;
                            hand.position.y = riseTime * 0.8;
                            if (riseTime > 1) {
                                clearInterval(riseInterval);
                                scene.remove(hand);
                                scene.remove(mound);

                                // Spawn skeleton enemy
                                if (enemies.length < 10) {
                                    const skeleton = createEnemy(graveX, graveZ, 0, 'skeleton');
                                    enemies.push(skeleton);
                                }
                            }
                        }, 50);
                    }, 500);
                }, i * 400);
            }

            setTimeout(() => {
                scene.fog = oldFog;
            }, 4000);
        }

        // Storm Dragon - Thunder Storm: Lightning strikes across the arena
        function performThunderStorm(enemy) {
            enemy.currentAbility = 'thunderStorm';
            enemy.abilityTimer = 5.0;
            showBossMessage('THUNDER STORM!', 0xffffaa);
            showBossAttackWarning('LIGHTNING - KEEP MOVING!', 3750);

            createBossRoarEffect(enemy, 0xffffaa);
            screenShake(0.3, 4.0);

            // Darken sky briefly for each strike
            const originalSky = scene.background.clone();

            // Multiple lightning strikes
            for (let i = 0; i < 8; i++) {
                setTimeout(() => {
                    const strikeX = player.position.x + (Math.random() - 0.5) * 20;
                    const strikeZ = player.position.z + (Math.random() - 0.5) * 20;

                    // Warning circle
                    const warnGeo = new THREE.CircleGeometry(2, 16);
                    const warnMat = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
                    const warn = new THREE.Mesh(warnGeo, warnMat);
                    warn.position.set(strikeX, 0.1, strikeZ);
                    warn.rotation.x = -Math.PI / 2;
                    scene.add(warn);

                    setTimeout(() => {
                        scene.remove(warn);

                        // Lightning bolt
                        scene.background = new THREE.Color(0xffffff);
                        const boltGeo = new THREE.BoxGeometry(0.3, 30, 0.3);
                        const boltMat = new THREE.MeshBasicMaterial({ color: 0xffffaa });
                        const bolt = new THREE.Mesh(boltGeo, boltMat);
                        bolt.position.set(strikeX, 15, strikeZ);
                        scene.add(bolt);

                        // Flash and damage
                        screenShake(0.5, 0.3);
                        const dx = player.position.x - strikeX;
                        const dz = player.position.z - strikeZ;
                        if (Math.sqrt(dx*dx + dz*dz) < 3) {
                            playerHealth -= 20;
                            timeSinceLastHit = 0;
                            updatePlayerHealth();
                        }

                        setTimeout(() => {
                            scene.remove(bolt);
                            scene.background = originalSky;
                        }, 100);
                    }, 600);
                }, i * 500);
            }
        }

        // Abyssal Dragon - Hellfire Rain: Meteors of hellfire rain from above
        function performHellfireRain(enemy) {
            enemy.currentAbility = 'hellfireRain';
            enemy.abilityTimer = 6.0;
            showBossMessage('HELLFIRE RAIN!', 0xff0000);
            showBossAttackWarning('HELLFIRE - NOWHERE IS SAFE!', 5000);

            createBossRoarEffect(enemy, 0xff0000);
            screenShake(0.5, 5.0);

            // Sky turns blood red
            const oldBackground = scene.background.clone();
            scene.background = new THREE.Color(0x220000);

            // Rain hellfire across the ENTIRE arena
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    const fireX = (Math.random() - 0.5) * 60;
                    const fireZ = (Math.random() - 0.5) * 60;

                    // Warning
                    const warnGeo = new THREE.CircleGeometry(2.5, 16);
                    const warnMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.4, side: THREE.DoubleSide });
                    const warn = new THREE.Mesh(warnGeo, warnMat);
                    warn.position.set(fireX, 0.1, fireZ);
                    warn.rotation.x = -Math.PI / 2;
                    scene.add(warn);

                    setTimeout(() => {
                        scene.remove(warn);

                        // Hellfire meteor
                        const meteorGeo = new THREE.SphereGeometry(1);
                        const meteorMat = new THREE.MeshBasicMaterial({ color: 0xff2200 });
                        const meteor = new THREE.Mesh(meteorGeo, meteorMat);
                        meteor.position.set(fireX, 25, fireZ);
                        scene.add(meteor);

                        let fallSpeed = 0.5;
                        const fallInterval = setInterval(() => {
                            fallSpeed += 0.3;
                            meteor.position.y -= fallSpeed;

                            // Fire trail
                            const trailGeo = new THREE.SphereGeometry(0.3);
                            const trailMat = new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.6 });
                            const trail = new THREE.Mesh(trailGeo, trailMat);
                            trail.position.copy(meteor.position);
                            scene.add(trail);
                            setTimeout(() => scene.remove(trail), 200);

                            if (meteor.position.y <= 0) {
                                clearInterval(fallInterval);
                                scene.remove(meteor);

                                // Explosion
                                createEpicExplosion(fireX, 0.5, fireZ, 0xff0000, 2, 15);

                                // Damage
                                const dx = player.position.x - fireX;
                                const dz = player.position.z - fireZ;
                                if (Math.sqrt(dx*dx + dz*dz) < 3.5) {
                                    playerHealth -= 18;
                                    timeSinceLastHit = 0;
                                    updatePlayerHealth();
                                }
                            }
                        }, 30);
                    }, 400);
                }, i * 250);
            }

            setTimeout(() => {
                scene.background = oldBackground;
            }, 6000);
        }

        // ========== DEMON LORD BOSS ABILITIES ==========
        function updateDemonLordBoss(enemy, deltaTime, distance) {
            const cd = enemy.abilityCooldowns;

            // Hellfire - AoE fire around boss
            if (cd.hellfire <= 0 && distance < 10) {
                performHellfire(enemy);
                cd.hellfire = 14;
                setBossGlobalCooldown(enemy, 6);
                return true;
            }

            // Demon Summon - Spawn minions
            if (cd.demonSummon <= 0 && enemies.length < 5) {
                performDemonSummon(enemy);
                cd.demonSummon = 20;
                setBossGlobalCooldown(enemy, 5);
                return true;
            }

            // Dark Slash - Ranged slash wave (locks direction)
            if (cd.darkSlash <= 0 && distance > 5 && distance < 15) {
                performDarkSlash(enemy);
                cd.darkSlash = 10;
                setBossGlobalCooldown(enemy, 5);
                return true;
            }

            // Soul Drain - Heal from player
            if (cd.soulDrain <= 0 && distance < 12 && enemy.health < enemy.maxHealth * 0.6) {
                performSoulDrain(enemy);
                cd.soulDrain = 22;
                setBossGlobalCooldown(enemy, 6);
                return true;
            }

            return false;
        }

        function performHellfire(enemy) {
            enemy.currentAbility = 'hellfire';
            enemy.abilityTimer = 3.5;
            showBossMessage('HELLFIRE!', 0xff2200);
            showBossAttackWarning('HELLFIRE - GET AWAY!', 2500);

            // Demon Lord charges up - rises slightly and glows
            const startY = enemy.mesh.position.y;
            let chargeTime = 0;

            // Dark aura appears
            const auraGeo = new THREE.SphereGeometry(3);
            const auraMat = new THREE.MeshBasicMaterial({
                color: 0x660000, transparent: true, opacity: 0.4, side: THREE.BackSide
            });
            const aura = new THREE.Mesh(auraGeo, auraMat);
            enemy.mesh.add(aura);

            const chargeInterval = setInterval(() => {
                chargeTime += 0.04;
                enemy.mesh.position.y = startY + Math.sin(chargeTime * 10) * 0.5 + chargeTime;

                // Glow intensifies
                enemy.mesh.children.forEach(child => {
                    if (child.material && child.material.emissive && child !== aura) {
                        child.material.emissive.setHex(0xff2200);
                        child.material.emissiveIntensity = chargeTime * 1.5;
                    }
                });

                // Sparks gathering
                if (chargeTime < 0.8) {
                    const sparkGeo = new THREE.SphereGeometry(0.1);
                    const sparkMat = new THREE.MeshBasicMaterial({ color: 0xff4400 });
                    const spark = new THREE.Mesh(sparkGeo, sparkMat);
                    const sAngle = Math.random() * Math.PI * 2;
                    const sDist = 5 + Math.random() * 3;
                    spark.position.set(
                        enemy.mesh.position.x + Math.cos(sAngle) * sDist,
                        Math.random() * 3,
                        enemy.mesh.position.z + Math.sin(sAngle) * sDist
                    );
                    scene.add(spark);
                    const sparkMove = setInterval(() => {
                        spark.position.x += (enemy.mesh.position.x - spark.position.x) * 0.1;
                        spark.position.y += (enemy.mesh.position.y + 1 - spark.position.y) * 0.1;
                        spark.position.z += (enemy.mesh.position.z - spark.position.z) * 0.1;
                        if (spark.position.distanceTo(enemy.mesh.position) < 1) {
                            scene.remove(spark);
                            clearInterval(sparkMove);
                        }
                    }, 30);
                }

                aura.scale.set(1 + chargeTime * 0.5, 1 + chargeTime * 0.5, 1 + chargeTime * 0.5);

                if (chargeTime >= 1.0) {
                    clearInterval(chargeInterval);
                    enemy.mesh.remove(aura);
                    enemy.mesh.position.y = startY;

                    // UNLEASH HELLFIRE
                    screenShake(0.6, 2.5);
                    createBossRoarEffect(enemy, 0xff0000);

                    // Ground cracks before fire
                    createGroundCrack(enemy.mesh.position.x, enemy.mesh.position.z, 12, 0x440000);

                    // Expanding rings of hellfire
                    let ringCount = 0;
                    const fireInterval = setInterval(() => {
                        ringCount++;
                        const radius = ringCount * 3.5;

                        // Create epic fire ring with multiple layers
                        for (let i = 0; i < 24; i++) {
                            const angle = (i / 24) * Math.PI * 2 + ringCount * 0.2;

                            // Main fire pillar
                            const pillarGeo = new THREE.CylinderGeometry(0.3, 0.5, 2 + Math.random() * 2, 8);
                            const pillarMat = new THREE.MeshBasicMaterial({
                                color: Math.random() > 0.3 ? 0xff4400 : (Math.random() > 0.5 ? 0xff0000 : 0xffaa00)
                            });
                            const pillar = new THREE.Mesh(pillarGeo, pillarMat);
                            pillar.position.set(
                                enemy.mesh.position.x + Math.cos(angle) * radius,
                                1,
                                enemy.mesh.position.z + Math.sin(angle) * radius
                            );
                            scene.add(pillar);

                            // Fire rises then falls
                            let pLife = 0;
                            const pillarAnim = setInterval(() => {
                                pLife += 0.05;
                                if (pLife < 0.5) {
                                    pillar.scale.y = 1 + pLife * 2;
                                    pillar.position.y = 1 + pLife;
                                } else {
                                    pillar.scale.y *= 0.9;
                                    pillar.material.opacity = 1 - (pLife - 0.5) * 2;
                                    pillar.material.transparent = true;
                                }
                                if (pLife > 1) {
                                    scene.remove(pillar);
                                    clearInterval(pillarAnim);
                                }
                            }, 30);

                            // Damage check
                            const dx = player.position.x - pillar.position.x;
                            const dz = player.position.z - pillar.position.z;
                            if (Math.sqrt(dx*dx + dz*dz) < 2.5) {
                                playerHealth -= 12;
                                timeSinceLastHit = 0;
                                updatePlayerHealth();
                            }
                        }

                        // Ember particles between rings
                        for (let e = 0; e < 10; e++) {
                            const eAngle = Math.random() * Math.PI * 2;
                            const eDist = radius - 1 + Math.random() * 2;
                            const emberGeo = new THREE.SphereGeometry(0.1);
                            const emberMat = new THREE.MeshBasicMaterial({ color: 0xff8800 });
                            const ember = new THREE.Mesh(emberGeo, emberMat);
                            ember.position.set(
                                enemy.mesh.position.x + Math.cos(eAngle) * eDist,
                                0.5,
                                enemy.mesh.position.z + Math.sin(eAngle) * eDist
                            );
                            scene.add(ember);

                            const vy = 2 + Math.random() * 3;
                            let eLife = 0;
                            const emberMove = setInterval(() => {
                                eLife += 0.03;
                                ember.position.y += vy * 0.03 * (1 - eLife);
                                if (eLife > 1) {
                                    scene.remove(ember);
                                    clearInterval(emberMove);
                                }
                            }, 30);
                        }

                        if (ringCount >= 6) {
                            clearInterval(fireInterval);
                            enemy.mesh.children.forEach(child => {
                                if (child.material && child.material.emissive) {
                                    child.material.emissiveIntensity = 0;
                                }
                            });
                        }
                    }, 180);
                }
            }, 30);
        }

        function performDemonSummon(enemy) {
            enemy.currentAbility = 'demonSummon';
            enemy.abilityTimer = 2.0; // Extended for warning
            showBossMessage('RISE, MY MINIONS!', 0x660022);
            showBossAttackWarning('SUMMONING MINIONS', 2500);

            // Summon demon spawns around the boss
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const angle = (i / 3) * Math.PI * 2;
                    const spawnX = enemy.mesh.position.x + Math.cos(angle) * 5;
                    const spawnZ = enemy.mesh.position.z + Math.sin(angle) * 5;

                    // Summon effect
                    createShockwaveEffect(spawnX, spawnZ, 0x660022);

                    // Create minion
                    const minion = createEnemy(spawnX, spawnZ, 0, 'demonSpawn');
                    enemies.push(minion);
                    updateEnemyCount();
                }, i * 400);
            }
        }

        function performDarkSlash(enemy) {
            enemy.currentAbility = 'darkSlash';
            enemy.abilityTimer = 1.3; // Extended for warning
            showBossMessage('DARK SLASH!', 0x440044);
            showBossAttackWarning('DARK SLASH', 2000);

            // Send dark wave toward player
            const dir = new THREE.Vector3(
                player.position.x - enemy.mesh.position.x,
                0,
                player.position.z - enemy.mesh.position.z
            ).normalize();

            const slashGeo = new THREE.BoxGeometry(4, 2, 0.5);
            const slashMat = new THREE.MeshBasicMaterial({ color: 0x660066, transparent: true, opacity: 0.8 });
            const slash = new THREE.Mesh(slashGeo, slashMat);
            slash.position.copy(enemy.mesh.position);
            slash.position.y = 1;
            slash.rotation.y = Math.atan2(dir.x, dir.z);
            scene.add(slash);

            let dist = 0;
            const slashInterval = setInterval(() => {
                dist += 1.5;
                slash.position.x = enemy.mesh.position.x + dir.x * dist;
                slash.position.z = enemy.mesh.position.z + dir.z * dist;

                // Damage check
                const dx = player.position.x - slash.position.x;
                const dz = player.position.z - slash.position.z;
                if (Math.sqrt(dx*dx + dz*dz) < 3) {
                    playerHealth -= 30;
                    timeSinceLastHit = 0;
                    updatePlayerHealth();
                    scene.remove(slash);
                    clearInterval(slashInterval);
                }

                if (dist > 25) {
                    scene.remove(slash);
                    clearInterval(slashInterval);
                }
            }, 30);
        }

        function performSoulDrain(enemy) {
            enemy.currentAbility = 'soulDrain';
            enemy.abilityTimer = 2.5; // Extended for warning
            showBossMessage('YOUR SOUL IS MINE!', 0x8800ff);
            showBossAttackWarning('SOUL DRAIN - INTERRUPT!', 3000);

            // Drain particles from player to boss
            let drainTicks = 0;
            const drainInterval = setInterval(() => {
                drainTicks++;

                // Create drain particle
                const particleGeo = new THREE.SphereGeometry(0.2);
                const particleMat = new THREE.MeshBasicMaterial({ color: 0x8800ff });
                const particle = new THREE.Mesh(particleGeo, particleMat);
                particle.position.copy(player.position);
                particle.position.y = 1.5;
                scene.add(particle);

                // Animate toward boss
                const moveInterval = setInterval(() => {
                    const dx = enemy.mesh.position.x - particle.position.x;
                    const dz = enemy.mesh.position.z - particle.position.z;
                    const dist = Math.sqrt(dx*dx + dz*dz);

                    if (dist < 1) {
                        scene.remove(particle);
                        clearInterval(moveInterval);
                        // Heal boss
                        enemy.health = Math.min(enemy.maxHealth, enemy.health + 15);
                    } else {
                        particle.position.x += dx * 0.1;
                        particle.position.z += dz * 0.1;
                        particle.position.y += 0.05;
                    }
                }, 30);

                // Damage player
                playerHealth -= 5;
                timeSinceLastHit = 0;
                updatePlayerHealth();

                if (drainTicks >= 8) clearInterval(drainInterval);
            }, 200);
        }

        // ========== ANCIENT GOD BOSS ABILITIES ==========
        function updateAncientGodBoss(enemy, deltaTime, distance) {
            const cd = enemy.abilityCooldowns;

            // Divine Smite - Targeted holy bolt (locks direction)
            if (cd.divineSmite <= 0 && distance < 20) {
                performDivineSmite(enemy);
                cd.divineSmite = 10;
                setBossGlobalCooldown(enemy, 5);
                return true;
            }

            // Holy Nova - Expanding holy damage
            if (cd.holyNova <= 0 && distance < 15) {
                performHolyNova(enemy);
                cd.holyNova = 16;
                setBossGlobalCooldown(enemy, 6);
                return true;
            }

            // Judgment - Beam from sky (locks positions)
            if (cd.judgment <= 0 && enemy.phase >= 2) {
                performJudgment(enemy);
                cd.judgment = 14;
                setBossGlobalCooldown(enemy, 6);
                return true;
            }

            // Celestial Beam - Sweeping laser
            if (cd.celestialBeam <= 0 && enemy.phase >= 2 && distance < 18) {
                performCelestialBeam(enemy);
                cd.celestialBeam = 18;
                setBossGlobalCooldown(enemy, 7);
                return true;
            }

            // Ascend - Invulnerable + rain attacks
            if (cd.ascend <= 0 && enemy.phase >= 3) {
                performAscend(enemy);
                cd.ascend = 30;
                setBossGlobalCooldown(enemy, 8);
                return true;
            }

            return false;
        }

        function performDivineSmite(enemy) {
            enemy.currentAbility = 'divineSmite';
            enemy.abilityTimer = 1.2; // Extended for warning
            showBossMessage('DIVINE SMITE!', 0xffd700);
            showBossAttackWarning('DIVINE SMITE', 2000);

            // Holy bolt toward player
            const dir = new THREE.Vector3(
                player.position.x - enemy.mesh.position.x,
                0,
                player.position.z - enemy.mesh.position.z
            ).normalize();

            const boltGeo = new THREE.SphereGeometry(0.6);
            const boltMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const bolt = new THREE.Mesh(boltGeo, boltMat);
            bolt.position.copy(enemy.mesh.position);
            bolt.position.y = 3;
            scene.add(bolt);

            // Trail particles
            let boltDist = 0;
            const boltInterval = setInterval(() => {
                boltDist += 2;
                bolt.position.x = enemy.mesh.position.x + dir.x * boltDist;
                bolt.position.z = enemy.mesh.position.z + dir.z * boltDist;

                // Glow trail
                const trailGeo = new THREE.SphereGeometry(0.3);
                const trailMat = new THREE.MeshBasicMaterial({ color: 0xffd700, transparent: true, opacity: 0.5 });
                const trail = new THREE.Mesh(trailGeo, trailMat);
                trail.position.copy(bolt.position);
                scene.add(trail);
                setTimeout(() => { scene.remove(trail); }, 200);

                // Hit check
                const dx = player.position.x - bolt.position.x;
                const dz = player.position.z - bolt.position.z;
                if (Math.sqrt(dx*dx + dz*dz) < 2) {
                    playerHealth -= 35;
                    timeSinceLastHit = 0;
                    updatePlayerHealth();
                    createShockwaveEffect(bolt.position.x, bolt.position.z, 0xffd700);
                    scene.remove(bolt);
                    clearInterval(boltInterval);
                }

                if (boltDist > 30) {
                    scene.remove(bolt);
                    clearInterval(boltInterval);
                }
            }, 30);
        }

        function performHolyNova(enemy) {
            enemy.currentAbility = 'holyNova';
            enemy.abilityTimer = 3.0;
            showBossMessage('HOLY NOVA!', 0xffffff);
            showBossAttackWarning('HOLY NOVA - AOE!', 2000);

            // Divine charge-up - god glows brilliantly
            const startY = enemy.mesh.position.y;
            let chargeTime = 0;

            // Temporary bright light
            const lightSphere = new THREE.SphereGeometry(2);
            const lightMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 });
            const light = new THREE.Mesh(lightSphere, lightMat);
            enemy.mesh.add(light);

            const chargeInterval = setInterval(() => {
                chargeTime += 0.03;
                enemy.mesh.position.y = startY + Math.sin(chargeTime * 8) * 0.3;

                // Intensify glow
                enemy.mesh.children.forEach(child => {
                    if (child.material && child.material.emissive && child !== light) {
                        child.material.emissive.setHex(0xffffaa);
                        child.material.emissiveIntensity = chargeTime * 2;
                    }
                });

                light.scale.set(1 + chargeTime, 1 + chargeTime, 1 + chargeTime);
                light.material.opacity = 0.3 + chargeTime * 0.3;

                // Holy particles spiraling upward
                if (Math.random() > 0.5) {
                    const pGeo = new THREE.SphereGeometry(0.1);
                    const pMat = new THREE.MeshBasicMaterial({ color: 0xffd700 });
                    const p = new THREE.Mesh(pGeo, pMat);
                    const angle = Math.random() * Math.PI * 2;
                    p.position.set(
                        enemy.mesh.position.x + Math.cos(angle) * 2,
                        0,
                        enemy.mesh.position.z + Math.sin(angle) * 2
                    );
                    scene.add(p);
                    let pTime = 0;
                    const pMove = setInterval(() => {
                        pTime += 0.05;
                        p.position.y += 0.3;
                        p.position.x += (enemy.mesh.position.x - p.position.x) * 0.05;
                        p.position.z += (enemy.mesh.position.z - p.position.z) * 0.05;
                        if (pTime > 1) { scene.remove(p); clearInterval(pMove); }
                    }, 30);
                }

                if (chargeTime >= 0.8) {
                    clearInterval(chargeInterval);
                    enemy.mesh.remove(light);
                    enemy.mesh.position.y = startY;

                    // RELEASE THE NOVA
                    screenShake(0.8, 2.0);

                    // Blinding flash
                    const flashGeo = new THREE.SphereGeometry(30);
                    const flashMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8, side: THREE.BackSide });
                    const flash = new THREE.Mesh(flashGeo, flashMat);
                    flash.position.copy(enemy.mesh.position);
                    scene.add(flash);

                    let flashTime = 0;
                    const flashFade = setInterval(() => {
                        flashTime += 0.05;
                        flash.material.opacity -= 0.08;
                        if (flash.material.opacity <= 0) {
                            scene.remove(flash);
                            clearInterval(flashFade);
                        }
                    }, 30);

                    // Expanding rings of divine light with vertical pillars
                    for (let ring = 0; ring < 5; ring++) {
                        setTimeout(() => {
                            const radius = (ring + 1) * 4;

                            // Main ring
                            const novaGeo = new THREE.TorusGeometry(radius, 0.8, 8, 48);
                            const novaMat = new THREE.MeshBasicMaterial({ color: 0xffd700, transparent: true, opacity: 0.9 });
                            const nova = new THREE.Mesh(novaGeo, novaMat);
                            nova.position.copy(enemy.mesh.position);
                            nova.position.y = 0.5;
                            nova.rotation.x = Math.PI / 2;
                            scene.add(nova);

                            // Vertical light pillars at intervals
                            for (let p = 0; p < 8; p++) {
                                const pAngle = (p / 8) * Math.PI * 2;
                                const pillarGeo = new THREE.CylinderGeometry(0.3, 0.3, 8, 8);
                                const pillarMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.7 });
                                const pillar = new THREE.Mesh(pillarGeo, pillarMat);
                                pillar.position.set(
                                    enemy.mesh.position.x + Math.cos(pAngle) * radius,
                                    4,
                                    enemy.mesh.position.z + Math.sin(pAngle) * radius
                                );
                                scene.add(pillar);

                                let pillarTime = 0;
                                const pillarFade = setInterval(() => {
                                    pillarTime += 0.05;
                                    pillar.scale.y = 1 + pillarTime;
                                    pillar.material.opacity -= 0.05;
                                    if (pillar.material.opacity <= 0) {
                                        scene.remove(pillar);
                                        clearInterval(pillarFade);
                                    }
                                }, 30);
                            }

                            // Damage check
                            const dx = player.position.x - enemy.mesh.position.x;
                            const dz = player.position.z - enemy.mesh.position.z;
                            const playerDist = Math.sqrt(dx*dx + dz*dz);
                            if (Math.abs(playerDist - radius) < 2.5) {
                                playerHealth -= 20;
                                timeSinceLastHit = 0;
                                updatePlayerHealth();
                            }

                            // Ring expands and fades
                            let ringTime = 0;
                            const ringFade = setInterval(() => {
                                ringTime += 0.03;
                                nova.scale.set(1 + ringTime * 0.3, 1 + ringTime * 0.3, 1);
                                nova.material.opacity -= 0.04;
                                if (nova.material.opacity <= 0) {
                                    scene.remove(nova);
                                    clearInterval(ringFade);
                                }
                            }, 30);
                        }, ring * 200);
                    }

                    // Reset emissive
                    setTimeout(() => {
                        enemy.mesh.children.forEach(child => {
                            if (child.material && child.material.emissive) {
                                child.material.emissiveIntensity = 0;
                            }
                        });
                    }, 1500);
                }
            }, 30);
        }

        function performJudgment(enemy) {
            enemy.currentAbility = 'judgment';
            enemy.abilityTimer = 3.5; // Extended for warning
            showBossMessage('JUDGMENT!', 0xffff00);
            showBossAttackWarning('JUDGMENT - KEEP MOVING!', 3750);

            // Multiple beams from sky
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const targetX = player.position.x + (Math.random() - 0.5) * 12;
                    const targetZ = player.position.z + (Math.random() - 0.5) * 12;

                    // Warning circle
                    const warningGeo = new THREE.RingGeometry(2, 2.5, 16);
                    const warningMat = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.6, side: THREE.DoubleSide });
                    const warning = new THREE.Mesh(warningGeo, warningMat);
                    warning.position.set(targetX, 0.1, targetZ);
                    warning.rotation.x = -Math.PI / 2;
                    scene.add(warning);

                    // Beam after delay
                    setTimeout(() => {
                        scene.remove(warning);

                        // Create beam
                        const beamGeo = new THREE.CylinderGeometry(1.5, 1.5, 30, 8);
                        const beamMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.9 });
                        const beam = new THREE.Mesh(beamGeo, beamMat);
                        beam.position.set(targetX, 15, targetZ);
                        scene.add(beam);

                        // Damage check
                        const dx = player.position.x - targetX;
                        const dz = player.position.z - targetZ;
                        if (Math.sqrt(dx*dx + dz*dz) < 3) {
                            playerHealth -= 40;
                            timeSinceLastHit = 0;
                            updatePlayerHealth();
                        }

                        setTimeout(() => { scene.remove(beam); }, 300);
                    }, 600);
                }, i * 300);
            }
        }

        function performCelestialBeam(enemy) {
            enemy.currentAbility = 'celestialBeam';
            enemy.abilityTimer = 5.0;
            showBossMessage('CELESTIAL BEAM!', 0x00ffff);
            showBossAttackWarning('CELESTIAL BEAM - DODGE!', 3000);

            // Charge-up phase - gathering cosmic energy
            let chargeTime = 0;
            enemy.mesh.children.forEach(child => {
                if (child.material && child.material.emissive) {
                    child.material.emissive.setHex(0x00ffff);
                }
            });

            // Cosmic particles spiraling in
            const chargeInterval = setInterval(() => {
                chargeTime += 0.03;
                enemy.mesh.children.forEach(child => {
                    if (child.material && child.material.emissive) {
                        child.material.emissiveIntensity = chargeTime * 1.5;
                    }
                });

                // Spiral particles
                for (let i = 0; i < 2; i++) {
                    const pGeo = new THREE.SphereGeometry(0.15);
                    const pMat = new THREE.MeshBasicMaterial({ color: Math.random() > 0.5 ? 0x00ffff : 0xffffff });
                    const p = new THREE.Mesh(pGeo, pMat);
                    const angle = chargeTime * 5 + i * Math.PI;
                    const dist = 8 * (1 - chargeTime);
                    p.position.set(
                        enemy.mesh.position.x + Math.cos(angle) * dist,
                        2 + Math.sin(chargeTime * 10) * 2,
                        enemy.mesh.position.z + Math.sin(angle) * dist
                    );
                    scene.add(p);

                    let pLife = 0;
                    const pMove = setInterval(() => {
                        pLife += 0.05;
                        p.position.x += (enemy.mesh.position.x - p.position.x) * 0.1;
                        p.position.y += (2.5 - p.position.y) * 0.1;
                        p.position.z += (enemy.mesh.position.z - p.position.z) * 0.1;
                        if (pLife > 0.8) { scene.remove(p); clearInterval(pMove); }
                    }, 30);
                }

                if (chargeTime >= 1.0) {
                    clearInterval(chargeInterval);

                    // RELEASE THE BEAM
                    screenShake(0.5, 3.0);

                    let angle = Math.atan2(
                        player.position.x - enemy.mesh.position.x,
                        player.position.z - enemy.mesh.position.z
                    ) - Math.PI / 2;

                    // Create epic multi-layered beam
                    const beamGroup = new THREE.Group();

                    // Core beam (bright white)
                    const coreGeo = new THREE.BoxGeometry(25, 0.5, 0.3);
                    const coreMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                    const core = new THREE.Mesh(coreGeo, coreMat);
                    beamGroup.add(core);

                    // Inner glow (cyan)
                    const innerGeo = new THREE.BoxGeometry(25, 1.5, 0.8);
                    const innerMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.7 });
                    const inner = new THREE.Mesh(innerGeo, innerMat);
                    beamGroup.add(inner);

                    // Outer glow (blue)
                    const outerGeo = new THREE.BoxGeometry(25, 2.5, 1.5);
                    const outerMat = new THREE.MeshBasicMaterial({ color: 0x0066ff, transparent: true, opacity: 0.4 });
                    const outer = new THREE.Mesh(outerGeo, outerMat);
                    beamGroup.add(outer);

                    beamGroup.position.copy(enemy.mesh.position);
                    beamGroup.position.y = 2;
                    scene.add(beamGroup);

                    let sweepTime = 0;
                    const sweepInterval = setInterval(() => {
                        sweepTime += 0.025;
                        angle += 0.04;
                        beamGroup.rotation.y = angle;
                        beamGroup.position.x = enemy.mesh.position.x + Math.sin(angle) * 12.5;
                        beamGroup.position.z = enemy.mesh.position.z + Math.cos(angle) * 12.5;

                        // Pulse effect
                        const pulse = 1 + Math.sin(sweepTime * 20) * 0.2;
                        beamGroup.scale.set(1, pulse, pulse);

                        // Beam particles along length
                        if (Math.random() > 0.3) {
                            const beamDir = new THREE.Vector3(Math.sin(angle), 0, Math.cos(angle));
                            const d = Math.random() * 25;
                            const sparkGeo = new THREE.SphereGeometry(0.1 + Math.random() * 0.1);
                            const sparkMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                            const spark = new THREE.Mesh(sparkGeo, sparkMat);
                            spark.position.set(
                                enemy.mesh.position.x + beamDir.x * d,
                                2 + (Math.random() - 0.5),
                                enemy.mesh.position.z + beamDir.z * d
                            );
                            scene.add(spark);
                            setTimeout(() => scene.remove(spark), 100);
                        }

                        // Ground scorching effect
                        if (sweepTime % 0.1 < 0.03) {
                            const beamDir = new THREE.Vector3(Math.sin(angle), 0, Math.cos(angle));
                            for (let d = 5; d < 20; d += 5) {
                                const scorchGeo = new THREE.CircleGeometry(0.5 + Math.random() * 0.5, 8);
                                const scorchMat = new THREE.MeshBasicMaterial({
                                    color: 0x003333, transparent: true, opacity: 0.5, side: THREE.DoubleSide
                                });
                                const scorch = new THREE.Mesh(scorchGeo, scorchMat);
                                scorch.position.set(
                                    enemy.mesh.position.x + beamDir.x * d,
                                    0.02,
                                    enemy.mesh.position.z + beamDir.z * d
                                );
                                scorch.rotation.x = -Math.PI / 2;
                                scene.add(scorch);
                                setTimeout(() => scene.remove(scorch), 3000);
                            }
                        }

                        // Damage check along beam
                        const beamDir = new THREE.Vector3(Math.sin(angle), 0, Math.cos(angle));
                        for (let d = 0; d < 25; d += 1.5) {
                            const checkX = enemy.mesh.position.x + beamDir.x * d;
                            const checkZ = enemy.mesh.position.z + beamDir.z * d;
                            const dx = player.position.x - checkX;
                            const dz = player.position.z - checkZ;
                            if (Math.sqrt(dx*dx + dz*dz) < 2.5) {
                                playerHealth -= 8;
                                timeSinceLastHit = 0;
                                updatePlayerHealth();
                                // Hit spark
                                createEpicExplosion(player.position.x, 1, player.position.z, 0x00ffff, 1, 10);
                                break;
                            }
                        }

                        if (sweepTime >= 3.0) {
                            // Beam fades out
                            let fadeTime = 0;
                            const fadeInterval = setInterval(() => {
                                fadeTime += 0.05;
                                beamGroup.children.forEach(c => {
                                    if (c.material) c.material.opacity -= 0.1;
                                });
                                if (fadeTime > 0.5) {
                                    scene.remove(beamGroup);
                                    clearInterval(fadeInterval);
                                }
                            }, 30);
                            clearInterval(sweepInterval);

                            // Reset emissive
                            enemy.mesh.children.forEach(child => {
                                if (child.material && child.material.emissive) {
                                    child.material.emissiveIntensity = 0;
                                }
                            });
                        }
                    }, 25);
                }
            }, 30);
        }

        function performAscend(enemy) {
            enemy.currentAbility = 'ascend';
            enemy.abilityTimer = 8.0;
            showBossMessage('ASCENSION!', 0xffffff);
            showBossAttackWarning('ASCENSION - ULTIMATE ATTACK!', 5000);

            const startPos = enemy.mesh.position.clone();
            enemy.invulnerable = true;
            screenShake(0.3, 6.0);

            // Divine chorus - the god speaks
            createBossRoarEffect(enemy, 0xffd700);

            // Massive holy aura
            const auraGeo = new THREE.SphereGeometry(5);
            const auraMat = new THREE.MeshBasicMaterial({
                color: 0xffffff, transparent: true, opacity: 0.4, side: THREE.BackSide
            });
            const aura = new THREE.Mesh(auraGeo, auraMat);
            enemy.mesh.add(aura);

            // Wings of light
            const wingGroup = new THREE.Group();
            for (let side = -1; side <= 1; side += 2) {
                for (let feather = 0; feather < 6; feather++) {
                    const fGeo = new THREE.BoxGeometry(0.3, 0.1, 3 - feather * 0.3);
                    const fMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
                    const f = new THREE.Mesh(fGeo, fMat);
                    f.position.set(side * (2 + feather * 0.5), 0.5 - feather * 0.1, -1);
                    f.rotation.z = side * (0.3 + feather * 0.1);
                    wingGroup.add(f);
                }
            }
            enemy.mesh.add(wingGroup);

            // EPIC ASCENSION
            let phase = 'rise';
            let riseTime = 0;
            const riseInterval = setInterval(() => {
                riseTime += 0.015;

                if (phase === 'rise') {
                    // Majestic ascent
                    enemy.mesh.position.y = startPos.y + riseTime * 25;

                    // Glow intensifies
                    enemy.mesh.children.forEach(child => {
                        if (child.material && child.material.emissive && child !== aura) {
                            child.material.emissive.setHex(0xffffff);
                            child.material.emissiveIntensity = 0.5 + riseTime;
                        }
                    });

                    // Aura grows
                    aura.scale.set(1 + riseTime * 2, 1 + riseTime * 2, 1 + riseTime * 2);
                    auraMat.opacity = 0.4 + riseTime * 0.3;

                    // Wing animation
                    wingGroup.rotation.z = Math.sin(riseTime * 15) * 0.2;
                    wingGroup.children.forEach((f, i) => {
                        f.position.y = 0.5 + Math.sin(riseTime * 10 + i * 0.3) * 0.2;
                    });

                    // Divine particles trailing
                    for (let i = 0; i < 3; i++) {
                        const pGeo = new THREE.SphereGeometry(0.15 + Math.random() * 0.1);
                        const pMat = new THREE.MeshBasicMaterial({
                            color: Math.random() > 0.5 ? 0xffffff : 0xffd700
                        });
                        const p = new THREE.Mesh(pGeo, pMat);
                        p.position.copy(enemy.mesh.position);
                        p.position.x += (Math.random() - 0.5) * 3;
                        p.position.y -= 1;
                        p.position.z += (Math.random() - 0.5) * 3;
                        scene.add(p);

                        let pLife = 0;
                        const pFall = setInterval(() => {
                            pLife += 0.03;
                            p.position.y -= 0.2;
                            p.material.opacity = 1 - pLife;
                            p.material.transparent = true;
                            if (pLife > 1) { scene.remove(p); clearInterval(pFall); }
                        }, 30);
                    }

                    if (riseTime >= 0.6) {
                        phase = 'hover';
                        riseTime = 0;
                        showBossMessage('DIVINE JUDGMENT!!!', 0xffd700);
                    }
                } else if (phase === 'hover') {
                    // Hovering at apex, raining destruction
                    enemy.mesh.position.y = startPos.y + 15 + Math.sin(riseTime * 10) * 0.5;

                    // Rain holy bolts with lightning
                    if (Math.random() > 0.5) {
                        const boltX = player.position.x + (Math.random() - 0.5) * 20;
                        const boltZ = player.position.z + (Math.random() - 0.5) * 20;

                        // Warning circle
                        const warnGeo = new THREE.CircleGeometry(2, 16);
                        const warnMat = new THREE.MeshBasicMaterial({
                            color: 0xffd700, transparent: true, opacity: 0.5, side: THREE.DoubleSide
                        });
                        const warn = new THREE.Mesh(warnGeo, warnMat);
                        warn.position.set(boltX, 0.1, boltZ);
                        warn.rotation.x = -Math.PI / 2;
                        scene.add(warn);

                        setTimeout(() => {
                            scene.remove(warn);

                            // LIGHTNING BOLT from god to target
                            createLightningBolt(
                                enemy.mesh.position.x, enemy.mesh.position.y - 1, enemy.mesh.position.z,
                                boltX, 0.5, boltZ, 0xffd700
                            );

                            // Impact explosion
                            createEpicExplosion(boltX, 0.5, boltZ, 0xffd700, 2, 15);
                            createSlamEffect(boltX, boltZ, 2.5, 0xffd700);

                            const dx = player.position.x - boltX;
                            const dz = player.position.z - boltZ;
                            if (Math.sqrt(dx*dx + dz*dz) < 3) {
                                playerHealth -= 20;
                                timeSinceLastHit = 0;
                                updatePlayerHealth();
                            }
                        }, 400);
                    }

                    if (riseTime >= 2.0) {
                        phase = 'descent';
                        riseTime = 0;
                        showBossMessage('KNEEL!!!', 0xffffff);
                    }
                } else if (phase === 'descent') {
                    // Dramatic descent with final attack
                    enemy.mesh.position.y = startPos.y + 15 * (1 - riseTime * 1.5);

                    if (enemy.mesh.position.y <= startPos.y) {
                        clearInterval(riseInterval);
                        enemy.mesh.position.y = startPos.y;
                        enemy.invulnerable = false;
                        enemy.mesh.remove(aura);
                        enemy.mesh.remove(wingGroup);

                        // MASSIVE LANDING SHOCKWAVE
                        createEpicExplosion(enemy.mesh.position.x, 1, enemy.mesh.position.z, 0xffffff, 5, 50);
                        createSlamEffect(enemy.mesh.position.x, enemy.mesh.position.z, 10, 0xffd700);
                        screenShake(1.5, 0.8);

                        // Multiple expanding holy rings
                        for (let r = 0; r < 6; r++) {
                            setTimeout(() => {
                                createShockwaveEffect(enemy.mesh.position.x, enemy.mesh.position.z,
                                    r % 2 === 0 ? 0xffffff : 0xffd700);
                            }, r * 100);
                        }

                        // Final judgment damage in area
                        const dx = player.position.x - enemy.mesh.position.x;
                        const dz = player.position.z - enemy.mesh.position.z;
                        if (Math.sqrt(dx*dx + dz*dz) < 10) {
                            playerHealth -= 40;
                            timeSinceLastHit = 0;
                            updatePlayerHealth();
                        }

                        enemy.mesh.children.forEach(child => {
                            if (child.material && child.material.emissive) {
                                child.material.emissive.setHex(0x000000);
                            }
                        });
                    }
                }

                riseTime += 0.015;
            }, 30);
        }

        // Function to spawn a wave
        function spawnWave(waveNum) {
            const wave = waves[waveNum - 1];
            wave.enemies.forEach(e => {
                const rotation = Math.atan2(-e.x, -e.z); // Face toward center
                // Use themed enemy type based on current map
                const themedType = getThemedEnemyType(e.type);
                const enemy = createEnemy(e.x, e.z, rotation, themedType);
                enemies.push(enemy);
                // Show boss health bar for boss enemies
                if (enemy.config && enemy.config.isBoss) {
                    showBossHealthBar(enemy);
                }
            });
            waveNumberEl.textContent = waveNum;
            updateEnemyCount();

            // Spawn some animals each wave (if not too many already)
            if (animals.length < 6) {
                const animalCount = Math.floor(Math.random() * 2) + 1; // 1-2 animals
                spawnAnimals(animalCount);
            }
        }

        // Function to update enemy count display
        function updateEnemyCount() {
            enemyCountEl.textContent = enemies.length;
        }

        // Start first wave
        function startNextWave() {
            currentWave++;
            if (currentWave <= totalWaves) {
                waveStartDelay = true;
                announceWave(currentWave);
                setTimeout(() => {
                    spawnWave(currentWave);
                    waveInProgress = true;
                    waveStartDelay = false;
                }, 2000);
            } else {
                // Game complete!
                announceWave(currentWave);
            }
        }

        // Game starts from home screen - don't auto-start waves

        // Attack range and hit detection
        const baseAttackRange = 5.0; // Base range
        const attackAngle = Math.PI / 3; // 60 degree cone in front

        // Attack cooldown
        let canAttack = true;
        const baseAttackCooldown = 0.25; // 250ms cooldown between attacks

        // Damage variance helper - adds Â±3 to any damage value
        function applyDamageVariance(damage) {
            const variance = Math.floor(Math.random() * 7) - 3; // -3 to +3
            return Math.max(1, damage + variance); // Minimum 1 damage
        }

        // Function to check and deal damage to enemies in range
        function attackEnemies() {
            let baseDamage = Math.floor(Math.random() * 6) + 5; // 5-10 base damage

            // Apply damage multiplier
            baseDamage *= playerStats.damage;

            // Shadow step bonus
            if (shadowStepBonus > 0) {
                baseDamage *= (1 + shadowStepBonus);
                shadowStepBonus = 0;
            }

            // Parry damage boost (after successful parry)
            if (parryDamageBoostActive && playerStats.parryDamageBoost) {
                baseDamage *= (1 + playerStats.parryDamageBoost);
            }

            // Berserker bonus (below 50% health)
            if (playerStats.berserkBonus && playerHealth < playerStats.maxHealth * 0.5) {
                baseDamage *= (1 + playerStats.berserkBonus);
            }

            // Combo system
            const now = performance.now();
            if (now - lastHitTime < 1500) {
                comboCount++;
            } else {
                comboCount = 1;
            }
            lastHitTime = now;

            // Combo bonus damage
            if (playerStats.comboBonus && comboCount > 1) {
                baseDamage *= (1 + playerStats.comboBonus * (comboCount - 1));
            }

            // Critical hit check
            let isCrit = Math.random() < playerStats.critChance;
            if (isCrit) {
                baseDamage *= playerStats.critDamage;
                // Crit heal
                if (playerStats.critHeal) {
                    playerHealth = Math.min(playerStats.maxHealth, playerHealth + playerStats.critHeal);
                    updatePlayerHealth();
                }
            }

            const effectiveRange = baseAttackRange * playerStats.attackRange;
            let targetsHit = 0;
            const maxTargets = 1 + (playerStats.cleaveTargets || 0);
            const hitEnemies = new Set();

            for (let i = enemies.length - 1; i >= 0 && targetsHit < maxTargets; i--) {
                const enemy = enemies[i];
                if (hitEnemies.has(enemy)) continue;

                // Calculate distance to enemy
                const dx = enemy.mesh.position.x - player.position.x;
                const dz = enemy.mesh.position.z - player.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);

                // Check if in range
                if (distance <= effectiveRange) {
                    // Check if enemy is in front of player (within attack cone)
                    const angleToEnemy = Math.atan2(-dx, -dz);
                    let angleDiff = angleToEnemy - cameraRotationY;

                    // Normalize angle difference
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                    if (Math.abs(angleDiff) <= attackAngle / 2) {
                        let finalDamage = baseDamage;

                        // First strike bonus
                        if (playerStats.firstStrikeBonus && !enemy.hasBeenHit) {
                            finalDamage *= (1 + playerStats.firstStrikeBonus);
                            enemy.hasBeenHit = true;
                        }

                        // Execute bonus (enemy below 30% HP)
                        if (playerStats.executeBonus && enemy.health < enemy.maxHealth * 0.3) {
                            finalDamage *= (1 + playerStats.executeBonus);
                        }

                        // Hunter bonus (far enemies)
                        if (playerStats.hunterBonus && distance > 3) {
                            finalDamage *= (1 + playerStats.hunterBonus);
                        }

                        // Predator bonus (isolated enemies)
                        if (playerStats.predatorBonus) {
                            let nearbyEnemies = 0;
                            for (const other of enemies) {
                                if (other !== enemy) {
                                    const odx = other.mesh.position.x - enemy.mesh.position.x;
                                    const odz = other.mesh.position.z - enemy.mesh.position.z;
                                    if (Math.sqrt(odx*odx + odz*odz) < 5) nearbyEnemies++;
                                }
                            }
                            if (nearbyEnemies === 0) {
                                finalDamage *= (1 + playerStats.predatorBonus);
                            }
                        }

                        // Backstab bonus (Assassin) - attacking from behind
                        if (playerStats.backstabBonus) {
                            // Get enemy's facing direction (they face the player)
                            const enemyFacingX = player.position.x - enemy.mesh.position.x;
                            const enemyFacingZ = player.position.z - enemy.mesh.position.z;
                            // Get player's attack direction
                            const attackDirX = -Math.sin(cameraRotationY);
                            const attackDirZ = -Math.cos(cameraRotationY);
                            // Dot product - if positive, attacking from behind
                            const dot = enemyFacingX * attackDirX + enemyFacingZ * attackDirZ;
                            if (dot > 0) {
                                // Behind the enemy!
                                finalDamage *= (1 + playerStats.backstabBonus);
                                showAbilityEffect('BACKSTAB!');
                            }
                        }

                        // Boss damage bonus
                        if (playerStats.bossDamage && enemy.isBoss) {
                            finalDamage *= (1 + playerStats.bossDamage);
                        }

                        // Calculate damage after armor reduction, then apply Â±3 variance
                        const damage = applyDamageVariance(Math.max(1, Math.floor(finalDamage) - enemy.armor));
                        enemy.health -= damage;
                        trackQuestDamage(damage);
                        hitEnemies.add(enemy);
                        targetsHit++;

                        // Wizard gains energy from melee hits
                        if (currentRunCharacter === 'wizard') {
                            const baseEnergy = characters.wizard.energyPerMelee || 15;
                            const bonusEnergy = playerStats.skillBonuses?.energyPerMelee?.add || 0;
                            gainWizardEnergy(baseEnergy + bonusEnergy);
                        }
                        // Necromancer gains mana from melee hits
                        if (currentRunCharacter === 'necromancer') {
                            const baseMana = characters.necromancer.energyPerMelee || 12;
                            const bonusMana = playerStats.skillBonuses?.energyPerMelee?.add || 0;
                            gainNecroMana(baseMana + bonusMana);
                        }

                        // Lifesteal
                        if (playerStats.lifesteal > 0) {
                            const healAmount = damage * playerStats.lifesteal;
                            playerHealth = Math.min(playerStats.maxHealth, playerHealth + healAmount);
                            updatePlayerHealth();
                        }

                        // Flash enemy red when hit (yellow for crit)
                        const flashColor = isCrit ? 0xffff00 : 0xff0000;
                        enemy.mesh.children.forEach(child => {
                            if (child.material && child.material.emissive) {
                                child.material.emissive.setHex(flashColor);
                                setTimeout(() => {
                                    child.material.emissive.setHex(0x000000);
                                }, 100);
                            }
                        });

                        // Check if enemy is dead
                        if (enemy.health <= 0) {
                            createGibs(enemy);
                            scene.remove(enemy.mesh);
                            enemies.splice(i, 1);
                            onEnemyKilled(enemy);
                            updateEnemyCount();
                        }
                    }
                }
            }

            // Also check for harvestable obstacles
            harvestObstacles();

            // Also check for huntable animals
            attackAnimals();
        }

        // Harvest resources from obstacles
        function harvestObstacles() {
            const effectiveRange = baseAttackRange * playerStats.attackRange;
            const now = performance.now();

            for (const obstacle of obstacles) {
                // Check harvest cooldown (2 second per obstacle)
                if (obstacle.lastHarvest && now - obstacle.lastHarvest < 2000) continue;

                // Calculate distance to obstacle
                const dx = obstacle.x - player.position.x;
                const dz = obstacle.z - player.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);

                // Check if in range
                if (distance <= effectiveRange + obstacle.radius) {
                    // Check if obstacle is in front of player (within attack cone)
                    const angleToObstacle = Math.atan2(-dx, -dz);
                    let angleDiff = angleToObstacle - cameraRotationY;

                    // Normalize angle difference
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                    if (Math.abs(angleDiff) <= attackAngle / 2) {
                        // Mark as harvested (cooldown)
                        obstacle.lastHarvest = now;

                        // Determine resource type based on obstacle type
                        let resourceType = null;
                        let amount = 1;

                        switch(obstacle.type) {
                            case 'tree':
                                resourceType = 'wood';
                                amount = 2;
                                break;
                            case 'giantTree':
                                resourceType = 'wood';
                                amount = 5;
                                break;
                            case 'log':
                                resourceType = 'wood';
                                amount = 1;
                                break;
                            case 'boulder':
                                resourceType = 'ore';
                                amount = 3;
                                break;
                            case 'rock':
                                resourceType = 'rock';
                                amount = 2;
                                break;
                            case 'platform':
                                resourceType = 'rock';
                                amount = 1;
                                break;
                        }

                        if (resourceType) {
                            addResource(resourceType, amount);

                            // Visual feedback - shake the obstacle
                            if (obstacle.mesh) {
                                const originalX = obstacle.mesh.position.x;
                                const originalZ = obstacle.mesh.position.z;
                                const shakeIntensity = 0.1;
                                let shakeTime = 0;
                                const shakeInterval = setInterval(() => {
                                    shakeTime += 50;
                                    if (shakeTime >= 200) {
                                        obstacle.mesh.position.x = originalX;
                                        obstacle.mesh.position.z = originalZ;
                                        clearInterval(shakeInterval);
                                    } else {
                                        obstacle.mesh.position.x = originalX + (Math.random() - 0.5) * shakeIntensity;
                                        obstacle.mesh.position.z = originalZ + (Math.random() - 0.5) * shakeIntensity;
                                    }
                                }, 50);
                            }
                        }
                    }
                }
            }
        }

        // Attack animals for food
        function attackAnimals() {
            const effectiveRange = baseAttackRange * playerStats.attackRange;
            let baseDamage = Math.floor(Math.random() * 6) + 5;
            baseDamage *= playerStats.damage;

            for (let i = animals.length - 1; i >= 0; i--) {
                const animal = animals[i];

                // Calculate distance to animal
                const dx = animal.mesh.position.x - player.position.x;
                const dz = animal.mesh.position.z - player.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);

                // Check if in range
                if (distance <= effectiveRange + 1) {
                    // Check if animal is in front of player (within attack cone)
                    const angleToAnimal = Math.atan2(-dx, -dz);
                    let angleDiff = angleToAnimal - cameraRotationY;

                    // Normalize angle difference
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                    if (Math.abs(angleDiff) <= attackAngle / 2) {
                        // Hit the animal
                        animal.health -= baseDamage;

                        // Flash red
                        animal.mesh.children.forEach(child => {
                            if (child.material && child.material.emissive) {
                                child.material.emissive.setHex(0xff0000);
                                setTimeout(() => {
                                    child.material.emissive.setHex(0x000000);
                                }, 100);
                            }
                        });

                        // Check if dead
                        if (animal.health <= 0) {
                            addResource('food', animal.foodAmount);
                            scene.remove(animal.mesh);
                            animals.splice(i, 1);
                        }
                    }
                }
            }
        }

        // Enemy AI - move toward player and attack
        let parryDamageBoostActive = false;
        let adrenalineActive = false;

        function updateEnemyAI(deltaTime) {
            if (playerHealth <= 0 || gameState !== 'playing') return;

            // Apply time slow to deltaTime for enemies
            const enemyDelta = deltaTime * timeSlowMultiplier;

            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];

                // Handle stun
                if (enemy.stunned) {
                    enemy.stunDuration -= deltaTime;
                    if (enemy.stunDuration <= 0) {
                        enemy.stunned = false;
                    }
                    continue;
                }

                // Handle freeze (Permafrost Shard relic)
                if (enemy.isFrozen) {
                    enemy.frozenTimer -= deltaTime;
                    if (enemy.frozenTimer <= 0) {
                        enemy.isFrozen = false;
                        // Reset color
                        enemy.mesh.children.forEach(child => {
                            if (child.material && child.userData && child.userData.originalColor) {
                                child.material.color.setHex(child.userData.originalColor);
                            }
                        });
                    }
                    continue; // Can't move while frozen
                }

                // Handle poison (Plague Amulet relic)
                if (enemy.isPoisoned) {
                    enemy.poisonTimer -= deltaTime;
                    enemy.poisonTickTimer = (enemy.poisonTickTimer || 0) - deltaTime;
                    if (enemy.poisonTickTimer <= 0) {
                        enemy.health -= enemy.poisonDamage;
                        createDamageNumber(enemy.mesh.position.x, enemy.mesh.position.y + 2, enemy.mesh.position.z, enemy.poisonDamage, false);
                        enemy.poisonTickTimer = 0.5;
                        // Green flash
                        enemy.mesh.children.forEach(child => {
                            if (child.material && child.material.emissive) {
                                child.material.emissive.setHex(0x00ff00);
                                setTimeout(() => { child.material.emissive.setHex(0x000000); }, 100);
                            }
                        });
                    }
                    if (enemy.poisonTimer <= 0) {
                        enemy.isPoisoned = false;
                    }
                    // Check if poison killed enemy
                    if (enemy.health <= 0) {
                        createGibs(enemy);
                        scene.remove(enemy.mesh);
                        enemies.splice(i, 1);
                        onEnemyKilled(enemy);
                        updateEnemyCount();
                        continue;
                    }
                }

                // Handle ignite (Demon Horn relic)
                if (enemy.isIgnited) {
                    enemy.igniteTimer -= deltaTime;
                    enemy.igniteTickTimer = (enemy.igniteTickTimer || 0) - deltaTime;
                    if (enemy.igniteTickTimer <= 0) {
                        enemy.health -= enemy.igniteDamage;
                        createDamageNumber(enemy.mesh.position.x, enemy.mesh.position.y + 2, enemy.mesh.position.z, enemy.igniteDamage, false);
                        enemy.igniteTickTimer = 0.5;
                        createFireEffect(enemy.mesh.position.x, 1, enemy.mesh.position.z);
                    }
                    if (enemy.igniteTimer <= 0) {
                        enemy.isIgnited = false;
                    }
                    // Check if fire killed enemy
                    if (enemy.health <= 0) {
                        createGibs(enemy);
                        scene.remove(enemy.mesh);
                        enemies.splice(i, 1);
                        onEnemyKilled(enemy);
                        updateEnemyCount();
                        continue;
                    }
                }

                // Calculate direction to player (or nearest decoy)
                let targetX = player.position.x;
                let targetZ = player.position.z;

                // Void Cloak invisibility - enemies wander randomly
                if (isInvisible) {
                    targetX = enemy.mesh.position.x + (Math.random() - 0.5) * 10;
                    targetZ = enemy.mesh.position.z + (Math.random() - 0.5) * 10;
                }

                // Check if there are decoys to distract
                if (decoys.length > 0 && Math.random() < 0.5) {
                    const randomDecoy = decoys[Math.floor(Math.random() * decoys.length)];
                    targetX = randomDecoy.position.x;
                    targetZ = randomDecoy.position.z;
                }

                const dx = targetX - enemy.mesh.position.x;
                const dz = targetZ - enemy.mesh.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);

                // Face the target
                enemy.mesh.rotation.y = Math.atan2(dx, dz);

                // Update attack cooldown
                if (enemy.attackCooldown > 0) {
                    enemy.attackCooldown -= enemyDelta;
                }

                // Boss special abilities (new system with crazy moves)
                if (enemy.isBoss && enemy.abilities && enemy.abilities.length > 0) {
                    const bossActing = updateBossAbilities(enemy, enemyDelta, distance);
                    if (bossActing) {
                        // Boss is performing an ability, skip normal AI
                        continue;
                    }
                }

                // Ranged attack logic
                if (enemy.ranged && distance <= enemy.range && distance > 3) {
                    if (enemy.attackCooldown <= 0) {
                        // Fire projectile
                        createEnemyProjectile(enemy, targetX, targetZ);
                        enemy.attackCooldown = 1 / enemy.attackSpeed;

                        // Attack animation
                        if (enemy.mesh.userData.rightArmPivot) {
                            enemy.attackAnim = 0.5;
                        }
                    }
                } else if (distance <= enemy.range && !enemy.ranged) {
                    // Melee attack
                    if (enemy.attackCooldown <= 0) {
                        // Start attack animation
                        enemy.attackAnim = 0.5;

                        // Knight shield block chance
                        if (enemy.special === 'shield' && isSwinging && Math.random() < 0.3) {
                            showAbilityEffect('Blocked!');
                        } else {
                            // Attack the player!
                            let damage = enemy.damage;

                            // Boss damage bonus
                            if (enemy.isBoss && playerStats.bossHunter) {
                                // Player deals more to bosses, not takes more
                            }

                            // Iron Fortress blocks all damage
                            if (ironFortressActive) {
                                damage = 0;
                            } else {
                                // Dodge chance
                                if (playerStats.dodgeChance && Math.random() < playerStats.dodgeChance) {
                                    damage = 0;
                                    showAbilityEffect('Dodged!');
                                } else {
                                    // Parrying reduces damage
                                    if (isParrying) {
                                        damage = Math.floor(damage * (1 - playerStats.parryDamageReduction));
                                        if (playerStats.parryDamageBoost) {
                                            parryDamageBoostActive = true;
                                            setTimeout(() => { parryDamageBoostActive = false; }, 2000);
                                        }
                                        // Counter strike
                                        if (playerStats.counterDamage) {
                                            enemy.health -= playerStats.counterDamage;
                                            if (enemy.health <= 0) {
                                                createGibs(enemy);
                                                scene.remove(enemy.mesh);
                                                enemies.splice(i, 1);
                                                onEnemyKilled();
                                                updateEnemyCount();
                                                continue;
                                            }
                                        }
                                    }

                                    // Last Stand damage reduction
                                    if (playerStats.lastStandReduction && playerHealth < playerStats.maxHealth * 0.25) {
                                        damage = Math.floor(damage * (1 - playerStats.lastStandReduction));
                                    }

                                    // Armor reduction
                                    const totalArmor = playerStats.armor + (playerStats.ironWillArmor || 0);
                                    damage = Math.max(0, damage - totalArmor);
                                }
                            }

                            // Knight block chance
                            if (playerStats.blockChance && Math.random() < playerStats.blockChance) {
                                showAbilityEffect('BLOCKED!');
                                damage = 0;
                            }

                            // Samurai deflect chance (skill)
                            if (playerStats.skillBonuses?.deflectChance && Math.random() < playerStats.skillBonuses.deflectChance.add) {
                                showAbilityEffect('âš”ï¸ DEFLECTED!');
                                damage = 0;
                            }

                            // Guardian's Aegis - 15% block chance
                            if (hasRelic('guardian') && Math.random() < 0.15) {
                                showAbilityEffect('ðŸ›¡ï¸ AEGIS!');
                                damage = 0;
                            }

                            // Stone Heart - 20% damage reduction
                            if (hasRelic('earth') && damage > 0) {
                                damage = Math.floor(damage * 0.8);
                            }

                            // Dodge invincibility
                            if (isInvincible) {
                                damage = 0;
                            }

                            if (damage > 0) {
                                playerHealth -= damage;
                                trackQuestDamageTaken(damage);
                                timeSinceLastHit = 0;
                                updatePlayerHealth();

                                // Temporal Gem - slow enemies on hit
                                if (hasRelic('temporal') && temporalSlowCooldown <= 0) {
                                    temporalSlowCooldown = 10;
                                    enemies.forEach(e => {
                                        e.temporalSlowed = true;
                                        e.temporalSlowTimer = 2;
                                    });
                                    showAbilityEffect('â° TIME SLOW!');
                                }

                                // Fury Emblem - attack speed boost on hit
                                if (hasRelic('fury')) {
                                    furyAttackSpeedTimer = 4;
                                }

                                // Thorns damage
                                if (playerStats.thornsDamage) {
                                    const thorns = Math.floor(enemy.damage * playerStats.thornsDamage);
                                    enemy.health -= thorns;
                                    if (enemy.health <= 0) {
                                        createGibs(enemy);
                                        scene.remove(enemy.mesh);
                                        enemies.splice(i, 1);
                                        onEnemyKilled();
                                        updateEnemyCount();
                                        continue;
                                    }
                                }

                                // Adrenaline effect
                                if (playerStats.adrenalineBonus) {
                                    adrenalineActive = true;
                                    setTimeout(() => { adrenalineActive = false; }, 2000);
                                }
                            }
                        }

                        enemy.attackCooldown = 1 / enemy.attackSpeed;
                    }
                } else {
                    // Move toward target (unless ranged and in good range)
                    const minRange = enemy.ranged ? 8 : 0;
                    if (distance > minRange) {
                        // Calculate speed (water enemies move faster in water, others slower)
                        let enemySpeedMult = 1.0;
                        const inWater = isInWater(enemy.mesh.position.x, enemy.mesh.position.z);
                        if (inWater) {
                            if (enemy.isWaterEnemy) {
                                enemySpeedMult = 1.5; // Water enemies are FASTER in water
                            } else {
                                enemySpeedMult = lake.speedReduction; // Others are slower
                            }
                        }
                        // Temporal Gem slow effect
                        if (enemy.temporalSlowed) {
                            enemySpeedMult *= 0.5;
                        }

                        const moveX = (dx / distance) * enemy.moveSpeed * enemySpeedMult * enemyDelta;
                        const moveZ = (dz / distance) * enemy.moveSpeed * enemySpeedMult * enemyDelta;

                        const newX = enemy.mesh.position.x + moveX;
                        const newZ = enemy.mesh.position.z + moveZ;

                        // Check if blocked by tree
                        if (!collidesWithObstacle(newX, newZ, enemy.currentHeight || 0)) {
                            enemy.mesh.position.x = newX;
                            enemy.mesh.position.z = newZ;
                        }

                        // Handle obstacle height - enemies follow player onto obstacles
                        const currentObs = getObstacleAt(enemy.mesh.position.x, enemy.mesh.position.z);
                        const targetHeight = currentObs ? currentObs.height : 0;
                        const currentHeight = enemy.currentHeight || 0;

                        // If height difference (jumping up or down)
                        if (Math.abs(targetHeight - currentHeight) > 0.1) {
                            // 30% chance to fall off when jumping
                            if (Math.random() < 0.3) {
                                // Fall! Push enemy away from obstacle
                                const fallDir = Math.random() * Math.PI * 2;
                                enemy.mesh.position.x += Math.cos(fallDir) * 2;
                                enemy.mesh.position.z += Math.sin(fallDir) * 2;
                                enemy.currentHeight = 0;
                                enemy.mesh.position.y = 0;
                                // Stun briefly from fall
                                enemy.stunned = true;
                                enemy.stunDuration = 0.5;
                            } else {
                                // Successfully jump
                                enemy.currentHeight = targetHeight;
                            }
                        } else {
                            enemy.currentHeight = targetHeight;
                        }

                        // Set enemy Y position based on current height
                        enemy.mesh.position.y = enemy.currentHeight || 0;

                        // Walking animation
                        enemy.walkCycle += enemyDelta * enemy.moveSpeed * 2;
                        if (enemy.mesh.userData.leftLegPivot && enemy.mesh.userData.rightLegPivot) {
                            const swing = Math.sin(enemy.walkCycle) * 0.4;
                            enemy.mesh.userData.leftLegPivot.rotation.x = swing;
                            enemy.mesh.userData.rightLegPivot.rotation.x = -swing;
                        }
                        if (enemy.mesh.userData.leftArmPivot && enemy.mesh.userData.rightArmPivot && enemy.attackAnim <= 0) {
                            const armSwing = Math.sin(enemy.walkCycle) * 0.3;
                            enemy.mesh.userData.leftArmPivot.rotation.x = -armSwing;
                            enemy.mesh.userData.rightArmPivot.rotation.x = armSwing;
                        }
                    }
                }

                // Attack animation
                if (enemy.attackAnim > 0) {
                    enemy.attackAnim -= enemyDelta * 2;
                    if (enemy.mesh.userData.rightArmPivot) {
                        const attackPhase = 1 - enemy.attackAnim * 2;
                        enemy.mesh.userData.rightArmPivot.rotation.x = -Math.PI / 2 * Math.sin(attackPhase * Math.PI);
                    }
                }
            }

            // Update projectiles (enemy)
            updateProjectiles(deltaTime);

            // Update player projectiles (shurikens)
            updatePlayerProjectiles(deltaTime);

            // Regenerate shurikens (Shuriken Master)
            regenShurikens(deltaTime);

            // Regenerate arrows (Archer)
            regenArrows(deltaTime);

            // Update necromancer minions
            updateNecroMinions(deltaTime);

            // Update visual effects
            updateVisualEffects(deltaTime);

            // Update gibs
            updateGibs(deltaTime);

            // Update animals
            updateAnimals(deltaTime);

            // Animate spawn beam
            if (spawnBeam && spawnBeamGlow) {
                spawnBeam.material.opacity = 0.2 + Math.sin(Date.now() * 0.003) * 0.1;
                spawnBeamGlow.material.opacity = 0.4 + Math.sin(Date.now() * 0.005) * 0.2;
                if (spawnBeam.baseRing) {
                    spawnBeam.baseRing.rotation.z += deltaTime * 0.5;
                }
            }

            // Update spirit ally
            if (spiritMesh) {
                // Find nearest enemy
                let nearestDist = Infinity;
                let nearestIdx = -1;
                for (let i = 0; i < enemies.length; i++) {
                    const enemy = enemies[i];
                    const dx = enemy.mesh.position.x - spiritMesh.position.x;
                    const dz = enemy.mesh.position.z - spiritMesh.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestIdx = i;
                    }
                }

                if (nearestIdx >= 0) {
                    const enemy = enemies[nearestIdx];
                    const dx = enemy.mesh.position.x - spiritMesh.position.x;
                    const dz = enemy.mesh.position.z - spiritMesh.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    // Move toward enemy
                    if (dist > 2) {
                        spiritMesh.position.x += (dx / dist) * 5 * deltaTime;
                        spiritMesh.position.z += (dz / dist) * 5 * deltaTime;
                    } else {
                        // Attack
                        spiritMesh.attackTimer -= deltaTime;
                        if (spiritMesh.attackTimer <= 0) {
                            dealDamageToEnemy(nearestIdx, 15);
                            spiritMesh.attackTimer = 1;
                        }
                    }
                }
            }
        }

        // Track if attack has hit this swing
        let hasHitThisSwing = false;

        // Sword swing animation state
        let isSwinging = false;
        let swingProgress = 0;
        let currentAttack = 0;
        const totalAttacks = 4;
        const swingDuration = 0.35; // seconds

        // Parry state
        let isParrying = false;

        // Attack animation definitions
        // Sword default rotation is Math.PI/2 on X (blade pointing forward, handle in hand)
        const attacks = [
            {
                name: 'Horizontal Slash',
                duration: 0.3,
                animate: (t) => {
                    // Arm extends forward and swings across horizontally
                    const easeT = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
                    rightArmPivot.rotation.x = -Math.PI / 3 * easeT; // Arm forward
                    rightArmPivot.rotation.y = 0.8 - 2.0 * easeT; // Swing from right to left
                    rightArmPivot.rotation.z = -0.2;
                    swordPivot.rotation.x = defaultSwordRotX;
                    swordPivot.rotation.y = 0;
                }
            },
            {
                name: 'Overhead Slash',
                duration: 0.4,
                animate: (t) => {
                    // Raise sword overhead then slash down in front
                    if (t < 0.35) {
                        // Wind up - raise arm and sword above head
                        const phase = t / 0.35;
                        rightArmPivot.rotation.x = Math.PI * 0.6 * phase; // Arm back/up
                        rightArmPivot.rotation.z = -0.3 * phase;
                        swordPivot.rotation.x = defaultSwordRotX + Math.PI * 0.3 * phase;
                    } else {
                        // Slash down in front
                        const phase = (t - 0.35) / 0.65;
                        const slashT = phase * phase * (3 - 2 * phase);
                        rightArmPivot.rotation.x = Math.PI * 0.6 - Math.PI * 1.0 * slashT; // Swing down
                        rightArmPivot.rotation.z = -0.3 + 0.2 * slashT;
                        swordPivot.rotation.x = defaultSwordRotX + Math.PI * 0.3 - Math.PI * 0.5 * slashT;
                    }
                }
            },
            {
                name: 'Diagonal Slash',
                duration: 0.35,
                animate: (t) => {
                    // Diagonal slash from upper right to lower left
                    const easeT = t * t * (3 - 2 * t);

                    // Start high right, slash down and across
                    rightArmPivot.rotation.x = -Math.PI / 6 - Math.PI / 3 * easeT;
                    rightArmPivot.rotation.y = 0.6 - 1.8 * easeT;
                    rightArmPivot.rotation.z = -0.5 + 0.3 * easeT;
                    swordPivot.rotation.x = defaultSwordRotX;
                    swordPivot.rotation.z = -Math.PI / 6 * easeT;
                }
            },
            {
                name: 'Thrust',
                duration: 0.25,
                animate: (t) => {
                    // Quick thrust forward - arm extends straight out
                    const easeT = t < 0.4
                        ? (t / 0.4) * (t / 0.4) // Quick acceleration
                        : 1 - Math.pow((t - 0.4) / 0.6, 2) * 0.4; // Hold then retract

                    rightArmPivot.rotation.x = -Math.PI / 2.5 * easeT; // Extend arm forward
                    rightArmPivot.rotation.y = -0.3 * easeT; // Slight inward angle
                    rightArmPivot.rotation.z = 0;
                    swordPivot.rotation.x = defaultSwordRotX - Math.PI / 6 * easeT; // Tilt blade for thrust
                }
            }
        ];

        // First person camera - position at chest height
        const cameraHeight = 1.4; // Chest level, same height as arms
        let cameraRotationY = 0; // Only horizontal rotation (like Minecraft)

        // Player physics
        let velocityY = 0;
        const gravity = -25;
        const jumpForce = 10;
        let isOnGround = true;

        // Movement state
        const keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            space: false
        };
        let spaceJustPressed = false; // For double jump detection

        // Double-tap dodge roll system
        const lastKeyPress = { w: 0, a: 0, s: 0, d: 0 };
        const doubleTapWindow = 250; // ms to detect double tap
        let isDodging = false;
        let dodgeCooldown = 0;
        let isInvincible = false;

        function performDodge(direction) {
            if (isDodging || dodgeCooldown > 0 || gameState !== 'playing') return;

            // Can't dodge at 60% stamina or below, or if stunned
            const staminaPercent = (playerStamina / playerStats.maxStamina) * 100;
            if (staminaPercent <= 60 || isStaminaStunned) {
                showAbilityEffect('Too tired to dodge!');
                return;
            }

            // Cost stamina for dodge
            playerStamina -= playerStats.staminaDodgeCost;
            if (playerStamina < 0) playerStamina = 0;
            updateStaminaUI();

            isDodging = true;
            isInvincible = true;
            dodgeCooldown = 1.0; // 1 second cooldown between dodges
            trackQuestDodge();

            // Void Cloak relic - become invisible after dodging
            if (hasRelic('shadow')) {
                isInvisible = true;
                invisibilityTimer = 1.5;
                showAbilityEffect('ðŸ‘» Vanish!');
            }

            // Calculate dodge direction based on camera
            let dodgeX = 0, dodgeZ = 0;
            const dodgeDistance = 8;

            if (direction === 'w') {
                dodgeX = -Math.sin(cameraRotationY) * dodgeDistance;
                dodgeZ = -Math.cos(cameraRotationY) * dodgeDistance;
            } else if (direction === 's') {
                dodgeX = Math.sin(cameraRotationY) * dodgeDistance;
                dodgeZ = Math.cos(cameraRotationY) * dodgeDistance;
            } else if (direction === 'a') {
                dodgeX = -Math.cos(cameraRotationY) * dodgeDistance;
                dodgeZ = Math.sin(cameraRotationY) * dodgeDistance;
            } else if (direction === 'd') {
                dodgeX = Math.cos(cameraRotationY) * dodgeDistance;
                dodgeZ = -Math.sin(cameraRotationY) * dodgeDistance;
            }

            const startX = player.position.x;
            const startZ = player.position.z;
            const targetX = startX + dodgeX;
            const targetZ = startZ + dodgeZ;

            // Visual effect - afterimages
            showAbilityEffect('DODGE!');

            let dodgeProgress = 0;
            const dodgeInterval = setInterval(() => {
                dodgeProgress += 0.15;

                // Smooth dodge movement
                player.position.x = startX + dodgeX * dodgeProgress;
                player.position.z = startZ + dodgeZ * dodgeProgress;

                // Create afterimage
                if (Math.random() > 0.5) {
                    const ghostGeo = new THREE.BoxGeometry(0.5, 1.5, 0.3);
                    const ghostMat = new THREE.MeshBasicMaterial({
                        color: 0x4488ff,
                        transparent: true,
                        opacity: 0.4
                    });
                    const ghost = new THREE.Mesh(ghostGeo, ghostMat);
                    ghost.position.copy(player.position);
                    ghost.position.y = 1;
                    ghost.rotation.y = cameraRotationY;
                    scene.add(ghost);
                    setTimeout(() => { scene.remove(ghost); }, 150);
                }

                if (dodgeProgress >= 1) {
                    clearInterval(dodgeInterval);
                    isDodging = false;

                    // Brief invincibility after dodge ends
                    setTimeout(() => {
                        isInvincible = false;
                    }, 100);
                }
            }, 20);
        }

        // Mouse state
        const mouseSensitivity = 0.002;

        // Event listeners for keyboard
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();

            // Double-tap dodge detection for WASD
            if (['w', 'a', 's', 'd'].includes(key)) {
                const now = performance.now();
                if (now - lastKeyPress[key] < doubleTapWindow && !keys[key]) {
                    // Double tap detected!
                    performDodge(key);
                }
                lastKeyPress[key] = now;
            }

            if (key === 'w') keys.w = true;
            if (key === 'a') keys.a = true;
            if (key === 's') keys.s = true;
            if (key === 'd') keys.d = true;
            if (key === ' ') {
                if (!keys.space) spaceJustPressed = true; // Track first press
                keys.space = true;
                e.preventDefault();
            }
            // Wizard spell keys
            if (key === 'q' && gameState === 'playing' && currentRunCharacter === 'wizard') {
                castFireball();
            }
            if (key === 'e' && gameState === 'playing' && currentRunCharacter === 'wizard') {
                castHomingBall();
            }
            // Necromancer summon keys
            if (key === 'q' && gameState === 'playing' && currentRunCharacter === 'necromancer') {
                summonSkeletonWarrior();
            }
            if (key === 'e' && gameState === 'playing' && currentRunCharacter === 'necromancer') {
                summonSkeletonArcher();
            }
            // ESC to exit build mode
            if (e.key === 'Escape' && gameState === 'building') {
                exitBuildMode();
            }
        });

        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (key === 'w') keys.w = false;
            if (key === 'a') keys.a = false;
            if (key === 's') keys.s = false;
            if (key === 'd') keys.d = false;
            if (key === ' ') keys.space = false;
        });

        // Pointer lock for mouse control and sword swing
        let pointerLocked = false;

        document.addEventListener('pointerlockchange', () => {
            pointerLocked = document.pointerLockElement === renderer.domElement;
        });

        document.addEventListener('click', () => {
            if (!pointerLocked && gameState === 'playing') {
                renderer.domElement.requestPointerLock();
            }
        });

        document.addEventListener('mousedown', (e) => {
            if (gameState !== 'playing') return;

            // Archer has separate attack handling
            if (pointerLocked && e.button === 0 && characters[currentRunCharacter].special === 'bowAttack') {
                // Archer uses dagger attack (left-click) - restores arrows
                if (canArcherPunch) {
                    performArcherDagger();
                    playAttackAnimation('punch'); // Use punch animation for dagger
                }
                return; // Don't do normal melee attack
            }

            if (pointerLocked && e.button === 0 && !isSwinging && !isParrying && canAttack) {
                isSwinging = true;
                playAttackAnimation('melee');
                swingProgress = 0;
                hasHitThisSwing = false; // Reset hit flag for new attack
                canAttack = false; // Start cooldown
                // Cycle through different attacks
                currentAttack = (currentAttack + 1) % attacks.length;

                // Calculate actual cooldown with modifiers
                let actualCooldown = baseAttackCooldown * playerStats.attackSpeed;
                if (adrenalineActive && playerStats.adrenalineBonus) {
                    actualCooldown *= (1 - playerStats.adrenalineBonus);
                }
                // Berserker's Fang - attack speed increases as HP decreases
                if (hasRelic('berserker')) {
                    const hpPercent = playerHealth / playerStats.maxHealth;
                    const berserkerBonus = (1 - hpPercent) * 0.4; // Up to 40% faster
                    actualCooldown *= (1 - berserkerBonus);
                }
                // Fury Emblem - attack speed boost when recently hit
                if (hasRelic('fury') && furyAttackSpeedTimer > 0) {
                    actualCooldown *= 0.7; // 30% faster
                }

                // Reset cooldown after delay
                setTimeout(() => { canAttack = true; }, actualCooldown * 1000);
            }
            // Archer shoots arrows with right-click (separate handling)
            if (pointerLocked && e.button === 2 && characters[currentRunCharacter].special === 'bowAttack') {
                if (arrowAmmo > 0 && canShootArrow) {
                    shootArrow();
                    playAttackAnimation('arrow');
                }
                return; // Don't parry
            }
            // Right click to parry (non-archer)
            if (pointerLocked && e.button === 2 && !isSwinging) {
                isParrying = true;
            }
        });

        document.addEventListener('mouseup', (e) => {
            // Release parry on right click release (not for archer)
            if (e.button === 2 && characters[currentRunCharacter].special !== 'bowAttack') {
                isParrying = false;
            }
        });

        // Prevent context menu on right click
        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === renderer.domElement && gameState === 'playing') {
                // Only horizontal rotation (like Minecraft, no looking up/down)
                cameraRotationY -= e.movementX * mouseSensitivity;
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Game loop
        let lastTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);

            const currentTime = performance.now();
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            // Update screen shake effect
            updateScreenShake(deltaTime);

            // Update ability cooldowns
            for (const ability of playerAbilities) {
                if (abilityCooldowns[ability.id] > 0) {
                    abilityCooldowns[ability.id] -= deltaTime;
                    if (abilityCooldowns[ability.id] < 0) abilityCooldowns[ability.id] = 0;
                }
            }
            // Update wizard spell cooldowns
            if (currentRunCharacter === 'wizard') {
                if (wizardFireballCooldown > 0) {
                    wizardFireballCooldown -= deltaTime;
                    if (wizardFireballCooldown < 0) wizardFireballCooldown = 0;
                }
                if (wizardHomingCooldown > 0) {
                    wizardHomingCooldown -= deltaTime;
                    if (wizardHomingCooldown < 0) wizardHomingCooldown = 0;
                }
                updateWizardEnergyUI();
            }
            // Update ability bar UI periodically
            if (Math.floor(currentTime / 200) !== Math.floor((currentTime - deltaTime * 1000) / 200)) {
                updateAbilityBar();
                updateStatsPanel();
            }

            // Update relic timers
            if (killStreakTimer > 0) {
                killStreakTimer -= deltaTime;
                if (killStreakTimer <= 0) {
                    killStreakStacks = 0;
                }
            }
            if (hunterSpeedTimer > 0) hunterSpeedTimer -= deltaTime;
            if (temporalSlowCooldown > 0) temporalSlowCooldown -= deltaTime;
            if (furyAttackSpeedTimer > 0) furyAttackSpeedTimer -= deltaTime;

            // Update temporal slow on enemies
            enemies.forEach(e => {
                if (e.temporalSlowed) {
                    e.temporalSlowTimer -= deltaTime;
                    if (e.temporalSlowTimer <= 0) {
                        e.temporalSlowed = false;
                    }
                }
            });

            // Movement speed with multiplier and momentum bonus
            let speedMultiplier = playerStats.moveSpeed;
            if (momentumActive) speedMultiplier += momentumSpeedBonus;
            // Gale Boots relic - +25% movement speed
            if (hasRelic('wind')) speedMultiplier *= 1.25;
            // Hunter's Mark relic - +30% speed after kill
            if (hasRelic('hunter') && hunterSpeedTimer > 0) speedMultiplier *= 1.30;
            // Slow down in water
            if (isInWater(player.position.x, player.position.z)) {
                speedMultiplier *= lake.speedReduction;
            }

            // Stamina effects on movement
            const staminaPercent = (playerStamina / playerStats.maxStamina) * 100;
            if (staminaPercent <= 35 && !isStaminaStunned) {
                speedMultiplier *= 0.7; // 30% slower when tired
            }

            const moveSpeed = 8 * speedMultiplier * deltaTime;

            // Only process game logic when playing
            if (gameState === 'playing') {
                // Check if moving (for stamina drain)
                isMoving = (keys.w || keys.s || keys.a || keys.d) && !isStaminaStunned;

                // Stamina drain/regen logic
                if (isMoving) {
                    // Drain stamina while moving
                    playerStamina -= playerStats.staminaMoveDrain * deltaTime;
                    if (playerStamina <= 0) {
                        playerStamina = 0;
                        isStaminaStunned = true;
                    }
                } else {
                    // Regen stamina when not moving
                    playerStamina += playerStats.staminaRegen * deltaTime;
                    if (playerStamina >= playerStats.maxStamina) {
                        playerStamina = playerStats.maxStamina;
                    }
                    // Recover from stun at 10%
                    if (isStaminaStunned && playerStamina >= playerStats.maxStamina * 0.1) {
                        isStaminaStunned = false;
                    }
                }
                updateStaminaUI();

                // Simple movement - W/S forward/back, A/D strafe left/right
                // Store old position for collision
                const oldX = player.position.x;
                const oldZ = player.position.z;

                // Can't move if stamina stunned
                if (!isStaminaStunned) {
                    if (keys.w) {
                        player.position.x -= Math.sin(cameraRotationY) * moveSpeed;
                        player.position.z -= Math.cos(cameraRotationY) * moveSpeed;
                    }
                    if (keys.s) {
                        player.position.x += Math.sin(cameraRotationY) * moveSpeed;
                        player.position.z += Math.cos(cameraRotationY) * moveSpeed;
                    }
                    if (keys.a) {
                        player.position.x -= Math.cos(cameraRotationY) * moveSpeed;
                        player.position.z += Math.sin(cameraRotationY) * moveSpeed;
                    }
                    if (keys.d) {
                        player.position.x += Math.cos(cameraRotationY) * moveSpeed;
                        player.position.z -= Math.sin(cameraRotationY) * moveSpeed;
                    }
                }

                // Check tree collision - revert if blocked
                if (collidesWithObstacle(player.position.x, player.position.z, player.position.y)) {
                    player.position.x = oldX;
                    player.position.z = oldZ;
                }

                // Jump (with Storm Feather double jump)
                if (keys.space && isOnGround) {
                    velocityY = jumpForce;
                    isOnGround = false;
                    hasDoubleJumped = false;
                } else if (spaceJustPressed && !isOnGround && !hasDoubleJumped && hasRelic('sky')) {
                    // Double jump from Storm Feather relic
                    velocityY = jumpForce * 0.85;
                    hasDoubleJumped = true;
                    createHitEffect(player.position.x, player.position.y, player.position.z, 0xaaddff);
                }
                spaceJustPressed = false; // Reset after processing

                // Apply gravity
                velocityY += gravity * deltaTime;
                player.position.y += velocityY * deltaTime;

                // Ground and obstacle collision
                const obstacleBelow = getObstacleAt(player.position.x, player.position.z);
                const groundLevel = obstacleBelow ? obstacleBelow.height : 0;

                if (player.position.y <= groundLevel) {
                    player.position.y = groundLevel;
                    velocityY = 0;
                    isOnGround = true;
                    hasDoubleJumped = false;
                }

                // Update enemy AI
                updateEnemyAI(deltaTime);

                // Update relic effects
                updateHealingOrbs(deltaTime);
                updateGhostAllies(deltaTime);
                if (invisibilityTimer > 0) {
                    invisibilityTimer -= deltaTime;
                    if (invisibilityTimer <= 0) {
                        isInvisible = false;
                    }
                }

                // Update boss health bar
                if (currentBoss) {
                    if (!currentBoss.mesh || currentBoss.health <= 0) {
                        hideBossHealthBar();
                    } else {
                        updateBossHealthBar();
                    }
                }

                // Regenerate health
                regenHealth(deltaTime);

                // Update dodge cooldown
                if (dodgeCooldown > 0) {
                    dodgeCooldown -= deltaTime;
                }
            }

            // Sword swing animation (third person model)
            if (isSwinging) {
                const attack = attacks[currentAttack];
                swingProgress += deltaTime / attack.duration;

                // Check for hit at the peak of the swing (40-60%)
                if (swingProgress >= 0.4 && swingProgress <= 0.7 && !hasHitThisSwing) {
                    attackEnemies();
                    hasHitThisSwing = true;
                }

                if (swingProgress >= 1) {
                    swingProgress = 1;
                    isSwinging = false;
                    // Reset to idle pose
                    rightArmPivot.rotation.set(0, 0, 0);
                    swordPivot.rotation.set(defaultSwordRotX, 0, 0);
                } else {
                    // Run the attack animation
                    attack.animate(swingProgress);
                }
            } else if (isParrying) {
                // Parry stance - sword raised horizontally in front to block
                rightArmPivot.rotation.x = -Math.PI / 3; // Arm raised forward
                rightArmPivot.rotation.y = -0.4; // Slightly across body
                rightArmPivot.rotation.z = -0.2;
                swordPivot.rotation.x = defaultSwordRotX + Math.PI / 4; // Blade angled up
                swordPivot.rotation.z = Math.PI / 2; // Sword horizontal for blocking
            } else {
                // Idle sword position - blade pointing forward
                rightArmPivot.rotation.x = 0;
                rightArmPivot.rotation.y = 0;
                rightArmPivot.rotation.z = 0;
                swordPivot.rotation.set(defaultSwordRotX, 0, 0);
            }

            // First-person arm animation (always visible on screen)
            if (isSwinging) {
                // FP attack animations
                const t = swingProgress;
                if (currentAttack === 0) {
                    // Horizontal slash
                    const easeT = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
                    fpArmPivot.rotation.x = -0.3 * easeT;
                    fpArmPivot.rotation.y = 0.5 - 1.2 * easeT;
                    fpArmPivot.rotation.z = 0;
                    fpSwordPivot.rotation.x = fpDefaultSwordRotX;
                } else if (currentAttack === 1) {
                    // Overhead slash
                    if (t < 0.35) {
                        const phase = t / 0.35;
                        fpArmPivot.rotation.x = 0.8 * phase;
                        fpArmPivot.rotation.z = -0.2 * phase;
                        fpSwordPivot.rotation.x = fpDefaultSwordRotX + 0.3 * phase;
                    } else {
                        const phase = (t - 0.35) / 0.65;
                        fpArmPivot.rotation.x = 0.8 - 1.2 * phase;
                        fpArmPivot.rotation.z = -0.2 + 0.1 * phase;
                        fpSwordPivot.rotation.x = fpDefaultSwordRotX + 0.3 - 0.5 * phase;
                    }
                } else if (currentAttack === 2) {
                    // Diagonal slash
                    const easeT = t * t * (3 - 2 * t);
                    fpArmPivot.rotation.x = -0.2 - 0.4 * easeT;
                    fpArmPivot.rotation.y = 0.4 - 1.0 * easeT;
                    fpArmPivot.rotation.z = -0.3 + 0.2 * easeT;
                    fpSwordPivot.rotation.z = -0.3 * easeT;
                } else {
                    // Thrust
                    const easeT = t < 0.4 ? (t / 0.4) * (t / 0.4) : 1 - Math.pow((t - 0.4) / 0.6, 2) * 0.4;
                    fpArmPivot.rotation.x = -0.5 * easeT;
                    fpArmPivot.rotation.y = -0.2 * easeT;
                    fpArmPivot.rotation.z = 0;
                    fpSwordPivot.rotation.x = fpDefaultSwordRotX - 0.3 * easeT;
                }
            } else if (isParrying) {
                // FP Parry stance - sword raised horizontally to block
                fpArmPivot.rotation.x = -0.5;
                fpArmPivot.rotation.y = -0.3;
                fpArmPivot.rotation.z = 0;
                fpSwordPivot.rotation.x = fpDefaultSwordRotX + 0.4;
                fpSwordPivot.rotation.z = Math.PI / 2; // Horizontal blocking position
            } else {
                // FP Idle position
                fpArmPivot.rotation.x = 0;
                fpArmPivot.rotation.y = 0;
                fpArmPivot.rotation.z = 0;
                fpSwordPivot.rotation.set(fpDefaultSwordRotX, 0, 0);
            }

            // First person camera - position at player's head
            camera.position.set(
                player.position.x,
                player.position.y + cameraHeight,
                player.position.z
            );

            // Look forward based on rotation (no up/down)
            const lookDir = new THREE.Vector3(
                -Math.sin(cameraRotationY),
                0,
                -Math.cos(cameraRotationY)
            );
            const lookTarget = camera.position.clone().add(lookDir);
            camera.lookAt(lookTarget);

            // Rotate player model to match camera direction
            player.rotation.y = cameraRotationY;

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
